

[fusing <<421>>] 
fun (n: nat) -> 
fun (xs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $drop<$0> n[2] xs[3]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ($take<$0> n xs)


[yielding <<421>>] 
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $drop<$0> n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> $drop<$0> n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end


[dec-free from]
(
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $drop<$0> n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> $drop<$0> n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end) n xs


[dec-free context]

fun (take: nat -> list -> nat -> list -> list) -> 
fun (n: nat) -> 
fun (xs: list) -> take n xs n xs


[dec-free expressed fix]

fun (n: nat) -> 
fun (xs: list) -> (
fix (take: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $drop<$0> n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> $drop<$0> n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n[2] xs[2] n' ys)
    end
  end) n xs n xs


[fusing <<422>>] 
fun (n: nat) -> 
fun (xs: list) -> (
fix (take: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $drop<$0> n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> $drop<$0> n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n[2] xs[2] n' ys)
    end
  end) n xs n xs


[yielding <<422>>] 
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end
Cases: 

[fusing <<423>>] 
fun (n: nat) -> 
fun (xs: list) -> (
fix (count: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (count ys)
    else count ys
  end) ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: nat) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<423>>] 
fix (app: nat -> list -> nat) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (count: list -> nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 0
      | Cons (y: nat) (ys: list) -> 
        if $eq n y
        then Suc (count ys)
        else count ys
      end) ys
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (app n ys)
    else app n ys
  end


[fusing <<424>>] 
fun (ys: list) -> 
fun (xs: list) -> (
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> (
    fix (count: list -> nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 0
      | Cons (y: nat) (ys: list) -> 
        if $eq n y
        then Suc (count ys)
        else count ys
      end) ys
  | Suc (x': nat) -> Suc (add x')
  end) ((
fix (count: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (count ys)
    else count ys
  end) xs)


[fusing <<425>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $eq x y[2] in $eq x y


[yielding <<425>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in 
      assert True <- $eq x' y' in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in 
      assert True <- $eq x' y' in eq x' y' y'[2]
    end
  end


[fusing <<426>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $eq x y[2] in $eq x y


[yielding <<426>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert Suc (y': nat) <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      match y[2] with
      | 0 -> False
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in False
      end
    | Suc (y': nat) -> 
      match y[2] with
      | 0 -> (
        fix<426> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in eq x' y' y'[2]
      end
    end
  end


[yielding <<424>>] 
fix (count: list -> list -> nat) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (count: list -> nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 0
      | Cons (y: nat) (ys: list) -> 
        if $eq n y
        then Suc (count ys)
        else count ys
      end) ys
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (count ys[2] ys)
    else count ys[2] ys
  end


[rep-arg orig]
$eq n n


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[fusing <<427>>] 
fun (x: nat) -> 
fun (y: nat) -> $eq x x


[yielding <<427>>] 
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x' _|_
  end


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _1


[guess]
True


[guess check]
True


[fusing <<428>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $eq x y[2] in $eq x y


[yielding <<428>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in 
      assert True <- $eq x' y' in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in 
      assert True <- $eq x' y' in eq x' y' y'[2]
    end
  end


[fusing <<429>>] 
fun (x: nat) -> 
fun (n: nat) -> $minus x ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> m
  | Suc (x': nat) -> Suc (add x')
  end) x)


[yielding <<429>>] 
fix (add: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (n: nat) -> 
  match x with
  | 0 -> 
    match m with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Suc (x': nat) -> add x' _|_
  end


[orig]
(
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match _2 with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Suc (x': nat) -> add x'
  end) _1


[guess]
0


[guess check]
0


[fusing <<430>>] 
fun (y: nat) -> 
fun (n: nat) -> $minus ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> m
  | Suc (x': nat) -> Suc (add x')
  end) y) y


[yielding <<430>>] 
fix (add: nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  match y with
  | 0 -> m
  | Suc (x': nat) -> add x' _|_
  end


[orig]
(
fix (add: nat -> nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> _2
  | Suc (x': nat) -> add x'
  end) _1


[guess]
_0


[guess check]
_0


[fusing <<431>>] 
fun (x: nat) -> 
fun (k: nat) -> $minus x ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add x')
  end) k)


[yielding <<431>>] 
fix (add: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (k: nat) -> 
  match k with
  | 0 -> $minus x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> add x' x'[2]
    end
  end


[fusing <<432>>] 
fun (n: nat) -> 
fun (k: nat) -> 
fun (k: nat) -> (
fix (add: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (k: nat) -> 
  match k with
  | 0 -> $minus x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> add x' x'[2]
    end
  end) ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> m
  | Suc (x': nat) -> Suc (add x')
  end) k[2]) k[2]


[yielding <<432>>] 
fix (add: nat -> nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (k: nat) -> 
  fun (k: nat) -> 
  match k[2] with
  | 0 -> $minus m n
  | Suc (x': nat) -> add n x' _|_
  end


[orig]
(
fix (add: nat -> nat) -> 
  fun (k: nat) -> 
  match k with
  | 0 -> (
    fix (minus: nat -> nat -> nat) -> 
      fun (x: nat) -> 
      fun (y: nat) -> 
      match y with
      | 0 -> x
      | Suc (y': nat) -> 
        match x with
        | 0 -> 0
        | Suc (x': nat) -> minus x' y'
        end
      end) _3 _2
  | Suc (x': nat) -> add x'
  end) _2


[guess]
(
fix (minus: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> x
  | Suc (y': nat) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> minus x' y'
    end
  end) _1 _0


[guess check]
(
fix (minus: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> x
  | Suc (y': nat) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> minus x' y'
    end
  end) _1 _0


[fusing <<433>>] 
fun (y: nat) -> 
fun (n: nat) -> 
fun (m: nat) -> $minus ($minus n m) y


[yielding <<433>>] 
fix (minus: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $minus n y
  | Suc (y': nat) -> 
    match n with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (x': nat) -> minus y x' y'
    end
  end


[leq from]
((
fix (add: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (k: nat) -> 
  match k with
  | 0 -> $minus x k[2]
  | Suc (x': nat) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> add x' x'[2]
    end
  end) n m =< (
fix (minus: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $minus n k
  | Suc (y': nat) -> 
    match n with
    | 0 -> 
      match k with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (x': nat) -> minus x' y'
    end
  end) n m)


[leq to]
(
match m with
| 0 -> $minus n k
| Suc (x': nat) -> 
  match n with
  | 0 -> 0
  | Suc (x': nat) -> (
    fun (x: nat) -> 
    fun (k: nat) -> (
    fix (minus: nat -> nat -> nat) -> 
      fun (n: nat) -> 
      fun (m: nat) -> 
      match m with
      | 0 -> $minus n k[2]
      | Suc (y': nat) -> 
        match n with
        | 0 -> 
          match k[2] with
          | 0 -> 0
          | Suc (y': nat) -> 0
          end
        | Suc (x': nat) -> minus x' y'
        end
      end) x k) x' x'[2]
  end
end =< (
fix (minus: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $minus n k
  | Suc (y': nat) -> 
    match n with
    | 0 -> 
      match k with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (x': nat) -> minus x' y'
    end
  end) n m)


[leq from]
((
fix (minus: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $minus n k
  | Suc (y': nat) -> 
    match n with
    | 0 -> 
      match k with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (x': nat) -> minus x' y'
    end
  end) n m =< (
fix (add: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (k: nat) -> 
  match k with
  | 0 -> $minus x k[2]
  | Suc (x': nat) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> add x' x'[2]
    end
  end) n m)


[leq to]
(
match m with
| 0 -> $minus n k
| Suc (y': nat) -> 
  match n with
  | 0 -> 
    match k with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Suc (x': nat) -> (
    fun (n: nat) -> 
    fun (m: nat) -> (
    fix (add: nat -> nat -> nat) -> 
      fun (x: nat) -> 
      fun (k: nat) -> 
      match k with
      | 0 -> $minus x k[2]
      | Suc (x': nat) -> 
        match x with
        | 0 -> 0
        | Suc (x': nat) -> add x' x'[2]
        end
      end) n m) x' y'
  end
end =< (
fix (add: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (k: nat) -> 
  match k with
  | 0 -> $minus x k[2]
  | Suc (x': nat) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> add x' x'[2]
    end
  end) n m)


[rep-arg orig]
$minus n n


[rep-arg ctx]

fun (minus: nat -> nat -> nat) -> 
fun (x: nat) -> 
fun (y: nat) -> minus x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $minus x x


[fusing <<434>>] 
fun (x: nat) -> 
fun (y: nat) -> $minus x x


[yielding <<434>>] 
fix (minus: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 0
  | Suc (y': nat) -> minus y' _|_
  end


[orig]
(
fix (minus: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 0
  | Suc (y': nat) -> minus y'
  end) _0


[guess]
0


[guess check]
0


[fusing <<435>>] 
fun (f: A -> B) -> 
fun (n: nat) -> 
fun (xs: list) -> $map<$0, $0> f ($drop<$0> n xs)


[yielding <<435>>] 
fix (drop: (A -> B) -> nat -> list -> list) -> 
  fun (f: A -> B) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $map<$0, $0> f xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> drop f n' ys
    end
  end


[fusing <<436>>] 
fun (n: nat) -> 
fun (xs: list) -> $drop<$0> n ($map<$0, $0> f xs)


[yielding <<436>>] 
fix (map: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Cons (f y) ((
      fix<436> (map: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> Nil
        | Cons (y: A) (ys: list) -> Cons (f y) (map ys)
        end) ys)
    | Suc (n': nat) -> map n' ys
    end
  end


[leq from]
((
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $map<$0, $0> f xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs =< (
fix (map: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Cons (f y) ($map<$0, $0> f ys)
    | Suc (n': nat) -> map n' ys
    end
  end) n xs)


[leq to]
(
match n with
| 0 -> $map<$0, $0> f xs
| Suc (n': nat) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> (
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (map: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match n with
        | 0 -> Nil
        | Suc (n': nat) -> Nil
        end
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Cons (f y) ($map<$0, $0> f ys)
        | Suc (n': nat) -> map n' ys
        end
      end) n xs) n' ys
  end
end =< (
fix (map: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Cons (f y) ($map<$0, $0> f ys)
    | Suc (n': nat) -> map n' ys
    end
  end) n xs)


[leq from]
((
fix (map: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Cons (f y) ($map<$0, $0> f ys)
    | Suc (n': nat) -> map n' ys
    end
  end) n xs =< (
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $map<$0, $0> f xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs)


[leq to]
(
match xs with
| Nil -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> Nil
  end
| Cons (y: A) (ys: list) -> 
  match n with
  | 0 -> Cons (f y) ($map<$0, $0> f ys)
  | Suc (n': nat) -> (
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (drop: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match n with
      | 0 -> $map<$0, $0> f xs
      | Suc (n': nat) -> 
        match xs with
        | Nil -> Nil
        | Cons (y: A) (ys: list) -> drop n' ys
        end
      end) n xs) n' ys
  end
end =< (
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $map<$0, $0> f xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs)


[fusing <<437>>] 
fun (ys: list) -> 
fun (xs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $filter<$0> p ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ($filter<$0> p xs)


[yielding <<437>>] 
fix (filter: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $filter<$0> p ys
  | Cons (y: A) (ys: list) -> 
    if p y
    then Cons y (filter ys[2] ys)
    else filter ys[2] ys
  end


[fusing <<438>>] 
fun (p: A -> bool) -> 
fun (xs: list) -> $filter<$0> p ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<438>>] 
fix (app: (A -> bool) -> list -> list) -> 
  fun (p: A -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $filter<$0> p ys
  | Cons (y: A) (ys: list) -> 
    if p y
    then Cons y (app p ys)
    else app p ys
  end


[fusing <<439>>] 
fun (xs: list) -> $length<nat> ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons n Nil
  | Cons (y: nat) (ys: list) -> 
    if $le n y
    then Cons n (Cons y ys)
    else Cons y (ins ys)
  end) xs)


[fusing <<440>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $le x y


[yielding <<440>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $le x' y' in False
    end
  | Suc (y': nat) -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> (
      fix<440> (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) x' y'
    | Suc (y': nat) -> 
      assert False <- $le x' y' in le x' y' y'[2]
    end
  end


[yielding <<439>>] 
fix (ins: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Suc 0
  | Cons (y: nat) (ys: list) -> 
    if $le n y
    then Suc (Suc ($length<nat> ys))
    else Suc (ins ys)
  end


[leq from]
((
fix (ins: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Suc 0
  | Cons (y: nat) (ys: list) -> 
    if $le n y
    then Suc (Suc ($length<nat> ys))
    else Suc (ins ys)
  end) xs =< Suc ($length<nat> xs))


[leq to]
(
match xs with
| Nil -> Suc 0
| Cons (y: nat) (ys: list) -> 
  if $le n y
  then Suc (Suc ($length<nat> ys))
  else Suc ((
    fun (xs: list) -> Suc ($length<nat> xs)) ys)
end =< Suc ($length<nat> xs))


[fusing <<441>>] 
fun (x: nat) -> 
fun (x0: nat) -> $lt x (Suc x0)


[yielding <<441>>] 
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x0: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x0 with
    | 0 -> 
      match x' with
      | 0 -> False
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end


[fusing <<442>>] 
fun (x: nat) -> 
fun (n: nat) -> (
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x0: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x0 with
    | 0 -> 
      match x' with
      | 0 -> False
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> m
  | Suc (x': nat) -> Suc (add x')
  end) x)


[yielding <<442>>] 
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (n: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> add x' _|_
  end


[orig]
(
fix (add: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> add x'
  end) _1


[guess]
True


[guess check]
True


[fusing <<443>>] 
fun (y: nat) -> 
fun (xs: list) -> $minus ($length<$0> xs) y


[yielding <<443>>] 
fix (len: nat -> list -> nat) -> 
  fun (y: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match y with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Cons (y: A) (ys: list) -> 
    match y[2] with
    | 0 -> Suc ((
      fix<443> (len: list -> nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 0
        | Cons (y: A) (ys: list) -> Suc (len ys)
        end) ys)
    | Suc (y': nat) -> len y' ys
    end
  end


[fusing <<444>>] 
fun (n: nat) -> 
fun (xs: list) -> $length<$0> ($drop<$0> n xs)


[yielding <<444>>] 
fix (drop: nat -> list -> nat) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $length<$0> xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 0
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end


[leq from]
((
fix (len: nat -> list -> nat) -> 
  fun (y: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match y with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Cons (y: A) (ys: list) -> 
    match y[2] with
    | 0 -> Suc ($length<$0> ys)
    | Suc (y': nat) -> len y' ys
    end
  end) n xs =< (
fix (drop: nat -> list -> nat) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $length<$0> xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 0
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs)


[leq to]
(
match xs with
| Nil -> 
  match n with
  | 0 -> 0
  | Suc (y': nat) -> 0
  end
| Cons (y: A) (ys: list) -> 
  match n with
  | 0 -> Suc ($length<$0> ys)
  | Suc (y': nat) -> (
    fun (y: nat) -> 
    fun (xs: list) -> (
    fix (drop: nat -> list -> nat) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match n with
      | 0 -> $length<$0> xs
      | Suc (n': nat) -> 
        match xs with
        | Nil -> 0
        | Cons (y: A) (ys: list) -> drop n' ys
        end
      end) y xs) y' ys
  end
end =< (
fix (drop: nat -> list -> nat) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $length<$0> xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 0
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs)


[leq from]
((
fix (drop: nat -> list -> nat) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $length<$0> xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 0
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs =< (
fix (len: nat -> list -> nat) -> 
  fun (y: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match y with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Cons (y: A) (ys: list) -> 
    match y[2] with
    | 0 -> Suc ($length<$0> ys)
    | Suc (y': nat) -> len y' ys
    end
  end) n xs)


[leq to]
(
match n with
| 0 -> $length<$0> xs
| Suc (n': nat) -> 
  match xs with
  | Nil -> 0
  | Cons (y: A) (ys: list) -> (
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (len: nat -> list -> nat) -> 
      fun (y: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match y with
        | 0 -> 0
        | Suc (y': nat) -> 0
        end
      | Cons (y: A) (ys: list) -> 
        match y[2] with
        | 0 -> Suc ($length<$0> ys)
        | Suc (y': nat) -> len y' ys
        end
      end) n xs) n' ys
  end
end =< (
fix (len: nat -> list -> nat) -> 
  fun (y: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match y with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Cons (y: A) (ys: list) -> 
    match y[2] with
    | 0 -> Suc ($length<$0> ys)
    | Suc (y': nat) -> len y' ys
    end
  end) n xs)


[fusing <<445>>] 
fun (xs: list) -> $length<nat> ($insertsort xs)


[discovery prop (before)]

fun (g: list) -> ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Cons y[2] (Cons y ys)
    else Cons y (ins ys)
  end) g =< (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<nat> g))


[fusing <<446>>] 
fun (c1: list -> list) -> 
fun (c0: list) -> 
fun (g: list) -> (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<nat> g)


[yielding <<446>>] 
fix (len: (list -> list) -> list -> list -> list) -> 
  fun (c1: list -> list) -> 
  fun (c0: list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c1 (len c1 c0 ys)
  end


[leq from]
((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Cons y[2] (Cons y ys)
    else Cons y (ins ys)
  end) g =< (
fix (len: list -> list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c1 (len ys)
  end) g)


[leq to]
(
match g with
| Nil -> Cons y Nil
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then Cons y[2] (Cons y ys)
  else Cons y ((
    fun (xs: list) -> (
    fix (len: list -> list) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) xs) ys)
end =< (
fix (len: list -> list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c1 (len ys)
  end) g)


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (Cons y Nil =< c0)
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then (Cons y[2] (Cons y ys) =< c1 ((
    fix (len: list -> list) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys))
  else (Cons y ((
    fix (len: list -> list) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys) =< c1 ((
    fix (len: list -> list) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys))
end


[discovery prop (before)]

fun (g: list) -> ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Cons y[2] (Cons y ys)
    else Cons y (ins ys)
  end) g =< (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<nat> g))


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (Cons y Nil =< c0)
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then (Cons y[2] (Cons y ys) =< c1 ((
    fix (len: list -> list) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys))
  else (Cons y ((
    fix (len: list -> list) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys) =< c1 ((
    fix (len: list -> list) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys))
end


[discovery prop (before)]

fun (g: list) -> ((
fix (ins: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Suc ($length<nat> ys)
    else Suc (ins ys)
  end) g =< (
fix (fold[nat]: nat -> nat) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<nat> g))


[fusing <<447>>] 
fun (c1: nat -> nat) -> 
fun (c0: nat) -> 
fun (g: list) -> (
fix (fold[nat]: nat -> nat) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<nat> g)


[yielding <<447>>] 
fix (len: (nat -> nat) -> nat -> list -> nat) -> 
  fun (c1: nat -> nat) -> 
  fun (c0: nat) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c1 (len c1 c0 ys)
  end


[leq from]
((
fix (ins: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Suc ($length<nat> ys)
    else Suc (ins ys)
  end) g =< (
fix (len: list -> nat) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c1 (len ys)
  end) g)


[leq to]
(
match g with
| Nil -> 0
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then Suc ($length<nat> ys)
  else Suc ((
    fun (xs: list) -> (
    fix (len: list -> nat) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) xs) ys)
end =< (
fix (len: list -> nat) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c1 (len ys)
  end) g)


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (0 =< c0)
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then (Suc ($length<nat> ys) =< c1 ((
    fix (len: list -> nat) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys))
  else (Suc ((
    fix (len: list -> nat) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys) =< c1 ((
    fix (len: list -> nat) -> 
      fun (g: list) -> 
      match g with
      | Nil -> c0
      | Cons (y: nat) (ys: list) -> c1 (len ys)
      end) ys))
end


[hopefully true (before)]

match (
fix<445> (isort: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: nat) (ys: list) -> (
    fix (ins: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons y Nil
      | Cons (y: nat) (ys: list) -> 
        if $le y[2] y
        then Cons y[2] (Cons y ys)
        else Cons y (ins ys)
      end) (isort ys)
  end) ys with
| Nil -> (0 =< 0)
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then (Suc ($length<nat> ys) =< Suc ($length<nat> ys))
  else (Suc ($length<nat> ys) =< Suc ($length<nat> ys))
end


[hopefully true]
tt


[yielding <<445>>] $length<nat>


[fusing <<448>>] 
fun (x: nat) -> 
fun (n: nat) -> $le x ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> m
  | Suc (x': nat) -> Suc (add x')
  end) x)


[yielding <<448>>] 
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (n: nat) -> 
  match x with
  | 0 -> 
    match m with
    | 0 -> True
    | Suc (y': nat) -> True
    end
  | Suc (x': nat) -> add x' _|_
  end


[orig]
(
fix (add: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match _2 with
    | 0 -> True
    | Suc (y': nat) -> True
    end
  | Suc (x': nat) -> add x'
  end) _1


[guess]
True


[guess check]
True


[fusing <<449>>] 
fun (x: nat) -> 
fun (m: nat) -> 
fun (k: nat) -> $max x ($max m k)


[yielding <<449>>] 
fix (max: nat -> nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  fun (k: nat) -> 
  match m with
  | 0 -> $max x k
  | Suc (x': nat) -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> Suc x'
      | Suc (x': nat) -> Suc ($max x' x'[2])
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> Suc ((
        fix<449> (max: nat -> nat -> nat) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> y
          | Suc (x': nat) -> 
            match y with
            | 0 -> Suc x'
            | Suc (y': nat) -> Suc (max x' y')
            end
          end) x' y')
      | Suc (x': nat) -> Suc (max x' x'[2] y')
      end
    end
  end


[fusing <<450>>] 
fun (y: nat) -> 
fun (n: nat) -> 
fun (m: nat) -> $max ($max n m) y


[yielding <<450>>] 
fix (max: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> $max m y
  | Suc (x': nat) -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> Suc x'
      | Suc (y': nat) -> Suc ($max x' y')
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> Suc ((
        fix<450> (max: nat -> nat -> nat) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> y
          | Suc (x': nat) -> 
            match y with
            | 0 -> Suc x'
            | Suc (y': nat) -> Suc (max x' y')
            end
          end) x' y')
      | Suc (y': nat) -> Suc (max y' x' y'[2])
      end
    end
  end


[leq from]
((
fix (max: nat -> nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  fun (k: nat) -> 
  match m with
  | 0 -> $max x k
  | Suc (x': nat) -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> Suc x'
      | Suc (x': nat) -> Suc ($max x' x'[2])
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> Suc ($max x' y')
      | Suc (x': nat) -> Suc (max x' x'[2] y')
      end
    end
  end) n m k =< (
fix (max: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> $max m y
  | Suc (x': nat) -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> Suc x'
      | Suc (y': nat) -> Suc ($max x' y')
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> Suc ($max x' y')
      | Suc (y': nat) -> Suc (max y' x' y'[2])
      end
    end
  end) k n m)


[leq to]
(
match m with
| 0 -> $max n k
| Suc (x': nat) -> 
  match k with
  | 0 -> 
    match n with
    | 0 -> Suc x'
    | Suc (x': nat) -> Suc ($max x' x'[2])
    end
  | Suc (y': nat) -> 
    match n with
    | 0 -> Suc ($max x' y')
    | Suc (x': nat) -> Suc ((
      fun (x: nat) -> 
      fun (m: nat) -> 
      fun (k: nat) -> (
      fix (max: nat -> nat -> nat -> nat) -> 
        fun (y: nat) -> 
        fun (n: nat) -> 
        fun (m: nat) -> 
        match n with
        | 0 -> $max m y
        | Suc (x': nat) -> 
          match m with
          | 0 -> 
            match y with
            | 0 -> Suc x'
            | Suc (y': nat) -> Suc ($max x' y')
            end
          | Suc (y': nat) -> 
            match y with
            | 0 -> Suc ($max x' y')
            | Suc (y': nat) -> Suc (max y' x' y'[2])
            end
          end
        end) k x m) x' x'[2] y')
    end
  end
end =< (
fix (max: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> $max m y
  | Suc (x': nat) -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> Suc x'
      | Suc (y': nat) -> Suc ($max x' y')
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> Suc ($max x' y')
      | Suc (y': nat) -> Suc (max y' x' y'[2])
      end
    end
  end) k n m)


[leq from]
((
fix (max: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> $max m y
  | Suc (x': nat) -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> Suc x'
      | Suc (y': nat) -> Suc ($max x' y')
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> Suc ($max x' y')
      | Suc (y': nat) -> Suc (max y' x' y'[2])
      end
    end
  end) k n m =< (
fix (max: nat -> nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  fun (k: nat) -> 
  match m with
  | 0 -> $max x k
  | Suc (x': nat) -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> Suc x'
      | Suc (x': nat) -> Suc ($max x' x'[2])
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> Suc ($max x' y')
      | Suc (x': nat) -> Suc (max x' x'[2] y')
      end
    end
  end) n m k)


[leq to]
(
match n with
| 0 -> $max m k
| Suc (x': nat) -> 
  match m with
  | 0 -> 
    match k with
    | 0 -> Suc x'
    | Suc (y': nat) -> Suc ($max x' y')
    end
  | Suc (y': nat) -> 
    match k with
    | 0 -> Suc ($max x' y')
    | Suc (y': nat) -> Suc ((
      fun (y: nat) -> 
      fun (n: nat) -> 
      fun (m: nat) -> (
      fix (max: nat -> nat -> nat -> nat) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        fun (k: nat) -> 
        match m with
        | 0 -> $max x k
        | Suc (x': nat) -> 
          match k with
          | 0 -> 
            match x with
            | 0 -> Suc x'
            | Suc (x': nat) -> Suc ($max x' x'[2])
            end
          | Suc (y': nat) -> 
            match x with
            | 0 -> Suc ($max x' y')
            | Suc (x': nat) -> Suc (max x' x'[2] y')
            end
          end
        end) n m y) y' x' y'[2])
    end
  end
end =< (
fix (max: nat -> nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  fun (k: nat) -> 
  match m with
  | 0 -> $max x k
  | Suc (x': nat) -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> Suc x'
      | Suc (x': nat) -> Suc ($max x' x'[2])
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> Suc ($max x' y')
      | Suc (x': nat) -> Suc (max x' x'[2] y')
      end
    end
  end) n m k)


[fusing <<451>>] 
fun (y: nat) -> 
fun (n: nat) -> 
fun (m: nat) -> $eq ($max y m) y


[rep-arg orig]
$eq x' x'


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _0


[guess]
True


[guess check]
True


[yielding <<451>>] 
fix (max: nat -> nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match y with
  | 0 -> 
    match m with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Suc (x': nat) -> 
    match m with
    | 0 -> True
    | Suc (y': nat) -> max x' _|_ y'
    end
  end


[fusing <<452>>] 
fun (y: nat) -> 
fun (m: nat) -> 
assert True <- (
fix (max: nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (m: nat) -> 
  match y with
  | 0 -> 
    match m with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Suc (x': nat) -> 
    match m with
    | 0 -> True
    | Suc (y': nat) -> max x' y'
    end
  end) y m in $le m y


[failing <<452>>] 
fix (le: nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (m: nat) -> 
  assert True <- (
  fix (max: nat -> nat -> bool) -> 
    fun (y: nat) -> 
    fun (m: nat) -> 
    match y with
    | 0 -> 
      match m with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (x': nat) -> 
      match m with
      | 0 -> True
      | Suc (y': nat) -> max x' y'
      end
    end) y m in 
  match y with
  | 0 -> 
    match m with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Suc (y': nat) -> 
    match m with
    | 0 -> True
    | Suc (x': nat) -> (
      fix<452> (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) x' y'
    end
  end


[leq from]
($le m n =< True)


[leq to]
(
match n with
| 0 -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> False
  end
| Suc (y': nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> (
    fun (x: nat) -> 
    fun (y: nat) -> True) x' y'
  end
end =< True)


[fusing <<453>>] 
fun (y: nat) -> 
fun (n: nat) -> 
fun (m: nat) -> $eq ($max n y) y


[rep-arg orig]
$eq y y


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _2


[guess]
True


[guess check]
True


[yielding <<453>>] 
fix (max: nat -> nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> True
  | Suc (x': nat) -> 
    match y with
    | 0 -> False
    | Suc (y': nat) -> max y' x' _|_
    end
  end


[fusing <<454>>] 
fun (y: nat) -> 
fun (n: nat) -> 
assert True <- (
fix (max: nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> True
  | Suc (x': nat) -> 
    match y with
    | 0 -> False
    | Suc (y': nat) -> max y' x'
    end
  end) y n in $le n y


[failing <<454>>] 
fix (le: nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  assert True <- (
  fix (max: nat -> nat -> bool) -> 
    fun (y: nat) -> 
    fun (n: nat) -> 
    match n with
    | 0 -> True
    | Suc (x': nat) -> 
      match y with
      | 0 -> False
      | Suc (y': nat) -> max y' x'
      end
    end) y n in 
  match y with
  | 0 -> 
    match n with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Suc (y': nat) -> 
    match n with
    | 0 -> True
    | Suc (x': nat) -> (
      fix<454> (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) x' y'
    end
  end


[leq from]
($le n m =< True)


[leq to]
(
match m with
| 0 -> 
  match n with
  | 0 -> True
  | Suc (x': nat) -> False
  end
| Suc (y': nat) -> 
  match n with
  | 0 -> True
  | Suc (x': nat) -> (
    fun (x: nat) -> 
    fun (y: nat) -> True) x' y'
  end
end =< True)


[fusing <<455>>] 
fun (xs: list) -> 
assert True <- $elem n xs in (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: nat) (ys: list) -> Cons y (app ys)
  end) xs


[yielding <<455>>] 
fix (app: list -> list) -> 
  fun (xs: list) -> 
  assert Cons (y: nat) (ys: list) <- xs in 
  if $eq n y
  then Cons y ((
    fix<455> (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> ys[2]
      | Cons (y: nat) (ys: list) -> Cons y (app ys)
      end) ys)
  else 
    assert True <- $elem n ys in Cons y (app ys)


[fusing <<456>>] 
fun (n: nat) -> 
fun (xs: list) -> $elem n ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: nat) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<456>>] 
fix (app: nat -> list -> bool) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $elem n ys
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then True
    else app n ys
  end


[fusing <<457>>] 
fun (xs: list) -> 
assert True <- $elem n xs in (
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $elem n ys
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then True
    else app ys
  end) xs


[yielding <<457>>] 
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  assert Cons (y: nat) (ys: list) <- xs in 
  if $eq n y
  then True
  else 
    assert True <- $elem n ys in app ys


[orig]
(
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  assert Cons (y: nat) (ys: list) <- xs in 
  if (
    fix (eq: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (y: nat) -> 
      match x with
      | 0 -> 
        match y with
        | 0 -> True
        | Suc (y': nat) -> False
        end
      | Suc (x': nat) -> 
        match y with
        | 0 -> False
        | Suc (y': nat) -> eq x' y'
        end
      end) _6 y
  then True
  else app ys) _1


[guess]
True


[guess check]
True


[match fix from] (
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $elem n ys
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then True
    else app ys
  end) xs

[context] [True <- $elem n xs]

[to] True


[fusing <<458>>] 
fun (xs: list) -> 
assert True <- $elem n[2] xs in $elem n xs


[yielding <<458>>] 
fix (any: list -> bool) -> 
  fun (xs: list) -> 
  assert Cons (y: nat) (ys: list) <- xs in 
  if $eq n[2] y
  then 
    if $eq n y
    then True
    else (
      fix<458> (any: list -> bool) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> False
        | Cons (y: nat) (ys: list) -> 
          if $eq n y
          then True
          else any ys
        end) ys
  else 
    if $eq n y
    then 
      assert True <- $elem n[2] ys in True
    else 
      assert True <- $elem n[2] ys in any ys


[orig]
(
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if (
      fix (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) _6 y
    then True
    else app ys
  end) _1


[guess]
True


[guess check]
True


[fusing <<459>>] 
fun (xs: list) -> $elem n ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons n Nil
  | Cons (y: nat) (ys: list) -> Cons y (app ys)
  end) xs)


[rep-arg orig]
$eq n n


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _3


[guess]
True


[guess check]
True


[yielding <<459>>] 
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then True
    else app ys
  end


[orig]
(
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if (
      fix (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) _5 y
    then True
    else app ys
  end) _0


[guess]
True


[guess check]
True


[fusing <<460>>] 
fun (xs: list) -> $elem n ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons n Nil
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Cons y ys
    else Cons y (ins ys)
  end) xs)


[fusing <<461>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $eq x y[2] in $eq x y


[yielding <<461>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert Suc (y': nat) <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      match y[2] with
      | 0 -> False
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in False
      end
    | Suc (y': nat) -> 
      match y[2] with
      | 0 -> (
        fix<461> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in eq x' y' y'[2]
      end
    end
  end


[rep-arg orig]
$eq n n


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _3


[guess]
True


[guess check]
True


[yielding <<460>>] 
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then True
    else ins ys
  end


[orig]
(
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if (
      fix (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) _5 y
    then True
    else ins ys
  end) _0


[guess]
True


[guess check]
True


[fusing <<462>>] 
fun (xs: list) -> $elem n ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons n Nil
  | Cons (y: nat) (ys: list) -> 
    if $lt n y
    then Cons n (Cons y ys)
    else Cons y (ins ys)
  end) xs)


[fusing <<463>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $lt x y[2] in $lt x y


[yielding <<463>>] 
fix (lt: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[2] in 
    match y with
    | 0 -> False
    | Suc (y': nat) -> True
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      match y[2] with
      | 0 -> False
      | Suc (y': nat) -> 
        assert False <- $lt x' y' in False
      end
    | Suc (y': nat) -> 
      match y[2] with
      | 0 -> (
        fix<463> (lt: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> True
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> lt x' y'
            end
          end) x' y'
      | Suc (y': nat) -> 
        assert False <- $lt x' y' in lt x' y' y'[2]
      end
    end
  end


[rep-arg orig]
$eq n n


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _3


[guess]
True


[guess check]
True


[fusing <<464>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $lt x y[2] in $eq x y


[yielding <<464>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert Suc (y': nat) <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in 
      assert True <- $lt x' y' in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in 
      assert True <- $lt x' y' in eq x' y' y'[2]
    end
  end


[rep-arg orig]
$eq n n


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _5


[guess]
True


[guess check]
True


[fusing <<465>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $lt x y[2] in $eq x y


[yielding <<465>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      match y[2] with
      | 0 -> False
      | Suc (y': nat) -> 
        assert False <- $lt x' y' in False
      end
    | Suc (y': nat) -> 
      match y[2] with
      | 0 -> (
        fix<465> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (y': nat) -> 
        assert False <- $lt x' y' in eq x' y' y'[2]
      end
    end
  end


[fusing <<466>>] 
fun (x: nat) -> 
fun (y: nat) -> 
assert False <- $lt x y in $eq x y


[yielding <<466>>] 
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y in True
  | Suc (x': nat) -> 
    match y with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $lt x' y' in eq x' y'
    end
  end


[match fix from] $eq n y

[context] [False <- $lt n y]

[to] (
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match y with
    | 0 -> False
    | Suc (y': nat) -> eq x' y'
    end
  end) n y


[fusing <<467>>] 
fun (x: nat) -> 
fun (y: nat) -> 
assert False <- $lt x y in (
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match y with
    | 0 -> False
    | Suc (y': nat) -> eq x' y'
    end
  end) x y


[yielding <<467>>] 
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y in True
  | Suc (x': nat) -> 
    match y with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $lt x' y' in eq x' y'
    end
  end


[yielding <<462>>] 
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if $lt n y
    then True
    else 
      if (
        fix (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) n y
      then True
      else ins ys
  end


[fusing <<468>>] 
fun (x: nat) -> 
fun (y: nat) -> 
assert False <- $lt x y in (
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match y with
    | 0 -> False
    | Suc (y': nat) -> eq x' y'
    end
  end) x y


[yielding <<468>>] 
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y in True
  | Suc (x': nat) -> 
    match y with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $lt x' y' in eq x' y'
    end
  end


[orig]
(
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> True
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> lt x' y'
          end
        end) _5 y
    then True
    else 
      if (
        fix (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) _5 y
      then True
      else ins ys
  end) _0


[guess]
True


[guess check]
True


[fusing <<469>>] 
fun (x: nat) -> 
fun (m: nat) -> 
fun (k: nat) -> $min x ($min m k)


[yielding <<469>>] 
fix (min: nat -> nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  fun (k: nat) -> 
  match m with
  | 0 -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    end
  | Suc (x': nat) -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> Suc (min x' x'[2] y')
      end
    end
  end


[fusing <<470>>] 
fun (y: nat) -> 
fun (n: nat) -> 
fun (m: nat) -> $min ($min n m) y


[yielding <<470>>] 
fix (min: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    end
  | Suc (x': nat) -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> Suc (min y' x' y'[2])
      end
    end
  end


[leq from]
((
fix (min: nat -> nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  fun (k: nat) -> 
  match m with
  | 0 -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    end
  | Suc (x': nat) -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> Suc (min x' x'[2] y')
      end
    end
  end) n m k =< (
fix (min: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    end
  | Suc (x': nat) -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> Suc (min y' x' y'[2])
      end
    end
  end) k n m)


[leq to]
(
match m with
| 0 -> 
  match k with
  | 0 -> 
    match n with
    | 0 -> 0
    | Suc (x': nat) -> 0
    end
  | Suc (y': nat) -> 
    match n with
    | 0 -> 0
    | Suc (x': nat) -> 0
    end
  end
| Suc (x': nat) -> 
  match k with
  | 0 -> 
    match n with
    | 0 -> 0
    | Suc (x': nat) -> 0
    end
  | Suc (y': nat) -> 
    match n with
    | 0 -> 0
    | Suc (x': nat) -> Suc ((
      fun (x: nat) -> 
      fun (m: nat) -> 
      fun (k: nat) -> (
      fix (min: nat -> nat -> nat -> nat) -> 
        fun (y: nat) -> 
        fun (n: nat) -> 
        fun (m: nat) -> 
        match n with
        | 0 -> 
          match m with
          | 0 -> 
            match y with
            | 0 -> 0
            | Suc (y': nat) -> 0
            end
          | Suc (y': nat) -> 
            match y with
            | 0 -> 0
            | Suc (y': nat) -> 0
            end
          end
        | Suc (x': nat) -> 
          match m with
          | 0 -> 
            match y with
            | 0 -> 0
            | Suc (y': nat) -> 0
            end
          | Suc (y': nat) -> 
            match y with
            | 0 -> 0
            | Suc (y': nat) -> Suc (min y' x' y'[2])
            end
          end
        end) k x m) x' x'[2] y')
    end
  end
end =< (
fix (min: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    end
  | Suc (x': nat) -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> Suc (min y' x' y'[2])
      end
    end
  end) k n m)


[leq from]
((
fix (min: nat -> nat -> nat -> nat) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    end
  | Suc (x': nat) -> 
    match m with
    | 0 -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> 0
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> 0
      | Suc (y': nat) -> Suc (min y' x' y'[2])
      end
    end
  end) k n m =< (
fix (min: nat -> nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  fun (k: nat) -> 
  match m with
  | 0 -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    end
  | Suc (x': nat) -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> Suc (min x' x'[2] y')
      end
    end
  end) n m k)


[leq to]
(
match n with
| 0 -> 
  match m with
  | 0 -> 
    match k with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Suc (y': nat) -> 
    match k with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  end
| Suc (x': nat) -> 
  match m with
  | 0 -> 
    match k with
    | 0 -> 0
    | Suc (y': nat) -> 0
    end
  | Suc (y': nat) -> 
    match k with
    | 0 -> 0
    | Suc (y': nat) -> Suc ((
      fun (y: nat) -> 
      fun (n: nat) -> 
      fun (m: nat) -> (
      fix (min: nat -> nat -> nat -> nat) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        fun (k: nat) -> 
        match m with
        | 0 -> 
          match k with
          | 0 -> 
            match x with
            | 0 -> 0
            | Suc (x': nat) -> 0
            end
          | Suc (y': nat) -> 
            match x with
            | 0 -> 0
            | Suc (x': nat) -> 0
            end
          end
        | Suc (x': nat) -> 
          match k with
          | 0 -> 
            match x with
            | 0 -> 0
            | Suc (x': nat) -> 0
            end
          | Suc (y': nat) -> 
            match x with
            | 0 -> 0
            | Suc (x': nat) -> Suc (min x' x'[2] y')
            end
          end
        end) n m y) y' x' y'[2])
    end
  end
end =< (
fix (min: nat -> nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  fun (k: nat) -> 
  match m with
  | 0 -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    end
  | Suc (x': nat) -> 
    match k with
    | 0 -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> 0
      end
    | Suc (y': nat) -> 
      match x with
      | 0 -> 0
      | Suc (x': nat) -> Suc (min x' x'[2] y')
      end
    end
  end) n m k)


[fusing <<471>>] 
fun (y: nat) -> 
fun (n: nat) -> 
fun (m: nat) -> $eq ($min y m) y


[yielding <<471>>] 
fix (min: nat -> nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match y with
  | 0 -> 
    match m with
    | 0 -> True
    | Suc (y': nat) -> True
    end
  | Suc (x': nat) -> 
    match m with
    | 0 -> False
    | Suc (y': nat) -> min x' _|_ y'
    end
  end


[fusing <<472>>] 
fun (y: nat) -> 
fun (m: nat) -> 
assert True <- (
fix (min: nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (m: nat) -> 
  match y with
  | 0 -> 
    match m with
    | 0 -> True
    | Suc (y': nat) -> True
    end
  | Suc (x': nat) -> 
    match m with
    | 0 -> False
    | Suc (y': nat) -> min x' y'
    end
  end) y m in $le y m


[failing <<472>>] 
fix (le: nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (m: nat) -> 
  assert True <- (
  fix (min: nat -> nat -> bool) -> 
    fun (y: nat) -> 
    fun (m: nat) -> 
    match y with
    | 0 -> 
      match m with
      | 0 -> True
      | Suc (y': nat) -> True
      end
    | Suc (x': nat) -> 
      match m with
      | 0 -> False
      | Suc (y': nat) -> min x' y'
      end
    end) y m in 
  match m with
  | 0 -> 
    match y with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Suc (y': nat) -> 
    match y with
    | 0 -> True
    | Suc (x': nat) -> (
      fix<472> (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) x' y'
    end
  end


[leq from]
($le n m =< True)


[leq to]
(
match m with
| 0 -> 
  match n with
  | 0 -> True
  | Suc (x': nat) -> False
  end
| Suc (y': nat) -> 
  match n with
  | 0 -> True
  | Suc (x': nat) -> (
    fun (x: nat) -> 
    fun (y: nat) -> True) x' y'
  end
end =< True)


[fusing <<473>>] 
fun (y: nat) -> 
fun (n: nat) -> 
fun (m: nat) -> $eq ($min n y) y


[yielding <<473>>] 
fix (min: nat -> nat -> nat -> bool) -> 
  fun (y: nat) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  match n with
  | 0 -> 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> True
    | Suc (y': nat) -> min y' x' _|_
    end
  end


[fusing <<474>>] 
fun (xs: list) -> $elem n ((
fix (delete: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then delete xs'
    else Cons x (delete xs')
  end) xs)


[fusing <<475>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $eq x y[2] in $eq x y


[yielding <<475>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert Suc (y': nat) <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      match y[2] with
      | 0 -> False
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in False
      end
    | Suc (y': nat) -> 
      match y[2] with
      | 0 -> (
        fix<475> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in eq x' y' y'[2]
      end
    end
  end


[yielding <<474>>] 
fix (delete: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then delete xs'
    else delete xs'
  end


[orig]
(
fix (delete: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (x: nat) (xs': list) -> 
    if (
      fix (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) _5 x
    then delete xs'
    else delete xs'
  end) _0


[guess]
False


[guess check]
False


[fusing <<476>>] 
fun (xs: list) -> (
fix (count: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (count ys)
    else count ys
  end) ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons n Nil
  | Cons (y: nat) (ys: list) -> Cons y (app ys)
  end) xs)


[rep-arg orig]
$eq n n


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _3


[guess]
True


[guess check]
True


[yielding <<476>>] 
fix (app: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Suc 0
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (app ys)
    else app ys
  end


[leq from]
((
fix (app: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Suc 0
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (app ys)
    else app ys
  end) xs =< Suc ((
fix (count: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (count ys)
    else count ys
  end) xs))


[leq to]
(
match xs with
| Nil -> Suc 0
| Cons (y: nat) (ys: list) -> 
  if $eq n y
  then Suc ((
    fun (xs: list) -> Suc ((
    fix (count: list -> nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 0
      | Cons (y: nat) (ys: list) -> 
        if $eq n y
        then Suc (count ys)
        else count ys
      end) xs)) ys)
  else (
    fun (xs: list) -> Suc ((
    fix (count: list -> nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 0
      | Cons (y: nat) (ys: list) -> 
        if $eq n y
        then Suc (count ys)
        else count ys
      end) xs)) ys
end =< Suc ((
fix (count: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (count ys)
    else count ys
  end) xs))


[fusing <<477>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $eq x y[2] in $eq x y


[yielding <<477>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert Suc (y': nat) <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      match y[2] with
      | 0 -> False
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in False
      end
    | Suc (y': nat) -> 
      match y[2] with
      | 0 -> (
        fix<477> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in eq x' y' y'[2]
      end
    end
  end


[fusing <<478>>] 
fun (f: A -> B) -> 
fun (n: nat) -> 
fun (xs: list) -> $map<$0, $0> f ($take<$0> n xs)


[yielding <<478>>] 
fix (take: (A -> B) -> nat -> list -> list) -> 
  fun (f: A -> B) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (f y) (take f n' ys)
    end
  end


[fusing <<479>>] 
fun (n: nat) -> 
fun (xs: list) -> $take<$0> n ($map<$0, $0> f xs)


[yielding <<479>>] 
fix (map: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons (f y) (map n' ys)
    end
  end


[leq from]
((
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (f y) (take n' ys)
    end
  end) n xs =< (
fix (map: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons (f y) (map n' ys)
    end
  end) n xs)


[leq to]
(
match n with
| 0 -> Nil
| Suc (n': nat) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> Cons (f y) ((
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (map: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match n with
        | 0 -> Nil
        | Suc (n': nat) -> Nil
        end
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (n': nat) -> Cons (f y) (map n' ys)
        end
      end) n xs) n' ys)
  end
end =< (
fix (map: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons (f y) (map n' ys)
    end
  end) n xs)


[leq from]
((
fix (map: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons (f y) (map n' ys)
    end
  end) n xs =< (
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (f y) (take n' ys)
    end
  end) n xs)


[leq to]
(
match xs with
| Nil -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> Nil
  end
| Cons (y: A) (ys: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> Cons (f y) ((
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (take: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> 
        match xs with
        | Nil -> Nil
        | Cons (y: A) (ys: list) -> Cons (f y) (take n' ys)
        end
      end) n xs) n' ys)
  end
end =< (
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (f y) (take n' ys)
    end
  end) n xs)


[fusing <<480>>] 
fun (xs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (drop: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs': list) -> 
        if p x
        then drop xs'
        else Cons x xs'
      end) xs[3]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ((
fix (take: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: A) (xs': list) -> 
    if p x
    then Cons x (take xs')
    else Nil
  end) xs)


[yielding <<480>>] 
fix (take: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (drop: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs': list) -> 
        if p x
        then drop xs'
        else Cons x xs'
      end) xs[2]
  | Cons (x: A) (xs': list) -> 
    if p x
    then Cons x (take xs')
    else (
      fix (drop: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> Nil
        | Cons (x: A) (xs': list) -> 
          if p x
          then drop xs'
          else Cons x xs'
        end) xs[2]
  end


[dec-free from]
(
fix (take: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (drop: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs': list) -> 
        if p x
        then drop xs'
        else Cons x xs'
      end) xs[2]
  | Cons (x: A) (xs': list) -> 
    if p x
    then Cons x (take xs')
    else (
      fix (drop: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> Nil
        | Cons (x: A) (xs': list) -> 
          if p x
          then drop xs'
          else Cons x xs'
        end) xs[2]
  end) xs


[dec-free context]

fun (take: list -> list -> list) -> 
fun (xs: list) -> take xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (take: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (drop: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs': list) -> 
        if p x
        then drop xs'
        else Cons x xs'
      end) xs[2]
  | Cons (x: A) (xs': list) -> 
    if p x
    then Cons x (take xs[2] xs')
    else (
      fix (drop: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> Nil
        | Cons (x: A) (xs': list) -> 
          if p x
          then drop xs'
          else Cons x xs'
        end) xs[2]
  end) xs xs


[fusing <<481>>] 
fun (xs: list) -> (
fix (take: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (drop: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs': list) -> 
        if p x
        then drop xs'
        else Cons x xs'
      end) xs[2]
  | Cons (x: A) (xs': list) -> 
    if p x
    then Cons x (take xs[2] xs')
    else (
      fix (drop: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> Nil
        | Cons (x: A) (xs': list) -> 
          if p x
          then drop xs'
          else Cons x xs'
        end) xs[2]
  end) xs xs


[yielding <<481>>] 
fix (take: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: A) (xs': list) -> 
    if p x
    then Cons x (take xs')
    else Cons x xs'
  end


[fusing <<482>>] 
fun (x0: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons ($last<$0> (Cons x' xs'')) Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ($butlast<$0> x0)


[failing <<482>>] 
fix (butlast: list -> list) -> 
  fun (x0: list) -> 
  assert Cons (x: A) (xs': list) <- x0 in 
  match xs' with
  | Nil -> Cons ($last<$0> (Cons x' xs'')) Nil
  | Cons (x': A) (xs'': list) -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons ($last<$0> (Cons x'[2] xs''[2])) Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) (Cons x ((
    fix<482> (butlast: list -> list) -> 
      fun (xs: list) -> 
      assert Cons (x: A) (xs': list) <- xs in 
      match xs' with
      | Nil -> Nil
      | Cons (x': A) (xs'': list) -> Cons x (butlast (Cons x' xs''))
      end) (Cons x' xs'')))
  end


[leq from]
((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons ($last<$0> (Cons x' xs'')) Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys =< xs'')


[leq to]
(
match ys with
| Nil -> Cons ($last<$0> (Cons x' xs'')) Nil
| Cons (y: A) (ys: list) -> Cons y ((
  fun (xs: list) -> xs'') ys)
end =< xs'')


[leq from]
($take<$0> x' xs =< $butlast<$0> xs)


[leq to]
(
match x' with
| 0 -> Nil
| Suc (n': nat) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> Cons y ((
    fun (n: nat) -> 
    fun (xs: list) -> $butlast<$0> xs) n' ys)
  end
end =< $butlast<$0> xs)


[leq from]
($butlast<$0> xs =< 
match $length<$0> xs with
| 0 -> Nil
| Suc (x': nat) -> $take<$0> x' xs
end)


[leq to]
(
assert Cons (x: A) (xs': list) <- xs in 
match xs' with
| Nil -> Nil
| Cons (x': A) (xs'': list) -> Cons x ((
  fun (xs: list) -> 
  match $length<$0> xs with
  | 0 -> Nil
  | Suc (x': nat) -> $take<$0> x' xs
  end) (Cons x' xs''))
end =< 
match $length<$0> xs with
| 0 -> Nil
| Suc (x': nat) -> $take<$0> x' xs
end)


[fusing <<483>>] 
fun (xs: list) -> $butlast<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons x Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<483>>] 
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match (
    fix<483> (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons x Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys with
    | Nil -> Nil
    | Cons (x': A) (xs'': list) -> Cons y (app ys)
    end
  end


[leq from]
((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons x Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys with
    | Nil -> Nil
    | Cons (x': A) (xs'': list) -> Cons y (app ys)
    end
  end) xs =< xs)


[leq to]
(
match xs with
| Nil -> Nil
| Cons (y: A) (ys: list) -> 
  match (
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> Cons x Nil
    | Cons (y: A) (ys: list) -> Cons y (app ys)
    end) ys with
  | Nil -> Nil
  | Cons (x': A) (xs'': list) -> Cons y ((
    fun (xs: list) -> xs) ys)
  end
end =< xs)


[fusing <<484>>] 
fun (n: nat) -> 
fun (xs: list) -> $drop<$0> n ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<484>>] 
fix (app: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $drop<$0> n ys
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Cons y ((
      fix<484> (app: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> ys[2]
        | Cons (y: A) (ys: list) -> Cons y (app ys)
        end) ys)
    | Suc (n': nat) -> app n' ys
    end
  end


[fusing <<485>>] 
fun (x: nat) -> 
fun (xs: list) -> $minus x ($length<$0> xs)


[yielding <<485>>] 
fix (len: nat -> list -> nat) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> x
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> len x' ys
    end
  end


[fusing <<486>>] 
fun (xs: list) -> 
fun (n: nat) -> 
fun (xs: list) -> $drop<$0> ((
fix (len: nat -> list -> nat) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> x
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> len x' ys
    end
  end) n xs) xs[2]


[yielding <<486>>] 
fix (len: list -> nat -> list -> list) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $drop<$0> n xs[2]
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> xs[2]
    | Suc (x': nat) -> len xs[2] x' ys
    end
  end


[fusing <<487>>] 
fun (ys: list) -> 
fun (n: nat) -> 
fun (xs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (len: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $drop<$0> n ys
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> ys[2]
        | Suc (x': nat) -> len x' ys
        end
      end) n[2] xs[3]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ($drop<$0> n xs)


[yielding <<487>>] 
fix (drop: list -> nat -> list -> list) -> 
  fun (ys: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> (
        fix (len: nat -> list -> list) -> 
          fun (n: nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> $drop<$0> n ys
          | Cons (y: A) (ys: list) -> 
            match n with
            | 0 -> ys[2]
            | Suc (x': nat) -> len x' ys
            end
          end) n[2] xs[3]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $drop<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> ys[2]
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> drop ys[2] n' ys
    end
  end


[dec-free from]
(
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> (
        fix (len: nat -> list -> list) -> 
          fun (n: nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> $drop<$0> n ys
          | Cons (y: A) (ys: list) -> 
            match n with
            | 0 -> ys[2]
            | Suc (x': nat) -> len x' ys
            end
          end) n[2] xs[3]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $drop<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> ys[2]
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs


[dec-free context]

fun (drop: nat -> list -> nat -> list -> list) -> 
fun (n: nat) -> 
fun (xs: list) -> drop n xs n xs


[dec-free expressed fix]

fun (n: nat) -> 
fun (xs: list) -> (
fix (drop: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> (
        fix (len: nat -> list -> list) -> 
          fun (n: nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> $drop<$0> n ys
          | Cons (y: A) (ys: list) -> 
            match n with
            | 0 -> ys[2]
            | Suc (x': nat) -> len x' ys
            end
          end) n[2] xs[3]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $drop<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> ys[2]
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> drop n[2] xs[2] n' ys
    end
  end) n xs n xs


[fusing <<488>>] 
fun (n: nat) -> 
fun (xs: list) -> (
fix (drop: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> (
        fix (len: nat -> list -> list) -> 
          fun (n: nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> $drop<$0> n ys
          | Cons (y: A) (ys: list) -> 
            match n with
            | 0 -> ys[2]
            | Suc (x': nat) -> len x' ys
            end
          end) n[2] xs[3]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $drop<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> ys[2]
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> drop n[2] xs[2] n' ys
    end
  end) n xs n xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[fusing <<489>>] 
fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[failing <<489>>] 
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y ((
    fix<489> (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> ys[2]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys)
  end


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[yielding <<488>>] 
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match xs[2] with
        | Nil -> ys
        | Cons (y: A) (ys: list) -> ys[2]
        end
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> $drop<$0> n' ys
      end
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[fusing <<490>>] 
fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[failing <<490>>] 
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y ((
    fix<490> (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> ys[2]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys)
  end


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[leq from]
((
fix (app: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $drop<$0> n ys
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Cons y ((
      fix (app: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> ys[2]
        | Cons (y: A) (ys: list) -> Cons y (app ys)
        end) ys)
    | Suc (n': nat) -> app n' ys
    end
  end) n xs =< (
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match xs[2] with
        | Nil -> ys
        | Cons (y: A) (ys: list) -> ys[2]
        end
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> $drop<$0> n' ys
      end
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs)


[leq to]
(
match xs with
| Nil -> $drop<$0> n ys
| Cons (y: A) (ys: list) -> 
  match n with
  | 0 -> Cons y ((
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> ys[2]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys)
  | Suc (n': nat) -> (
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (drop: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match n with
      | 0 -> (
        fix (app: list -> list) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> 
            match xs[2] with
            | Nil -> ys[2]
            | Cons (y: A) (ys: list) -> ys[3]
            end
          | Cons (y: A) (ys: list) -> Cons y (app ys)
          end) xs
      | Suc (n': nat) -> 
        match xs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (y: A) (ys: list) -> $drop<$0> n' ys
          end
        | Cons (y: A) (ys: list) -> drop n' ys
        end
      end) n xs) n' ys
  end
end =< (
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match xs[2] with
        | Nil -> ys
        | Cons (y: A) (ys: list) -> ys[2]
        end
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> $drop<$0> n' ys
      end
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs)


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys[2]
    | Cons (y: A) (ys: list) -> ys[3]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> (
        fix (len: nat -> list -> list) -> 
          fun (n: nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> $drop<$0> n ys
          | Cons (y: A) (ys: list) -> 
            match n with
            | 0 -> ys[2]
            | Suc (x': nat) -> len x' ys
            end
          end) n[2] xs[3]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $drop<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> ys[2]
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs


[dec-free context]

fun (drop: nat -> list -> nat -> list -> list) -> 
fun (n: nat) -> 
fun (xs: list) -> drop n xs n xs


[dec-free expressed fix]

fun (n: nat) -> 
fun (xs: list) -> (
fix (drop: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> (
        fix (len: nat -> list -> list) -> 
          fun (n: nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> $drop<$0> n ys
          | Cons (y: A) (ys: list) -> 
            match n with
            | 0 -> ys[2]
            | Suc (x': nat) -> len x' ys
            end
          end) n[2] xs[3]
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $drop<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> ys[2]
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> drop n[2] xs[2] n' ys
    end
  end) n xs n xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[leq from]
((
fix (drop: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match xs[2] with
        | Nil -> ys
        | Cons (y: A) (ys: list) -> ys[2]
        end
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> $drop<$0> n' ys
      end
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) n xs =< (
fix (app: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $drop<$0> n ys
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Cons y ((
      fix (app: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> ys[2]
        | Cons (y: A) (ys: list) -> Cons y (app ys)
        end) ys)
    | Suc (n': nat) -> app n' ys
    end
  end) n xs)


[leq to]
(
match n with
| 0 -> (
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match xs[2] with
      | Nil -> ys
      | Cons (y: A) (ys: list) -> ys[2]
      end
    | Cons (y: A) (ys: list) -> Cons y (app ys)
    end) xs
| Suc (n': nat) -> 
  match xs with
  | Nil -> 
    match ys with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> $drop<$0> n' ys
    end
  | Cons (y: A) (ys: list) -> (
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (app: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $drop<$0> n ys[2]
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Cons y ((
          fix (app: list -> list) -> 
            fun (xs: list) -> 
            match xs with
            | Nil -> ys[3]
            | Cons (y: A) (ys: list) -> Cons y (app ys)
            end) ys)
        | Suc (n': nat) -> app n' ys
        end
      end) n xs) n' ys
  end
end =< (
fix (app: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $drop<$0> n ys
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Cons y ((
      fix (app: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> ys[2]
        | Cons (y: A) (ys: list) -> Cons y (app ys)
        end) ys)
    | Suc (n': nat) -> app n' ys
    end
  end) n xs)


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs[2] with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> ys[2]
    end
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[fusing <<491>>] 
fun (xs: list) -> 
fun (m: nat) -> $drop<$0> ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add x')
  end) m) xs


[yielding <<491>>] 
fix (add: list -> nat -> list) -> 
  fun (xs: list) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $drop<$0> n xs
  | Suc (x': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> add ys x'
    end
  end


[fusing <<492>>] 
fun (n: nat) -> 
fun (m: nat) -> 
fun (xs: list) -> $drop<$0> n ($drop<$0> m xs)


[yielding <<492>>] 
fix (drop: nat -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  fun (xs: list) -> 
  match m with
  | 0 -> $drop<$0> n xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: A) (ys: list) -> drop n n' ys
    end
  end


[leq from]
((
fix (add: list -> nat -> list) -> 
  fun (xs: list) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $drop<$0> n xs
  | Suc (x': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> add ys x'
    end
  end) xs m =< (
fix (drop: nat -> list -> list) -> 
  fun (m: nat) -> 
  fun (xs: list) -> 
  match m with
  | 0 -> $drop<$0> n xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) m xs)


[leq to]
(
match m with
| 0 -> $drop<$0> n xs
| Suc (x': nat) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> (
    fun (xs: list) -> 
    fun (m: nat) -> (
    fix (drop: nat -> list -> list) -> 
      fun (m: nat) -> 
      fun (xs: list) -> 
      match m with
      | 0 -> $drop<$0> n xs
      | Suc (n': nat) -> 
        match xs with
        | Nil -> 
          match n with
          | 0 -> Nil
          | Suc (n': nat) -> Nil
          end
        | Cons (y: A) (ys: list) -> drop n' ys
        end
      end) m xs) ys x'
  end
end =< (
fix (drop: nat -> list -> list) -> 
  fun (m: nat) -> 
  fun (xs: list) -> 
  match m with
  | 0 -> $drop<$0> n xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) m xs)


[leq from]
((
fix (drop: nat -> list -> list) -> 
  fun (m: nat) -> 
  fun (xs: list) -> 
  match m with
  | 0 -> $drop<$0> n xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: A) (ys: list) -> drop n' ys
    end
  end) m xs =< (
fix (add: list -> nat -> list) -> 
  fun (xs: list) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $drop<$0> n xs
  | Suc (x': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> add ys x'
    end
  end) xs m)


[leq to]
(
match m with
| 0 -> $drop<$0> n xs
| Suc (n': nat) -> 
  match xs with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: A) (ys: list) -> (
    fun (m: nat) -> 
    fun (xs: list) -> (
    fix (add: list -> nat -> list) -> 
      fun (xs: list) -> 
      fun (m: nat) -> 
      match m with
      | 0 -> $drop<$0> n xs
      | Suc (x': nat) -> 
        match xs with
        | Nil -> Nil
        | Cons (y: A) (ys: list) -> add ys x'
        end
      end) xs m) n' ys
  end
end =< (
fix (add: list -> nat -> list) -> 
  fun (xs: list) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $drop<$0> n xs
  | Suc (x': nat) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> add ys x'
    end
  end) xs m)


[fusing <<493>>] 
fun (xs: list) -> $last<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<493>>] 
fix (app: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match (
  fix<493> (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons y (app ys)
    end) ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> app ys
  end


[fusing <<494>>] 
fun (xs: list) -> $last<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons x xs'
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<494>>] 
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs' with
    | Nil -> x
    | Cons (z: A) (zs: list) -> $last<$0> (Cons z zs)
    end
  | Cons (y: A) (ys: list) -> 
    match (
    fix<494> (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons x xs'
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys with
    | Nil -> y
    | Cons (z: A) (zs: list) -> app ys
    end
  end


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> _3
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _3


[guess]
_1


[guess check]
_1


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> _3
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _3


[guess]
_1


[guess check]
_1


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (last: list -> A) -> 
      fun (xs: list) -> 
      assert Cons (y: A) (ys: list) <- xs in 
      match ys with
      | Nil -> y
      | Cons (z: A) (zs: list) -> last (Cons z zs)
      end) (Cons _3 _2)
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _5


[guess]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[guess check]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (last: list -> A) -> 
      fun (xs: list) -> 
      assert Cons (y: A) (ys: list) <- xs in 
      match ys with
      | Nil -> y
      | Cons (z: A) (zs: list) -> last (Cons z zs)
      end) (Cons _3 _2)
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _5


[guess]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[guess check]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> _3
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _3


[guess]
_1


[guess check]
_1


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (last: list -> A) -> 
      fun (xs: list) -> 
      assert Cons (y: A) (ys: list) <- xs in 
      match ys with
      | Nil -> y
      | Cons (z: A) (zs: list) -> last (Cons z zs)
      end) (Cons _3 _2)
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _5


[guess]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[guess check]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> _3
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _3


[guess]
_1


[guess check]
_1


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (last: list -> A) -> 
      fun (xs: list) -> 
      assert Cons (y: A) (ys: list) <- xs in 
      match ys with
      | Nil -> y
      | Cons (z: A) (zs: list) -> last (Cons z zs)
      end) (Cons _3 _2)
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _5


[guess]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[guess check]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> _3
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _3


[guess]
_1


[guess check]
_1


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (last: list -> A) -> 
      fun (xs: list) -> 
      assert Cons (y: A) (ys: list) <- xs in 
      match ys with
      | Nil -> y
      | Cons (z: A) (zs: list) -> last (Cons z zs)
      end) (Cons _3 _2)
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _5


[guess]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[guess check]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> _3
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _3


[guess]
_1


[guess check]
_1


[orig]
(
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (last: list -> A) -> 
      fun (xs: list) -> 
      assert Cons (y: A) (ys: list) <- xs in 
      match ys with
      | Nil -> y
      | Cons (z: A) (zs: list) -> last (Cons z zs)
      end) (Cons _3 _2)
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) _5


[guess]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[guess check]
(
fix (last: list -> A) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> last (Cons z zs)
  end) (Cons _1 _0)


[leq from]
((
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match xs' with
    | Nil -> x
    | Cons (z: A) (zs: list) -> $last<$0> (Cons z zs)
    end
  | Cons (y: A) (ys: list) -> 
    match ys with
    | Nil -> app Nil
    | Cons (y: A) (ys: list) -> app (Cons y ys)
    end
  end) xs =< 
match xs' with
| Nil -> x
| Cons (z: A) (zs: list) -> $last<$0> (Cons z zs)
end)


[leq to]
(
match xs with
| Nil -> 
  match xs' with
  | Nil -> x
  | Cons (z: A) (zs: list) -> $last<$0> (Cons z zs)
  end
| Cons (y: A) (ys: list) -> 
  match ys with
  | Nil -> (
    fun (xs: list) -> 
    match xs' with
    | Nil -> x
    | Cons (z: A) (zs: list) -> $last<$0> (Cons z zs)
    end) Nil
  | Cons (y: A) (ys: list) -> (
    fun (xs: list) -> 
    match xs' with
    | Nil -> x
    | Cons (z: A) (zs: list) -> $last<$0> (Cons z zs)
    end) (Cons y ys)
  end
end =< 
match xs' with
| Nil -> x
| Cons (z: A) (zs: list) -> $last<$0> (Cons z zs)
end)


[fusing <<495>>] 
fun (x: nat) -> 
fun (xs: list) -> $lt x ($length<$0> xs)


[yielding <<495>>] 
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> False
    | Suc (x': nat) -> False
    end
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end


[fusing <<496>>] 
fun (x: nat) -> 
fun (xs: list) -> 
assert True <- (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> False
    | Suc (x': nat) -> False
    end
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end) x xs in $drop<$0> x xs


[yielding <<496>>] 
fix (drop: nat -> list -> list) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match x with
  | 0 -> 
    assert Cons (y: A) (ys: list) <- xs in Cons y ys
  | Suc (n': nat) -> 
    assert Cons (y: A) (ys: list) <- xs in 
    assert True <- (
    fix (len: nat -> list -> bool) -> 
      fun (x: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match x with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      | Cons (y: A) (ys: list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> len x' ys
        end
      end) n' ys in drop n' ys
  end


[fusing <<497>>] 
fun (n: nat) -> 
fun (xs: list) -> $last<$0> ($drop<$0> n xs)


[yielding <<497>>] 
fix (drop: nat -> list -> A) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $last<$0> xs
  | Suc (n': nat) -> 
    assert Cons (y: A) (ys: list) <- xs in drop n' ys
  end


[fusing <<498>>] 
fun (x: nat) -> 
fun (xs: list) -> 
assert True <- (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> False
    | Suc (x': nat) -> False
    end
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end) x xs in (
fix (drop: nat -> list -> A) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $last<$0> xs
  | Suc (n': nat) -> 
    assert Cons (y: A) (ys: list) <- xs in drop n' ys
  end) x xs


[yielding <<498>>] 
fix (drop: nat -> list -> A) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match x with
  | 0 -> 
    assert Cons (y: A) (ys: list) <- xs in 
    match ys with
    | Nil -> y
    | Cons (z: A) (zs: list) -> $last<$0> (Cons z zs)
    end
  | Suc (n': nat) -> 
    assert Cons (y: A) (ys: list) <- xs in 
    assert True <- (
    fix (len: nat -> list -> bool) -> 
      fun (x: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> 
        match x with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      | Cons (y: A) (ys: list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> len x' ys
        end
      end) n' ys in drop n' ys
  end


[fusing <<499>>] 
fun (x: nat) -> 
fun (xs: list) -> 
assert True <- (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> False
    | Suc (x': nat) -> False
    end
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end) x xs in $last<$0> xs


[yielding <<499>>] 
fix (last: nat -> list -> A) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  assert Cons (y: A) (ys: list) <- xs in 
  match ys with
  | Nil -> 
    assert 0 <- x in y
  | Cons (z: A) (zs: list) -> 
    match x with
    | 0 -> (
      fix<499> (last: list -> A) -> 
        fun (xs: list) -> 
        assert Cons (y: A) (ys: list) <- xs in 
        match ys with
        | Nil -> y
        | Cons (z: A) (zs: list) -> last (Cons z zs)
        end) (Cons z zs)
    | Suc (x': nat) -> 
      match x' with
      | 0 -> last 0 (Cons z zs)
      | Suc (x': nat) -> 
        assert True <- (
        fix (len: nat -> list -> bool) -> 
          fun (x: nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> 
            match x with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          | Cons (y: A) (ys: list) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> len x' ys
            end
          end) x' zs in last (Suc x') (Cons z zs)
      end
    end
  end


[leq from]
((
fix (drop: nat -> list -> A) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> $last<$0> xs
  | Suc (n': nat) -> 
    assert Cons (y: A) (ys: list) <- xs in drop n' ys
  end) n xs =< $last<$0> xs)


[leq to]
(
match n with
| 0 -> $last<$0> xs
| Suc (n': nat) -> 
  assert Cons (y: A) (ys: list) <- xs in (
  fun (n: nat) -> 
  fun (xs: list) -> $last<$0> xs) n' ys
end =< $last<$0> xs)


[fusing <<500>>] 
fun (xs: list) -> $last<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons x Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<500>>] 
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> x
  | Cons (y: A) (ys: list) -> 
    match (
    fix<500> (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons x Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys with
    | Nil -> y
    | Cons (z: A) (zs: list) -> app ys
    end
  end


[leq from]
((
fix (app: list -> A) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> x
  | Cons (y: A) (ys: list) -> 
    match (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons x Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys with
    | Nil -> y
    | Cons (z: A) (zs: list) -> app ys
    end
  end) xs =< x)


[leq to]
(
match xs with
| Nil -> x
| Cons (y: A) (ys: list) -> 
  match (
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> Cons x Nil
    | Cons (y: A) (ys: list) -> Cons y (app ys)
    end) ys with
  | Nil -> y
  | Cons (z: A) (zs: list) -> (
    fun (xs: list) -> x) ys
  end
end =< x)


[fusing <<501>>] 
fun (x: nat) -> 
fun (m: nat) -> (
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x0: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x0 with
    | 0 -> 
      match x' with
      | 0 -> False
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add x')
  end) m)


[yielding <<501>>] 
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x0: nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x0 with
        | 0 -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end


[dec-free from]
(
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x0: nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x0 with
        | 0 -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) n m


[dec-free context]

fun (add: nat -> nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (m: nat) -> add x x m


[dec-free expressed fix]

fun (x: nat) -> 
fun (m: nat) -> (
fix (add: nat -> nat -> nat -> bool) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x0: nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x0 with
        | 0 -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add n x' x'[2]
    end
  end) x x m


[fusing <<502>>] 
fun (x: nat) -> 
fun (m: nat) -> (
fix (add: nat -> nat -> nat -> bool) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x0: nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x0 with
        | 0 -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add n x' x'[2]
    end
  end) x x m


[rep-arg orig]
(
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x0: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x0 with
    | 0 -> 
      match x' with
      | 0 -> False
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x x


[rep-arg ctx]

fun (lt: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (x0: nat) -> lt x x


[rep-arg full]

fun (x: nat) -> 
fun (x0: nat) -> (
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x0: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x0 with
    | 0 -> 
      match x' with
      | 0 -> False
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x x


[fusing <<503>>] 
fun (x: nat) -> 
fun (x0: nat) -> (
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x0: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x0 with
    | 0 -> 
      match x' with
      | 0 -> False
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x x


[yielding <<503>>] 
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x0: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> lt x' _|_
  end


[orig]
(
fix (lt: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> lt x'
  end) _1


[guess]
True


[guess check]
True


[fusing <<504>>] 
fun (x: nat) -> 
fun (x': nat) -> (
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x0: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x0 with
    | 0 -> 
      match x' with
      | 0 -> False
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x (Suc x')


[yielding <<504>>] 
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end


[discovery prop (before)]

fun (x': nat) -> ((
fix<502> (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix<502> (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x0: nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x0 with
          | 0 -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq from]
((
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x0: nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x0 with
          | 0 -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq to]
(
match x'[3] with
| 0 -> (
  fix (lt: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x'[2] with
      | 0 -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        end
      | Suc (b0: nat) -> lt x' b0
      end
    end) x'[2] x'
| Suc (x': nat) -> 
  match x'[3] with
  | 0 -> True
  | Suc (x': nat) -> (
    fun (x: nat) -> 
    fun (m: nat) -> 
    if (
      fix (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (lt: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x0: nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x0 with
              | 0 -> 
                match x' with
                | 0 -> False
                | Suc (x': nat) -> False
                end
              | Suc (b0: nat) -> lt x' b0
              end
            end) x x'[3]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x m
    then c0
    else c1) x' x'[2]
  end
end =< 
if (
  fix (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x0: nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x0 with
          | 0 -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq from]
((
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x'[2] x' =< 
if (
  fix (lt: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x0: nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x0 with
      | 0 -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      | Suc (b0: nat) -> lt x' b0
      end
    end) x'[2] x'
then c0
else c1)


[leq to]
(
match x'[2] with
| 0 -> True
| Suc (x': nat) -> 
  match x'[2] with
  | 0 -> 
    match x' with
    | 0 -> True
    | Suc (x': nat) -> 
      match x' with
      | 0 -> False
      | Suc (x': nat) -> False
      end
    end
  | Suc (b0: nat) -> (
    fun (x: nat) -> 
    fun (x': nat) -> 
    if (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x0: nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x0 with
          | 0 -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    then c0
    else c1) x' b0
  end
end =< 
if (
  fix (lt: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x0: nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x0 with
      | 0 -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      | Suc (b0: nat) -> lt x' b0
      end
    end) x'[2] x'
then c0
else c1)


[discovery prop]

fun (x': nat) -> 
match x'[3] with
| 0 -> 
  match x'[2] with
  | 0 -> (True =< c0)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< c1)
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (False =< c1)
      | Suc (x': nat) -> (False =< c1)
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[3] in (True =< c0)
end


[hopefully true (before)]

match x'[2] with
| 0 -> 
  match x' with
  | 0 -> (True =< True)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< (
      fix<502> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (lt: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> 
                  match x' with
                  | 0 -> False
                  | Suc (x': nat) -> False
                  end
                end
              | Suc (b0: nat) -> lt x' b0
              end
            end) x x'[2]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[2] x'[3])
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (False =< (
        fix<502> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> False
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'[3]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[3] x'[4])
      | Suc (x': nat) -> (False =< (
        fix<502> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> False
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'[4]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[4] x'[5])
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[2] in (True =< True)
end


[hopefully true]
tt


[discovery prop (before)]

fun (x': nat) -> ((
fix<502> (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix<502> (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x0: nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x0 with
          | 0 -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[discovery prop]

fun (x': nat) -> 
match x'[3] with
| 0 -> 
  match x'[2] with
  | 0 -> (True =< c0)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< c1)
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (False =< c1)
      | Suc (x': nat) -> (False =< c1)
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[3] in (True =< c0)
end


[hopefully true (before)]

match x'[2] with
| 0 -> 
  match x' with
  | 0 -> (True =< True)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< (
      fix<502> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (lt: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> 
                  match x' with
                  | 0 -> False
                  | Suc (x': nat) -> False
                  end
                end
              | Suc (b0: nat) -> lt x' b0
              end
            end) x x'[2]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[2] x'[3])
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (False =< (
        fix<502> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> False
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'[3]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[3] x'[4])
      | Suc (x': nat) -> (False =< (
        fix<502> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> False
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'[4]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[4] x'[5])
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[2] in (True =< True)
end


[hopefully true]
tt


[discovery prop (before)]

fun (x': nat) -> ((
fix<502> (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix<502> (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x0: nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x0 with
          | 0 -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[discovery prop]

fun (x': nat) -> 
match x'[3] with
| 0 -> 
  match x'[2] with
  | 0 -> (True =< c0)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< c1)
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (False =< c1)
      | Suc (x': nat) -> (False =< c1)
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[3] in (True =< c0)
end


[hopefully true (before)]

match x'[2] with
| 0 -> 
  match x' with
  | 0 -> (True =< True)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< (
      fix<502> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (lt: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> 
                  match x' with
                  | 0 -> False
                  | Suc (x': nat) -> False
                  end
                end
              | Suc (b0: nat) -> lt x' b0
              end
            end) x x'[2]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[2] x'[3])
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (False =< (
        fix<502> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> False
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'[3]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[3] x'[4])
      | Suc (x': nat) -> (False =< (
        fix<502> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> False
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'[4]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[4] x'[5])
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[2] in (True =< True)
end


[hopefully true]
tt


[yielding <<502>>] 
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      if add x' x'[2]
      then True
      else 
        if add x' x'[2]
        then True
        else (
          fix<502> (add: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (m: nat) -> 
            match m with
            | 0 -> (
              fix (lt: nat -> nat -> bool) -> 
                fun (x: nat) -> 
                fun (x': nat) -> 
                match x with
                | 0 -> True
                | Suc (x': nat) -> 
                  match x'[2] with
                  | 0 -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> 
                      match x' with
                      | 0 -> False
                      | Suc (x': nat) -> False
                      end
                    end
                  | Suc (b0: nat) -> lt x' b0
                  end
                end) x x'
            | Suc (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> add x' x'[2]
              end
            end) x' x'[2]
    end
  end


[dec-free from]
(
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x' x'[2]


[dec-free context]

fun (add: nat -> nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (m: nat) -> add x x m


[dec-free expressed fix]

fun (x: nat) -> 
fun (m: nat) -> (
fix (add: nat -> nat -> nat -> bool) -> 
  fun (x': nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x'[3] x' x'[2]
    end
  end) x x m


[fusing <<505>>] 
fun (x: nat) -> 
fun (m: nat) -> (
fix (add: nat -> nat -> nat -> bool) -> 
  fun (x': nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x'[3] x' x'[2]
    end
  end) x x m


[rep-arg orig]
(
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x x


[rep-arg ctx]

fun (lt: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (x': nat) -> lt x x


[rep-arg full]

fun (x: nat) -> 
fun (x': nat) -> (
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x x


[fusing <<506>>] 
fun (x: nat) -> 
fun (x': nat) -> (
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x x


[yielding <<506>>] 
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> lt x' _|_
  end


[orig]
(
fix (lt: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> lt x'
  end) _1


[guess]
True


[guess check]
True


[fusing <<507>>] 
fun (x: nat) -> 
fun (x': nat) -> (
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x (Suc x')


[yielding <<507>>] 
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        end
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end


[discovery prop (before)]

fun (x': nat) -> ((
fix<505> (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> False
              | Suc (x': nat) -> False
              end
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix<505> (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x': nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x'[2] with
          | 0 -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> False
              | Suc (x': nat) -> False
              end
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq from]
((
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (lt: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> False
              | Suc (x': nat) -> False
              end
            end
          end
        | Suc (b0: nat) -> lt x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x': nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x'[2] with
          | 0 -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> False
              | Suc (x': nat) -> False
              end
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq to]
(
match x'[3] with
| 0 -> (
  fix (lt: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x'[2] with
      | 0 -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> False
            | Suc (x': nat) -> False
            end
          end
        end
      | Suc (b0: nat) -> lt x' b0
      end
    end) x'[2] x'
| Suc (x': nat) -> 
  match x'[3] with
  | 0 -> True
  | Suc (x': nat) -> (
    fun (x: nat) -> 
    fun (m: nat) -> 
    if (
      fix (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (lt: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> 
                  match x' with
                  | 0 -> False
                  | Suc (x': nat) -> False
                  end
                end
              | Suc (b0: nat) -> lt x' b0
              end
            end) x x'[3]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x m
    then c0
    else c1) x' x'[2]
  end
end =< 
if (
  fix (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x': nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x'[2] with
          | 0 -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> False
              | Suc (x': nat) -> False
              end
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq from]
((
fix (lt: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        end
      end
    | Suc (b0: nat) -> lt x' b0
    end
  end) x'[2] x' =< 
if (
  fix (lt: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x'[2] with
      | 0 -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        end
      | Suc (b0: nat) -> lt x' b0
      end
    end) x'[2] x'
then c0
else c1)


[leq to]
(
match x'[2] with
| 0 -> True
| Suc (x': nat) -> 
  match x'[2] with
  | 0 -> 
    match x' with
    | 0 -> True
    | Suc (x': nat) -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> False
        | Suc (x': nat) -> False
        end
      end
    end
  | Suc (b0: nat) -> (
    fun (x: nat) -> 
    fun (x': nat) -> 
    if (
      fix (lt: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x': nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x'[2] with
          | 0 -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> False
              | Suc (x': nat) -> False
              end
            end
          | Suc (b0: nat) -> lt x' b0
          end
        end) x x'
    then c0
    else c1) x' b0
  end
end =< 
if (
  fix (lt: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x'[2] with
      | 0 -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> 
          match x' with
          | 0 -> False
          | Suc (x': nat) -> False
          end
        end
      | Suc (b0: nat) -> lt x' b0
      end
    end) x'[2] x'
then c0
else c1)


[discovery prop]

fun (x': nat) -> 
match x'[3] with
| 0 -> 
  match x'[2] with
  | 0 -> (True =< c0)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< c0)
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (True =< c1)
      | Suc (x': nat) -> 
        match x' with
        | 0 -> (False =< c1)
        | Suc (x': nat) -> (False =< c1)
        end
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[3] in (True =< c0)
end


[hopefully true (before)]

match x'[2] with
| 0 -> 
  match x' with
  | 0 -> (True =< True)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< True)
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (True =< (
        fix<505> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> 
                      match x' with
                      | 0 -> False
                      | Suc (x': nat) -> False
                      end
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'[3]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[3] x'[4])
      | Suc (x': nat) -> 
        match x' with
        | 0 -> (False =< (
          fix<505> (add: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (m: nat) -> 
            match m with
            | 0 -> (
              fix (lt: nat -> nat -> bool) -> 
                fun (x: nat) -> 
                fun (x': nat) -> 
                match x with
                | 0 -> True
                | Suc (x': nat) -> 
                  match x'[2] with
                  | 0 -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> 
                      match x' with
                      | 0 -> True
                      | Suc (x': nat) -> 
                        match x' with
                        | 0 -> False
                        | Suc (x': nat) -> False
                        end
                      end
                    end
                  | Suc (b0: nat) -> lt x' b0
                  end
                end) x x'[4]
            | Suc (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> add x' x'[2]
              end
            end) x'[4] x'[5])
        | Suc (x': nat) -> (False =< (
          fix<505> (add: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (m: nat) -> 
            match m with
            | 0 -> (
              fix (lt: nat -> nat -> bool) -> 
                fun (x: nat) -> 
                fun (x': nat) -> 
                match x with
                | 0 -> True
                | Suc (x': nat) -> 
                  match x'[2] with
                  | 0 -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> 
                      match x' with
                      | 0 -> True
                      | Suc (x': nat) -> 
                        match x' with
                        | 0 -> False
                        | Suc (x': nat) -> False
                        end
                      end
                    end
                  | Suc (b0: nat) -> lt x' b0
                  end
                end) x x'[5]
            | Suc (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> add x' x'[2]
              end
            end) x'[5] x'[6])
        end
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[2] in (True =< True)
end


[hopefully true]
tt


[yielding <<505>>] 
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      if add x' x'[2]
      then True
      else (
        fix<505> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> 
                      match x' with
                      | 0 -> False
                      | Suc (x': nat) -> False
                      end
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x' x'[2]
    end
  end


[orig]
(
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      if add x' x'[2]
      then True
      else (
        fix (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (lt: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> 
                      match x' with
                      | 0 -> False
                      | Suc (x': nat) -> False
                      end
                    end
                  end
                | Suc (b0: nat) -> lt x' b0
                end
              end) x x'
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x' x'[2]
    end
  end) _0 _1


[guess]
True


[guess check]
True


[orig]
(
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      if add x' x'[2]
      then True
      else True
    end
  end) _1 _0


[guess]
True


[guess check]
True


[fusing <<508>>] 
fun (xs: list) -> $length<$0> ($filter<$0> p xs)


[yielding <<508>>] 
fix (filter: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: A) (ys: list) -> 
    if p y
    then Suc (filter ys)
    else filter ys
  end


[fusing <<509>>] 
fun (x: nat) -> 
fun (xs: list) -> $le x ($length<$0> xs)


[yielding <<509>>] 
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end


[fusing <<510>>] 
fun (xs: list) -> 
fun (xs: list) -> (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end) ((
fix (filter: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: A) (ys: list) -> 
    if p y
    then Suc (filter ys)
    else filter ys
  end) xs[2]) xs[2]


[fusing <<511>>] 
fun (x: nat) -> 
fun (y: A) -> 
fun (ys: list) -> (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end) x (Cons y ys)


[yielding <<511>>] 
fix (len: nat -> A -> list -> bool) -> 
  fun (x: nat) -> 
  fun (y: A) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: A) (b1: list) -> len x' b0 b1
    end
  end


[discovery prop (before)]

fun (g: nat) -> ((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: A) (b1: list) -> len x' b1
    end
  end) g ys =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: A) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g ys
then c0
else c1)


[leq from]
((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: A) (b1: list) -> len x' b1
    end
  end) g ys =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: A) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g ys
then c0
else c1)


[leq to]
(
match g with
| 0 -> True
| Suc (x': nat) -> 
  match ys with
  | Nil -> 
    match x' with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Cons (b0: A) (b1: list) -> (
    fun (x: nat) -> 
    fun (ys: list) -> 
    if (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Cons (y: A) (ys: list) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> len x' ys
          end
        end) x ys
    then c0
    else c1) x' b1
  end
end =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: A) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g ys
then c0
else c1)


[discovery prop]

fun (g: nat) -> 
match g with
| 0 -> (True =< 
  match ys with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c0
  end)
| Suc (x': nat) -> 
  assert Nil <- ys in 
  match x' with
  | 0 -> (True =< c1)
  | Suc (x': nat) -> (False =< c1)
  end
end


[discovery prop (before)]

fun (g: nat) -> ((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: A) (b1: list) -> len x' b1
    end
  end) g ys =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: A) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g ys
then c0
else c1)


[discovery prop]

fun (g: nat) -> 
match g with
| 0 -> (True =< 
  match ys with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c0
  end)
| Suc (x': nat) -> 
  assert Nil <- ys in 
  match x' with
  | 0 -> (True =< c1)
  | Suc (x': nat) -> (False =< c1)
  end
end


[discovery prop (before)]

fun (g: nat) -> ((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: A) (b1: list) -> len x' b1
    end
  end) g ys =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: A) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g ys
then c0
else c1)


[discovery prop]

fun (g: nat) -> 
match g with
| 0 -> (True =< 
  match ys with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c0
  end)
| Suc (x': nat) -> 
  assert Nil <- ys in 
  match x' with
  | 0 -> (True =< c1)
  | Suc (x': nat) -> (False =< c1)
  end
end


[yielding <<510>>] 
fix (filter: list -> list -> bool) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs[2] with
  | Nil -> True
  | Cons (y: A) (ys: list) -> 
    if p y
    then filter ys _|_
    else (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (ys: list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match ys with
          | Nil -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Cons (b0: A) (b1: list) -> len x' b1
          end
        end) ((
      fix<510> (filter: list -> nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 0
        | Cons (y: A) (ys: list) -> 
          if p y
          then Suc (filter ys)
          else filter ys
        end) ys) ys
  end


[fusing <<512>>] 
fun (ys: list) -> 
fun (ys: list) -> (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: A) (b1: list) -> len x' b1
    end
  end) ((
fix (filter: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: A) (ys: list) -> 
    if p y
    then Suc (filter ys)
    else filter ys
  end) ys[2]) ys[2]


[fusing <<513>>] 
fun (x: nat) -> 
fun (y: A) -> 
fun (ys: list) -> (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: A) (b1: list) -> len x' b1
    end
  end) x (Cons y ys)


[yielding <<513>>] 
fix (len: nat -> A -> list -> bool) -> 
  fun (x: nat) -> 
  fun (y: A) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      end
    | Cons (b0: A) (b1: list) -> len x' b0 b1
    end
  end


[discovery prop (before)]

fun (g: nat) -> ((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      end
    | Cons (b0: A) (b1: list) -> len x' b1
    end
  end) g ys =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match ys with
      | Nil -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Cons (b0: A) (b1: list) -> len x' b1
      end
    end) g ys
then c0
else c1)


[leq from]
((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (ys: list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match ys with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      end
    | Cons (b0: A) (b1: list) -> len x' b1
    end
  end) g ys =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match ys with
      | Nil -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Cons (b0: A) (b1: list) -> len x' b1
      end
    end) g ys
then c0
else c1)


[leq to]
(
match g with
| 0 -> True
| Suc (x': nat) -> 
  match ys with
  | Nil -> 
    match x' with
    | 0 -> True
    | Suc (x': nat) -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    end
  | Cons (b0: A) (b1: list) -> (
    fun (x: nat) -> 
    fun (ys: list) -> 
    if (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (ys: list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match ys with
          | Nil -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Cons (b0: A) (b1: list) -> len x' b1
          end
        end) x ys
    then c0
    else c1) x' b1
  end
end =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match ys with
      | Nil -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Cons (b0: A) (b1: list) -> len x' b1
      end
    end) g ys
then c0
else c1)


[discovery prop]

fun (g: nat) -> 
match g with
| 0 -> (True =< c0)
| Suc (x': nat) -> 
  assert Nil <- ys in 
  match x' with
  | 0 -> (True =< c0)
  | Suc (x': nat) -> 
    match x' with
    | 0 -> (True =< c1)
    | Suc (x': nat) -> (False =< c1)
    end
  end
end


[hopefully true (before)]

match (
fix<512> (filter: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: A) (ys: list) -> 
    if p y
    then Suc (filter ys)
    else filter ys
  end) ys with
| 0 -> (True =< True)
| Suc (x': nat) -> 
  assert Nil <- ys in 
  match x' with
  | 0 -> (True =< True)
  | Suc (x': nat) -> 
    match x' with
    | 0 -> (True =< (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (ys: list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match ys with
          | Nil -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> True
              | Suc (x': nat) -> False
              end
            end
          | Cons (b0: A) (b1: list) -> len x' b1
          end
        end) ((
      fix<512> (filter: list -> nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 0
        | Cons (y: A) (ys: list) -> 
          if p y
          then Suc (filter ys)
          else filter ys
        end) ys) ys)
    | Suc (x': nat) -> (False =< (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (ys: list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match ys with
          | Nil -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> True
              | Suc (x': nat) -> False
              end
            end
          | Cons (b0: A) (b1: list) -> len x' b1
          end
        end) ((
      fix<512> (filter: list -> nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 0
        | Cons (y: A) (ys: list) -> 
          if p y
          then Suc (filter ys)
          else filter ys
        end) ys) ys)
    end
  end
end


[hopefully true]
tt


[yielding <<512>>] 
fix (filter: list -> list -> bool) -> 
  fun (ys: list) -> 
  fun (ys: list) -> 
  match ys[2] with
  | Nil -> True
  | Cons (y: A) (ys: list) -> 
    if p y
    then filter ys _|_
    else 
      if filter ys _|_
      then True
      else (
        fix (len: nat -> list -> bool) -> 
          fun (x: nat) -> 
          fun (ys: list) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> 
            match ys with
            | Nil -> 
              match x' with
              | 0 -> True
              | Suc (x': nat) -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              end
            | Cons (b0: A) (b1: list) -> len x' b1
            end
          end) ((
        fix<512> (filter: list -> nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> 0
          | Cons (y: A) (ys: list) -> 
            if p y
            then Suc (filter ys)
            else filter ys
          end) ys) ys
  end


[orig]
(
fix (filter: list -> bool) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> True
  | Cons (y: A) (ys: list) -> 
    if _10 y
    then filter ys
    else 
      if filter ys
      then True
      else (
        fix (len: nat -> list -> bool) -> 
          fun (x: nat) -> 
          fun (ys: list) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> 
            match ys with
            | Nil -> 
              match x' with
              | 0 -> True
              | Suc (x': nat) -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              end
            | Cons (b0: A) (b1: list) -> len x' b1
            end
          end) ((
        fix (filter: list -> nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> 0
          | Cons (y: A) (ys: list) -> 
            if _14 y
            then Suc (filter ys)
            else filter ys
          end) ys) ys
  end) _0


[guess]
True


[guess check]
True


[orig]
(
fix (filter: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: A) (ys: list) -> 
    if _5 y
    then filter ys
    else True
  end) _0


[guess]
True


[guess check]
True


[fusing <<514>>] 
fun (xs: list) -> $length<$0> ($butlast<$0> xs)


[yielding <<514>>] 
fix (butlast: list -> nat) -> 
  fun (xs: list) -> 
  assert Cons (x: A) (xs': list) <- xs in 
  match xs' with
  | Nil -> 0
  | Cons (x': A) (xs'': list) -> Suc (butlast (Cons x' xs''))
  end


[leq from]
((
fix (butlast: list -> nat) -> 
  fun (xs: list) -> 
  assert Cons (x: A) (xs': list) <- xs in 
  match xs' with
  | Nil -> 0
  | Cons (x': A) (xs'': list) -> Suc (butlast (Cons x' xs''))
  end) xs =< 
match $length<$0> xs with
| 0 -> 0
| Suc (x': nat) -> x'
end)


[leq to]
(
assert Cons (x: A) (xs': list) <- xs in 
match xs' with
| Nil -> 0
| Cons (x': A) (xs'': list) -> Suc ((
  fun (xs: list) -> 
  match $length<$0> xs with
  | 0 -> 0
  | Suc (x': nat) -> x'
  end) (Cons x' xs''))
end =< 
match $length<$0> xs with
| 0 -> 0
| Suc (x': nat) -> x'
end)


[fusing <<515>>] 
fun (xs: list) -> $length<nat> ((
fix (delete: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then delete xs'
    else Cons x (delete xs')
  end) xs)


[yielding <<515>>] 
fix (delete: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then delete xs'
    else Suc (delete xs')
  end


[fusing <<516>>] 
fun (x: nat) -> 
fun (xs: list) -> $le x ($length<nat> xs)


[yielding <<516>>] 
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Cons (y: nat) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end


[fusing <<517>>] 
fun (xs: list) -> 
fun (xs: list) -> (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Cons (y: nat) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end) ((
fix (delete: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then delete xs'
    else Suc (delete xs')
  end) xs[2]) xs[2]


[fusing <<518>>] 
fun (x: nat) -> 
fun (x: nat) -> 
fun (xs': list) -> (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Cons (y: nat) (ys: list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> len x' ys
    end
  end) x[2] (Cons x xs')


[yielding <<518>>] 
fix (len: nat -> nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x[2] with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: nat) (b1: list) -> len x' b0 b1
    end
  end


[discovery prop (before)]

fun (g: nat) -> ((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: nat) (b1: list) -> len x' b1
    end
  end) g xs' =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: nat) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g xs'
then c0
else c1)


[leq from]
((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: nat) (b1: list) -> len x' b1
    end
  end) g xs' =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: nat) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g xs'
then c0
else c1)


[leq to]
(
match g with
| 0 -> True
| Suc (x': nat) -> 
  match xs' with
  | Nil -> 
    match x' with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Cons (b0: nat) (b1: list) -> (
    fun (x: nat) -> 
    fun (xs': list) -> 
    if (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Cons (y: nat) (ys: list) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> len x' ys
          end
        end) x xs'
    then c0
    else c1) x' b1
  end
end =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: nat) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g xs'
then c0
else c1)


[discovery prop]

fun (g: nat) -> 
match g with
| 0 -> (True =< 
  match xs' with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c0
  end)
| Suc (x': nat) -> 
  assert Nil <- xs' in 
  match x' with
  | 0 -> (True =< c1)
  | Suc (x': nat) -> (False =< c1)
  end
end


[discovery prop (before)]

fun (g: nat) -> ((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: nat) (b1: list) -> len x' b1
    end
  end) g xs' =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: nat) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g xs'
then c0
else c1)


[discovery prop]

fun (g: nat) -> 
match g with
| 0 -> (True =< 
  match xs' with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c0
  end)
| Suc (x': nat) -> 
  assert Nil <- xs' in 
  match x' with
  | 0 -> (True =< c1)
  | Suc (x': nat) -> (False =< c1)
  end
end


[discovery prop (before)]

fun (g: nat) -> ((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: nat) (b1: list) -> len x' b1
    end
  end) g xs' =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (y: nat) (ys: list) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> len x' ys
      end
    end) g xs'
then c0
else c1)


[discovery prop]

fun (g: nat) -> 
match g with
| 0 -> (True =< 
  match xs' with
  | Nil -> c0
  | Cons (y: nat) (ys: list) -> c0
  end)
| Suc (x': nat) -> 
  assert Nil <- xs' in 
  match x' with
  | 0 -> (True =< c1)
  | Suc (x': nat) -> (False =< c1)
  end
end


[yielding <<517>>] 
fix (delete: list -> list -> bool) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs[2] with
  | Nil -> True
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (xs': list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match xs' with
          | Nil -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Cons (b0: nat) (b1: list) -> len x' b1
          end
        end) ((
      fix<517> (delete: list -> nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 0
        | Cons (x: nat) (xs': list) -> 
          if $eq n x
          then delete xs'
          else Suc (delete xs')
        end) xs') xs'
    else delete xs' _|_
  end


[fusing <<519>>] 
fun (xs': list) -> 
fun (xs': list) -> (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: nat) (b1: list) -> len x' b1
    end
  end) ((
fix (delete: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then delete xs'
    else Suc (delete xs')
  end) xs'[2]) xs'[2]


[fusing <<520>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $eq x y[3] in (
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in eq x' y' y'[2]
    end
  end) x y[2] y


[yielding <<520>>] 
fix (eq: nat -> nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[3] in 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in 
      assert Suc (y': nat) <- y[3] in 
      assert True <- $eq x' y' in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in 
      assert Suc (y': nat) <- y[3] in 
      assert True <- $eq x' y' in eq x' y' y'[2] y'[3]
    end
  end


[fusing <<521>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $eq x y[3] in (
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in eq x' y' y'[2]
    end
  end) x y[2] y


[yielding <<521>>] 
fix (eq: nat -> nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert Suc (y': nat) <- y[3] in 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in 
      match y[3] with
      | 0 -> False
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in False
      end
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in 
      match y[3] with
      | 0 -> (
        fix<521> (eq: nat -> nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            assert 0 <- y[2] in 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> 
              assert Suc (y': nat) <- y[2] in False
            | Suc (y': nat) -> 
              assert Suc (y': nat) <- y[2] in eq x' y' y'[2]
            end
          end) x' y' y'[2]
      | Suc (y': nat) -> 
        assert False <- $eq x' y' in eq x' y' y'[2] y'[3]
      end
    end
  end


[fusing <<522>>] 
fun (x: nat) -> 
fun (x: nat) -> 
fun (xs': list) -> (
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Cons (b0: nat) (b1: list) -> len x' b1
    end
  end) x[2] (Cons x xs')


[yielding <<522>>] 
fix (len: nat -> nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x[2] with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      end
    | Cons (b0: nat) (b1: list) -> len x' b0 b1
    end
  end


[discovery prop (before)]

fun (g: nat) -> ((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      end
    | Cons (b0: nat) (b1: list) -> len x' b1
    end
  end) g xs' =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs': list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match xs' with
      | Nil -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Cons (b0: nat) (b1: list) -> len x' b1
      end
    end) g xs'
then c0
else c1)


[leq from]
((
fix (len: nat -> list -> bool) -> 
  fun (x: nat) -> 
  fun (xs': list) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match xs' with
    | Nil -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      end
    | Cons (b0: nat) (b1: list) -> len x' b1
    end
  end) g xs' =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs': list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match xs' with
      | Nil -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Cons (b0: nat) (b1: list) -> len x' b1
      end
    end) g xs'
then c0
else c1)


[leq to]
(
match g with
| 0 -> True
| Suc (x': nat) -> 
  match xs' with
  | Nil -> 
    match x' with
    | 0 -> True
    | Suc (x': nat) -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    end
  | Cons (b0: nat) (b1: list) -> (
    fun (x: nat) -> 
    fun (xs': list) -> 
    if (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (xs': list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match xs' with
          | Nil -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Cons (b0: nat) (b1: list) -> len x' b1
          end
        end) x xs'
    then c0
    else c1) x' b1
  end
end =< 
if (
  fix (len: nat -> list -> bool) -> 
    fun (x: nat) -> 
    fun (xs': list) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match xs' with
      | Nil -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Cons (b0: nat) (b1: list) -> len x' b1
      end
    end) g xs'
then c0
else c1)


[discovery prop]

fun (g: nat) -> 
match g with
| 0 -> (True =< c0)
| Suc (x': nat) -> 
  assert Nil <- xs' in 
  match x' with
  | 0 -> (True =< c0)
  | Suc (x': nat) -> 
    match x' with
    | 0 -> (True =< c1)
    | Suc (x': nat) -> (False =< c1)
    end
  end
end


[hopefully true (before)]

match (
fix<519> (delete: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then delete xs'
    else Suc (delete xs')
  end) xs' with
| 0 -> (True =< True)
| Suc (x': nat) -> 
  assert Nil <- xs' in 
  match x' with
  | 0 -> (True =< True)
  | Suc (x': nat) -> 
    match x' with
    | 0 -> (True =< (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (xs': list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match xs' with
          | Nil -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> True
              | Suc (x': nat) -> False
              end
            end
          | Cons (b0: nat) (b1: list) -> len x' b1
          end
        end) ((
      fix<519> (delete: list -> nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 0
        | Cons (x: nat) (xs': list) -> 
          if $eq n x
          then delete xs'
          else Suc (delete xs')
        end) xs') xs')
    | Suc (x': nat) -> (False =< (
      fix (len: nat -> list -> bool) -> 
        fun (x: nat) -> 
        fun (xs': list) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match xs' with
          | Nil -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> 
              match x' with
              | 0 -> True
              | Suc (x': nat) -> False
              end
            end
          | Cons (b0: nat) (b1: list) -> len x' b1
          end
        end) ((
      fix<519> (delete: list -> nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> 0
        | Cons (x: nat) (xs': list) -> 
          if $eq n x
          then delete xs'
          else Suc (delete xs')
        end) xs') xs')
    end
  end
end


[hopefully true]
tt


[yielding <<519>>] 
fix (delete: list -> list -> bool) -> 
  fun (xs': list) -> 
  fun (xs': list) -> 
  match xs'[2] with
  | Nil -> True
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then 
      if delete xs' _|_
      then True
      else (
        fix (len: nat -> list -> bool) -> 
          fun (x: nat) -> 
          fun (xs': list) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> 
            match xs' with
            | Nil -> 
              match x' with
              | 0 -> True
              | Suc (x': nat) -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              end
            | Cons (b0: nat) (b1: list) -> len x' b1
            end
          end) ((
        fix<519> (delete: list -> nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> 0
          | Cons (x: nat) (xs': list) -> 
            if $eq n x
            then delete xs'
            else Suc (delete xs')
          end) xs') xs'
    else delete xs' _|_
  end


[fusing <<523>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $eq x y[3] in (
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in eq x' y' y'[2]
    end
  end) x y[2] y


[yielding <<523>>] 
fix (eq: nat -> nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[3] in 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in 
      assert Suc (y': nat) <- y[3] in 
      assert True <- $eq x' y' in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in 
      assert Suc (y': nat) <- y[3] in 
      assert True <- $eq x' y' in eq x' y' y'[2] y'[3]
    end
  end


[orig]
(
fix (delete: list -> bool) -> 
  fun (xs': list) -> 
  match xs' with
  | Nil -> True
  | Cons (x: nat) (xs': list) -> 
    if (
      fix (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) _10 x
    then 
      if delete xs'
      then True
      else (
        fix (len: nat -> list -> bool) -> 
          fun (x: nat) -> 
          fun (xs': list) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> 
            match xs' with
            | Nil -> 
              match x' with
              | 0 -> True
              | Suc (x': nat) -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              end
            | Cons (b0: nat) (b1: list) -> len x' b1
            end
          end) ((
        fix (delete: list -> nat) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> 0
          | Cons (x: nat) (xs': list) -> 
            if (
              fix (eq: nat -> nat -> bool) -> 
                fun (x: nat) -> 
                fun (y: nat) -> 
                match x with
                | 0 -> 
                  match y with
                  | 0 -> True
                  | Suc (y': nat) -> False
                  end
                | Suc (x': nat) -> 
                  match y with
                  | 0 -> False
                  | Suc (y': nat) -> eq x' y'
                  end
                end) _14 x
            then delete xs'
            else Suc (delete xs')
          end) xs') xs'
    else delete xs'
  end) _0


[guess]
True


[guess check]
True


[orig]
(
fix (delete: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (x: nat) (xs': list) -> 
    if (
      fix (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) _5 x
    then True
    else delete xs'
  end) _0


[guess]
True


[guess check]
True


[fusing <<524>>] 
fun (x: nat) -> 
fun (m: nat) -> $le x ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add x')
  end) m)


[yielding <<524>>] 
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $le x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end


[dec-free from]
(
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $le x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) n m


[dec-free context]

fun (add: nat -> nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (m: nat) -> add x x m


[dec-free expressed fix]

fun (x: nat) -> 
fun (m: nat) -> (
fix (add: nat -> nat -> nat -> bool) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $le x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add n x' x'[2]
    end
  end) x x m


[fusing <<525>>] 
fun (x: nat) -> 
fun (m: nat) -> (
fix (add: nat -> nat -> nat -> bool) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> $le x n
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add n x' x'[2]
    end
  end) x x m


[rep-arg orig]
$le x x


[rep-arg ctx]

fun (le: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> le x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $le x x


[fusing <<526>>] 
fun (x: nat) -> 
fun (y: nat) -> $le x x


[yielding <<526>>] 
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> True
  | Suc (y': nat) -> le y' _|_
  end


[orig]
(
fix (le: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (y': nat) -> le y'
  end) _1


[guess]
True


[guess check]
True


[fusing <<527>>] 
fun (x: nat) -> 
fun (x': nat) -> $le x (Suc x')


[yielding <<527>>] 
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end


[discovery prop (before)]

fun (x': nat) -> ((
fix<525> (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix<525> (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> $le x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq from]
((
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> $le x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq to]
(
match x'[3] with
| 0 -> (
  fix (le: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x'[2] with
      | 0 -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Suc (b0: nat) -> le x' b0
      end
    end) x'[2] x'
| Suc (x': nat) -> 
  match x'[3] with
  | 0 -> True
  | Suc (x': nat) -> (
    fun (x: nat) -> 
    fun (m: nat) -> 
    if (
      fix (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> $le x x'[3]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x m
    then c0
    else c1) x' x'[2]
  end
end =< 
if (
  fix (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> $le x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq from]
((
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end) x'[2] x' =< 
if $le x'[2] x'
then c0
else c1)


[leq to]
(
match x'[2] with
| 0 -> True
| Suc (x': nat) -> 
  match x'[2] with
  | 0 -> 
    match x' with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Suc (b0: nat) -> (
    fun (x: nat) -> 
    fun (x': nat) -> 
    if $le x x'
    then c0
    else c1) x' b0
  end
end =< 
if $le x'[2] x'
then c0
else c1)


[discovery prop]

fun (x': nat) -> 
match x'[3] with
| 0 -> 
  match x'[2] with
  | 0 -> (True =< 
    match x' with
    | 0 -> c0
    | Suc (y': nat) -> c0
    end)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< c1)
    | Suc (x': nat) -> (False =< c1)
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[3] in (True =< c0)
end


[hopefully true (before)]

match x'[2] with
| 0 -> 
  match x' with
  | 0 -> (True =< 
    match x' with
    | 0 -> True
    | Suc (y': nat) -> True
    end)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< (
      fix<525> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (le: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              | Suc (b0: nat) -> le x' b0
              end
            end) x x'[2]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[2] x'[3])
    | Suc (x': nat) -> (False =< (
      fix<525> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (le: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              | Suc (b0: nat) -> le x' b0
              end
            end) x x'[3]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[3] x'[4])
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[2] in (True =< True)
end


[hopefully true]
tt


[discovery prop (before)]

fun (x': nat) -> ((
fix<525> (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix<525> (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> $le x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[discovery prop]

fun (x': nat) -> 
match x'[3] with
| 0 -> 
  match x'[2] with
  | 0 -> (True =< 
    match x' with
    | 0 -> c0
    | Suc (y': nat) -> c0
    end)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< c1)
    | Suc (x': nat) -> (False =< c1)
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[3] in (True =< c0)
end


[hopefully true (before)]

match x'[2] with
| 0 -> 
  match x' with
  | 0 -> (True =< 
    match x' with
    | 0 -> True
    | Suc (y': nat) -> True
    end)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< (
      fix<525> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (le: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              | Suc (b0: nat) -> le x' b0
              end
            end) x x'[2]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[2] x'[3])
    | Suc (x': nat) -> (False =< (
      fix<525> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (le: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              | Suc (b0: nat) -> le x' b0
              end
            end) x x'[3]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[3] x'[4])
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[2] in (True =< True)
end


[hopefully true]
tt


[discovery prop (before)]

fun (x': nat) -> ((
fix<525> (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix<525> (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> $le x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[discovery prop]

fun (x': nat) -> 
match x'[3] with
| 0 -> 
  match x'[2] with
  | 0 -> (True =< 
    match x' with
    | 0 -> c0
    | Suc (y': nat) -> c0
    end)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< c1)
    | Suc (x': nat) -> (False =< c1)
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[3] in (True =< c0)
end


[hopefully true (before)]

match x'[2] with
| 0 -> 
  match x' with
  | 0 -> (True =< 
    match x' with
    | 0 -> True
    | Suc (y': nat) -> True
    end)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< (
      fix<525> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (le: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              | Suc (b0: nat) -> le x' b0
              end
            end) x x'[2]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[2] x'[3])
    | Suc (x': nat) -> (False =< (
      fix<525> (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (le: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              | Suc (b0: nat) -> le x' b0
              end
            end) x x'[3]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x'[3] x'[4])
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[2] in (True =< True)
end


[hopefully true]
tt


[yielding <<525>>] 
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      if add x' x'[2]
      then True
      else 
        if add x' x'[2]
        then True
        else (
          fix<525> (add: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (m: nat) -> 
            match m with
            | 0 -> (
              fix (le: nat -> nat -> bool) -> 
                fun (x: nat) -> 
                fun (x': nat) -> 
                match x with
                | 0 -> True
                | Suc (x': nat) -> 
                  match x'[2] with
                  | 0 -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> False
                    end
                  | Suc (b0: nat) -> le x' b0
                  end
                end) x x'
            | Suc (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> add x' x'[2]
              end
            end) x' x'[2]
    end
  end


[dec-free from]
(
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x' x'[2]


[dec-free context]

fun (add: nat -> nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (m: nat) -> add x x m


[dec-free expressed fix]

fun (x: nat) -> 
fun (m: nat) -> (
fix (add: nat -> nat -> nat -> bool) -> 
  fun (x': nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x'[3] x' x'[2]
    end
  end) x x m


[fusing <<528>>] 
fun (x: nat) -> 
fun (m: nat) -> (
fix (add: nat -> nat -> nat -> bool) -> 
  fun (x': nat) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x'[3] x' x'[2]
    end
  end) x x m


[rep-arg orig]
(
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end) x x


[rep-arg ctx]

fun (le: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (x': nat) -> le x x


[rep-arg full]

fun (x: nat) -> 
fun (x': nat) -> (
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end) x x


[fusing <<529>>] 
fun (x: nat) -> 
fun (x': nat) -> (
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end) x x


[yielding <<529>>] 
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> le x' _|_
  end


[orig]
(
fix (le: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> le x'
  end) _1


[guess]
True


[guess check]
True


[fusing <<530>>] 
fun (x: nat) -> 
fun (x': nat) -> (
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end) x (Suc x')


[yielding <<530>>] 
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      end
    | Suc (b0: nat) -> le x' b0
    end
  end


[discovery prop (before)]

fun (x': nat) -> ((
fix<528> (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix<528> (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x': nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x'[2] with
          | 0 -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> le x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq from]
((
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (le: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> 
        match x'[2] with
        | 0 -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          end
        | Suc (b0: nat) -> le x' b0
        end
      end) x x'
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> add x' x'[2]
    end
  end) x'[2] x'[3] =< 
if (
  fix (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x': nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x'[2] with
          | 0 -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> le x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq to]
(
match x'[3] with
| 0 -> (
  fix (le: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x'[2] with
      | 0 -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> 
          match x' with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        end
      | Suc (b0: nat) -> le x' b0
      end
    end) x'[2] x'
| Suc (x': nat) -> 
  match x'[3] with
  | 0 -> True
  | Suc (x': nat) -> (
    fun (x: nat) -> 
    fun (m: nat) -> 
    if (
      fix (add: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (m: nat) -> 
        match m with
        | 0 -> (
          fix (le: nat -> nat -> bool) -> 
            fun (x: nat) -> 
            fun (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> 
              match x'[2] with
              | 0 -> 
                match x' with
                | 0 -> True
                | Suc (x': nat) -> False
                end
              | Suc (b0: nat) -> le x' b0
              end
            end) x x'[3]
        | Suc (x': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> add x' x'[2]
          end
        end) x m
    then c0
    else c1) x' x'[2]
  end
end =< 
if (
  fix (add: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x': nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x'[2] with
          | 0 -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> le x' b0
          end
        end) x x'
    | Suc (x': nat) -> 
      match x with
      | 0 -> True
      | Suc (x': nat) -> add x' x'[2]
      end
    end) x'[2] x'[3]
then c0
else c1)


[leq from]
((
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (x': nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match x'[2] with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      end
    | Suc (b0: nat) -> le x' b0
    end
  end) x'[2] x' =< 
if (
  fix (le: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x'[2] with
      | 0 -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Suc (b0: nat) -> le x' b0
      end
    end) x'[2] x'
then c0
else c1)


[leq to]
(
match x'[2] with
| 0 -> True
| Suc (x': nat) -> 
  match x'[2] with
  | 0 -> 
    match x' with
    | 0 -> True
    | Suc (x': nat) -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    end
  | Suc (b0: nat) -> (
    fun (x: nat) -> 
    fun (x': nat) -> 
    if (
      fix (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (x': nat) -> 
        match x with
        | 0 -> True
        | Suc (x': nat) -> 
          match x'[2] with
          | 0 -> 
            match x' with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Suc (b0: nat) -> le x' b0
          end
        end) x x'
    then c0
    else c1) x' b0
  end
end =< 
if (
  fix (le: nat -> nat -> bool) -> 
    fun (x: nat) -> 
    fun (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      match x'[2] with
      | 0 -> 
        match x' with
        | 0 -> True
        | Suc (x': nat) -> False
        end
      | Suc (b0: nat) -> le x' b0
      end
    end) x'[2] x'
then c0
else c1)


[discovery prop]

fun (x': nat) -> 
match x'[3] with
| 0 -> 
  match x'[2] with
  | 0 -> (True =< c0)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< c0)
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (True =< c1)
      | Suc (x': nat) -> (False =< c1)
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[3] in (True =< c0)
end


[hopefully true (before)]

match x'[2] with
| 0 -> 
  match x' with
  | 0 -> (True =< True)
  | Suc (x': nat) -> 
    assert 0 <- x'[2] in 
    match x' with
    | 0 -> (True =< True)
    | Suc (x': nat) -> 
      match x' with
      | 0 -> (True =< (
        fix<528> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (le: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> le x' b0
                end
              end) x x'[3]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[3] x'[4])
      | Suc (x': nat) -> (False =< (
        fix<528> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (le: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> le x' b0
                end
              end) x x'[4]
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x'[4] x'[5])
      end
    end
  end
| Suc (x': nat) -> 
  assert 0 <- x'[2] in (True =< True)
end


[hopefully true]
tt


[yielding <<528>>] 
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      if add x' x'[2]
      then True
      else (
        fix<528> (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (le: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> le x' b0
                end
              end) x x'
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x' x'[2]
    end
  end


[orig]
(
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      if add x' x'[2]
      then True
      else (
        fix (add: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (m: nat) -> 
          match m with
          | 0 -> (
            fix (le: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (x': nat) -> 
              match x with
              | 0 -> True
              | Suc (x': nat) -> 
                match x'[2] with
                | 0 -> 
                  match x' with
                  | 0 -> True
                  | Suc (x': nat) -> 
                    match x' with
                    | 0 -> True
                    | Suc (x': nat) -> False
                    end
                  end
                | Suc (b0: nat) -> le x' b0
                end
              end) x x'
          | Suc (x': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> add x' x'[2]
            end
          end) x' x'[2]
    end
  end) _0 _1


[guess]
True


[guess check]
True


[orig]
(
fix (add: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> True
  | Suc (x': nat) -> 
    match x with
    | 0 -> True
    | Suc (x': nat) -> 
      if add x' x'[2]
      then True
      else True
    end
  end) _1 _0


[guess]
True


[guess check]
True


[fusing <<531>>] 
fun (x: nat) -> 
fun (n: nat) -> $le x (Suc n)


[yielding <<531>>] 
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (n: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match n with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end


[fusing <<532>>] 
fun (x: nat) -> 
fun (y: nat) -> 
assert True <- $le x y in (
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (n: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match n with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end) x y


[yielding <<532>>] 
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> True
    | Suc (y': nat) -> True
    end
  | Suc (x': nat) -> 
    assert Suc (b0: nat) <- y in 
    assert True <- $le x' b0 in le x' b0
  end


[orig]
(
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> True
    | Suc (y': nat) -> True
    end
  | Suc (x': nat) -> 
    assert Suc (b0: nat) <- y in le x' b0
  end) _0 _1


[guess]
True


[guess check]
True


[match fix from] (
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (n: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> 
    match n with
    | 0 -> 
      match x' with
      | 0 -> True
      | Suc (x': nat) -> False
      end
    | Suc (b0: nat) -> le x' b0
    end
  end) m n

[context] [True <- $le m n]

[to] True


[fusing <<533>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $eq x y[2] in $le y[2] y


[yielding <<533>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      match x with
      | 0 -> False
      | Suc (x': nat) -> 
        assert False <- $eq x' x'[2] in False
      end
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      match x with
      | 0 -> (
        fix<533> (le: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match y with
          | 0 -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Suc (y': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> le x' y'
            end
          end) x' y'
      | Suc (x': nat) -> 
        assert False <- $eq x' x'[2] in le x' x'[2] y'
      end
    end
  end


[fusing <<534>>] 
fun (n: nat) -> 
fun (xs: list) -> $elem n ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons m Nil
  | Cons (y: nat) (ys: list) -> 
    if $le m y
    then Cons m (Cons y ys)
    else Cons y (ins ys)
  end) xs)


[fusing <<535>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $le x y


[yielding <<535>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $le x' y' in False
    end
  | Suc (y': nat) -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> (
      fix<535> (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) x' y'
    | Suc (y': nat) -> 
      assert False <- $le x' y' in le x' y' y'[2]
    end
  end


[fusing <<536>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert False <- $eq x[2] y in $eq x y


[yielding <<536>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x[2] in True
    | Suc (y': nat) -> 
      match x[2] with
      | 0 -> False
      | Suc (x': nat) -> 
        assert False <- $eq x' y' in False
      end
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x[2] in False
    | Suc (y': nat) -> 
      match x[2] with
      | 0 -> (
        fix<536> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (x': nat) -> 
        assert False <- $eq x' y' in eq x' y' x'[2]
      end
    end
  end


[fusing <<537>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert True <- $le x[2] y in $eq x x[2]


[yielding <<537>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match x[2] with
    | 0 -> 
      match y with
      | 0 -> True
      | Suc (y': nat) -> True
      end
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y in 
      assert True <- $le y'[2] y' in False
    end
  | Suc (x': nat) -> 
    match x[2] with
    | 0 -> 
      match y with
      | 0 -> False
      | Suc (y': nat) -> False
      end
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y in 
      assert True <- $le y'[2] y' in eq y'[2] y' x'
    end
  end


[fusing <<538>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert True <- $le x[2] y in $eq x y


[yielding <<538>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> 
      assert 0 <- x[2] in True
    | Suc (y': nat) -> 
      match x[2] with
      | 0 -> False
      | Suc (x': nat) -> 
        assert True <- $le x' y' in False
      end
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert 0 <- x[2] in False
    | Suc (y': nat) -> 
      match x[2] with
      | 0 -> (
        fix<538> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (x': nat) -> 
        assert True <- $le x' y' in eq x' y' x'[2]
      end
    end
  end


[fusing <<539>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert False <- $le x[2] y in $eq x y


[yielding <<539>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x[2] in True
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in 
      assert False <- $le x' y' in False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x[2] in False
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in 
      assert False <- $le x' y' in eq x' y' x'[2]
    end
  end


[yielding <<534>>] 
fix (ins: nat -> list -> bool) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $eq n m
  | Cons (y: nat) (ys: list) -> 
    if $le m y
    then 
      if $eq n m
      then True
      else 
        if $eq n y
        then True
        else $elem n ys
    else 
      if $eq n y
      then True
      else ins n ys
  end


[fusing <<540>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert False <- $eq x[2] y in $eq x y


[yielding <<540>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x[2] in True
    | Suc (y': nat) -> 
      match x[2] with
      | 0 -> False
      | Suc (x': nat) -> 
        assert False <- $eq x' y' in False
      end
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x[2] in False
    | Suc (y': nat) -> 
      match x[2] with
      | 0 -> (
        fix<540> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (x': nat) -> 
        assert False <- $eq x' y' in eq x' y' x'[2]
      end
    end
  end


[fusing <<541>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert True <- $le x[2] y in $eq x x[2]


[yielding <<541>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match x[2] with
    | 0 -> 
      match y with
      | 0 -> True
      | Suc (y': nat) -> True
      end
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y in 
      assert True <- $le y'[2] y' in False
    end
  | Suc (x': nat) -> 
    match x[2] with
    | 0 -> 
      match y with
      | 0 -> False
      | Suc (y': nat) -> False
      end
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y in 
      assert True <- $le y'[2] y' in eq y'[2] y' x'
    end
  end


[fusing <<542>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert True <- $le x[2] y in $eq x y


[yielding <<542>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> 
      assert 0 <- x[2] in True
    | Suc (y': nat) -> 
      match x[2] with
      | 0 -> False
      | Suc (x': nat) -> 
        assert True <- $le x' y' in False
      end
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert 0 <- x[2] in False
    | Suc (y': nat) -> 
      match x[2] with
      | 0 -> (
        fix<542> (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) x' y'
      | Suc (x': nat) -> 
        assert True <- $le x' y' in eq x' y' x'[2]
      end
    end
  end


[fusing <<543>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert False <- $le x[2] y in $eq x y


[yielding <<543>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x[2] in True
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in 
      assert False <- $le x' y' in False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x[2] in False
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in 
      assert False <- $le x' y' in eq x' y' x'[2]
    end
  end


[leq from]
((
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (y: nat) (ys: list) -> 
    if $le m y
    then 
      if $eq n y
      then True
      else $elem n ys
    else 
      if $eq n y
      then True
      else ins ys
  end) xs =< $elem n xs)


[leq to]
(
match xs with
| Nil -> False
| Cons (y: nat) (ys: list) -> 
  if $le m y
  then 
    if $eq n y
    then True
    else $elem n ys
  else 
    if $eq n y
    then True
    else (
      fun (xs: list) -> $elem n xs) ys
end =< $elem n xs)


[fusing <<544>>] 
fun (n: nat) -> 
fun (xs: list) -> (
fix (count: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then Suc (count ys)
    else count ys
  end) ((
fix (snoc: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons m Nil
  | Cons (x: nat) (xs': list) -> Cons x (snoc xs')
  end) xs)


[yielding <<544>>] 
fix (snoc: nat -> list -> nat) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 
    if $eq n m
    then Suc 0
    else 0
  | Cons (x: nat) (xs': list) -> 
    if $eq n x
    then Suc (snoc n xs')
    else snoc n xs'
  end


[fusing <<545>>] 
fun (xs: list) -> $is_sorted ($insertsort xs)


[discovery prop (before)]

fun (g: list) -> ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Cons y[2] (Cons y ys)
    else Cons y (ins ys)
  end) g =< 
if $is_sorted g
then c0
else c1)


[leq from]
((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Cons y[2] (Cons y ys)
    else Cons y (ins ys)
  end) g =< 
if $is_sorted g
then c0
else c1)


[leq to]
(
match g with
| Nil -> Cons y Nil
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then Cons y[2] (Cons y ys)
  else Cons y ((
    fun (xs: list) -> 
    if $is_sorted xs
    then c0
    else c1) ys)
end =< 
if $is_sorted g
then c0
else c1)


[fusing <<546>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $le x y[2] in $le y[2] y


[yielding <<546>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x in True
    | Suc (x': nat) -> 
      match x with
      | 0 -> False
      | Suc (x': nat) -> 
        assert True <- $le x' x'[2] in False
      end
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x in True
    | Suc (x': nat) -> 
      match x with
      | 0 -> (
        fix<546> (le: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match y with
          | 0 -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Suc (y': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> le x' y'
            end
          end) x' y'
      | Suc (x': nat) -> 
        assert True <- $le x' x'[2] in le x' x'[2] y'
      end
    end
  end


[fusing <<547>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $le y[2] y


[yielding <<547>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert False <- $le x' x'[2] in False
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert False <- $le x' x'[2] in le x' x'[2] y'
    end
  end


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (Cons y Nil =< c0)
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then (Cons y[2] (Cons y ys) =< 
    match ys with
    | Nil -> c0
    | Cons (z: nat) (zs: list) -> 
      if $le y z
      then 
        if $is_sorted (Cons z zs)
        then c0
        else c1
      else c1
    end)
  else (Cons y (
    if $is_sorted ys
    then c0
    else c1) =< 
    match ys with
    | Nil -> c0
    | Cons (z: nat) (zs: list) -> 
      if $le y z
      then 
        if $is_sorted (Cons z zs)
        then c0
        else c1
      else c1
    end)
end


[discovery prop (before)]

fun (g: list) -> ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Cons y[2] (Cons y ys)
    else Cons y (ins ys)
  end) g =< 
if $is_sorted g
then c0
else c1)


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (Cons y Nil =< c0)
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then (Cons y[2] (Cons y ys) =< 
    match ys with
    | Nil -> c0
    | Cons (z: nat) (zs: list) -> 
      if $le y z
      then 
        if $is_sorted (Cons z zs)
        then c0
        else c1
      else c1
    end)
  else (Cons y (
    if $is_sorted ys
    then c0
    else c1) =< 
    match ys with
    | Nil -> c0
    | Cons (z: nat) (zs: list) -> 
      if $le y z
      then 
        if $is_sorted (Cons z zs)
        then c0
        else c1
      else c1
    end)
end


[fusing <<548>>] 
fun (x0: list) -> $is_sorted ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then Cons y[2] (Cons y ys)
    else Cons y (ins ys)
  end) x0)


[fusing <<549>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $le x y


[yielding <<549>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $le x' y' in False
    end
  | Suc (y': nat) -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> (
      fix<549> (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) x' y'
    | Suc (y': nat) -> 
      assert False <- $le x' y' in le x' y' y'[2]
    end
  end


[fusing <<550>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $le y[2] y


[yielding <<550>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert False <- $le x' x'[2] in False
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert False <- $le x' x'[2] in le x' x'[2] y'
    end
  end


[yielding <<548>>] 
fix (ins: list -> bool) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then $is_sorted (Cons y ys)
    else 
      match (
      fix<548> (ins: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> Cons y[2] Nil
        | Cons (y: nat) (ys: list) -> 
          if $le y[3] y
          then Cons y[3] (Cons y ys)
          else Cons y (ins ys)
        end) ys with
      | Nil -> True
      | Cons (z: nat) (zs: list) -> 
        if $le y z
        then ins ys
        else False
      end
  end


[fusing <<551>>] 
fun (x: nat) -> 
fun (y: nat) -> 
assert False <- $le x y in $le y x


[yielding <<551>>] 
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  assert Suc (y': nat) <- x in 
  match y with
  | 0 -> True
  | Suc (x': nat) -> 
    assert False <- $le y' x' in le y' x'
  end


[orig]
(
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  assert Suc (y': nat) <- x in 
  match y with
  | 0 -> True
  | Suc (x': nat) -> le y' x'
  end) _5 _1


[guess]
True


[guess check]
True


[match fix from] $le y y[2]

[context] [False <- $le y[2] y]

[to] True


[fusing <<552>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $le x y


[yielding <<552>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $le x' y' in False
    end
  | Suc (y': nat) -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> (
      fix<552> (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) x' y'
    | Suc (y': nat) -> 
      assert False <- $le x' y' in le x' y' y'[2]
    end
  end


[fusing <<553>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $le x y[2] in (
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  assert Suc (y': nat) <- x in 
  match y with
  | 0 -> True
  | Suc (x': nat) -> le y' x'
  end) x y


[orig]
(
fix<553> (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  assert Suc (y': nat) <- x in 
  match y with
  | 0 -> True
  | Suc (x': nat) -> le y' x'
  end) _1 _0


[guess]
True


[guess check]
True


[fusing <<554>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $le y[2] y


[yielding <<554>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert False <- $le x' x'[2] in False
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert False <- $le x' x'[2] in le x' x'[2] y'
    end
  end


[fusing <<555>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in (
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in False
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in le x' x'[2] y'
    end
  end) x y y[2]


[yielding <<555>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y[2] with
  | 0 -> 
    assert Suc (x': nat) <- x in 
    match y with
    | 0 -> True
    | Suc (x': nat) -> False
    end
  | Suc (y': nat) -> 
    match y with
    | 0 -> 
      assert Suc (x': nat) <- x in 
      assert False <- $le x' y' in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert False <- $le x' y' in le x' y' x'[2]
    end
  end


[discovery prop (before)]

fun (g: list) -> ((
fix (ins: list -> bool) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then $is_sorted (Cons y ys)
    else 
      match ys with
      | Nil -> ins Nil
      | Cons (y: nat) (ys: list) -> 
        if $le y[3] y
        then 
          if $le y[2] y[3]
          then ins (Cons y ys)
          else False
        else 
          if $le y[2] y
          then ins (Cons y ys)
          else False
      end
  end) g =< 
if $is_sorted g
then c0
else c1)


[leq from]
((
fix (ins: list -> bool) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if $le y[2] y
    then $is_sorted (Cons y ys)
    else 
      match ys with
      | Nil -> ins Nil
      | Cons (y: nat) (ys: list) -> 
        if $le y[3] y
        then 
          if $le y[2] y[3]
          then ins (Cons y ys)
          else False
        else 
          if $le y[2] y
          then ins (Cons y ys)
          else False
      end
  end) g =< 
if $is_sorted g
then c0
else c1)


[leq to]
(
match g with
| Nil -> True
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then $is_sorted (Cons y ys)
  else 
    match ys with
    | Nil -> (
      fun (x0: list) -> 
      if $is_sorted x0
      then c0
      else c1) Nil
    | Cons (y: nat) (ys: list) -> 
      if $le y[3] y
      then 
        if $le y[2] y[3]
        then (
          fun (x0: list) -> 
          if $is_sorted x0
          then c0
          else c1) (Cons y ys)
        else False
      else 
        if $le y[2] y
        then (
          fun (x0: list) -> 
          if $is_sorted x0
          then c0
          else c1) (Cons y ys)
        else False
    end
end =< 
if $is_sorted g
then c0
else c1)


[fusing <<556>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $le x y[2] in $le y[2] y


[yielding <<556>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x in True
    | Suc (x': nat) -> 
      match x with
      | 0 -> False
      | Suc (x': nat) -> 
        assert True <- $le x' x'[2] in False
      end
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x in True
    | Suc (x': nat) -> 
      match x with
      | 0 -> (
        fix<556> (le: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match y with
          | 0 -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Suc (y': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> le x' y'
            end
          end) x' y'
      | Suc (x': nat) -> 
        assert True <- $le x' x'[2] in le x' x'[2] y'
      end
    end
  end


[fusing <<557>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
fun (y: nat) -> 
assert True <- $le x[2] y[2] in (
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in False
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in le x' x'[2] y'
    end
  end) x y[2] y


[yielding <<557>>] 
fix (le: nat -> nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x[2] in 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      match x[2] with
      | 0 -> False
      | Suc (x': nat) -> 
        assert True <- $le x' x'[3] in False
      end
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x[2] in 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      match x[2] with
      | 0 -> (
        fix<557> (le: nat -> nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          fun (y: nat) -> 
          match y with
          | 0 -> 
            match y[2] with
            | 0 -> 
              assert Suc (x': nat) <- x in True
            | Suc (x': nat) -> 
              assert Suc (x': nat) <- x in False
            end
          | Suc (y': nat) -> 
            match y[2] with
            | 0 -> 
              assert Suc (x': nat) <- x in True
            | Suc (x': nat) -> 
              assert Suc (x': nat) <- x in le x' x'[2] y'
            end
          end) x' x'[2] y'
      | Suc (x': nat) -> 
        assert True <- $le x' x'[3] in le x' x'[3] x'[2] y'
      end
    end
  end


[fusing <<558>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $le x y[2] in (
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in False
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert Suc (x': nat) <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in le x' x'[2] y'
    end
  end) x y y[2]


[yielding <<558>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  assert Suc (y': nat) <- y[2] in 
  match y with
  | 0 -> 
    assert Suc (x': nat) <- x in 
    assert True <- $le x' y' in True
  | Suc (x': nat) -> 
    assert Suc (x': nat) <- x in 
    assert True <- $le x' y' in le x' y' x'[2]
  end


[orig]
(
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  assert Suc (y': nat) <- y[2] in 
  match y with
  | 0 -> True
  | Suc (x': nat) -> 
    assert Suc (x': nat) <- x in le x' y' x'[2]
  end) _8 _1 _3


[guess]
True


[guess check]
True


[match fix from] $le y[2] y

[context] [False <- $le y[3] y[2], True <- $le y[3] y]

[to] True


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (True =< c0)
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then 
    match ys with
    | Nil -> (True =< c0)
    | Cons (z: nat) (zs: list) -> 
      if $le y z
      then 
        if $is_sorted (Cons z zs)
        then (True =< c0)
        else (False =< c1)
      else (False =< c1)
    end
  else 
    assert Cons (y: nat) (ys: list) <- ys in 
    if $le y[3] y
    then 
      assert False <- $le y[2] y[3] in (False =< 
      if $is_sorted (Cons y ys)
      then c0
      else c1)
    else 
      assert False <- $le y[2] y in (False =< c1)
end


[fusing <<559>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $le x y[2] in $le y[2] y


[yielding <<559>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x in True
    | Suc (x': nat) -> 
      match x with
      | 0 -> False
      | Suc (x': nat) -> 
        assert True <- $le x' x'[2] in False
      end
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x in True
    | Suc (x': nat) -> 
      match x with
      | 0 -> (
        fix<559> (le: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match y with
          | 0 -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> False
            end
          | Suc (y': nat) -> 
            match x with
            | 0 -> True
            | Suc (x': nat) -> le x' y'
            end
          end) x' y'
      | Suc (x': nat) -> 
        assert True <- $le x' x'[2] in le x' x'[2] y'
      end
    end
  end


[orig]
(
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  assert Suc (y': nat) <- x in 
  match y with
  | 0 -> True
  | Suc (x': nat) -> le y' x'
  end) _7 _3


[guess]
True


[guess check]
True


[match fix from] $le y[2] y[3]

[context] [False <- $le y[3] y[2]]

[to] True


[hopefully true (before)]

match (
fix<545> (isort: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: nat) (ys: list) -> (
    fix (ins: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons y Nil
      | Cons (y: nat) (ys: list) -> 
        if $le y[2] y
        then Cons y[2] (Cons y ys)
        else Cons y (ins ys)
      end) (isort ys)
  end) ys with
| Nil -> (True =< True)
| Cons (y: nat) (ys: list) -> 
  if $le y[2] y
  then 
    match ys with
    | Nil -> (True =< True)
    | Cons (z: nat) (zs: list) -> 
      if $le y z
      then 
        if $is_sorted (Cons z zs)
        then (True =< True)
        else (False =< False)
      else (False =< False)
    end
  else 
    assert Cons (y: nat) (ys: list) <- ys in 
    if $le y[3] y
    then 
      assert False <- $le y[2] y[3] in (False =< 
      if $is_sorted (Cons y ys)
      then True
      else False)
    else 
      assert False <- $le y[2] y in (False =< False)
end


[hopefully true]
tt


[yielding <<545>>] 
fix (isort: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> isort ys
  end


[orig]
(
fix (isort: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> isort ys
  end) _0


[guess]
True


[guess check]
True


[fusing <<560>>] 
fun (n: nat) -> 
fun (xs: list) -> $take<$0> n ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<560>>] 
fix (app: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $take<$0> n ys
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons y (app n' ys)
    end
  end


[fusing <<561>>] 
fun (xs: list) -> 
fun (n: nat) -> 
fun (xs: list) -> $take<$0> ((
fix (len: nat -> list -> nat) -> 
  fun (x: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> x
  | Cons (y: A) (ys: list) -> 
    match x with
    | 0 -> 0
    | Suc (x': nat) -> len x' ys
    end
  end) n xs) xs[2]


[yielding <<561>>] 
fix (len: list -> nat -> list -> list) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $take<$0> n xs[2]
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (x': nat) -> len xs[2] x' ys
    end
  end


[fusing <<562>>] 
fun (ys: list) -> 
fun (n: nat) -> 
fun (xs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (len: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $take<$0> n ys
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (x': nat) -> len x' ys
        end
      end) n[2] xs[3]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ($take<$0> n xs)


[yielding <<562>>] 
fix (take: list -> nat -> list -> list) -> 
  fun (ys: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (len: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $take<$0> n ys
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (x': nat) -> len x' ys
        end
      end) n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $take<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> Nil
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take ys[2] n' ys)
    end
  end


[dec-free from]
(
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (len: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $take<$0> n ys
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (x': nat) -> len x' ys
        end
      end) n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $take<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> Nil
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end) n xs


[dec-free context]

fun (take: nat -> list -> nat -> list -> list) -> 
fun (n: nat) -> 
fun (xs: list) -> take n xs n xs


[dec-free expressed fix]

fun (n: nat) -> 
fun (xs: list) -> (
fix (take: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (len: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $take<$0> n ys
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (x': nat) -> len x' ys
        end
      end) n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $take<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> Nil
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n[2] xs[2] n' ys)
    end
  end) n xs n xs


[fusing <<563>>] 
fun (n: nat) -> 
fun (xs: list) -> (
fix (take: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (len: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $take<$0> n ys
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (x': nat) -> len x' ys
        end
      end) n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $take<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> Nil
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n[2] xs[2] n' ys)
    end
  end) n xs n xs


[yielding <<563>>] 
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Nil
    end
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Cons y ($take<$0> n' ys)
      end
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end


[leq from]
((
fix (app: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $take<$0> n ys
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons y (app n' ys)
    end
  end) n xs =< (
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Nil
    end
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Cons y ($take<$0> n' ys)
      end
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end) n xs)


[leq to]
(
match xs with
| Nil -> $take<$0> n ys
| Cons (y: A) (ys: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> Cons y ((
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (take: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match n with
      | 0 -> 
        match xs with
        | Nil -> Nil
        | Cons (y: A) (ys: list) -> Nil
        end
      | Suc (n': nat) -> 
        match xs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (y: A) (ys: list) -> Cons y ($take<$0> n' ys)
          end
        | Cons (y: A) (ys: list) -> Cons y (take n' ys)
        end
      end) n xs) n' ys)
  end
end =< (
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Nil
    end
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Cons y ($take<$0> n' ys)
      end
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end) n xs)


[dec-free from]
(
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (len: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $take<$0> n ys
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (x': nat) -> len x' ys
        end
      end) n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $take<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> Nil
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end) n xs


[dec-free context]

fun (take: nat -> list -> nat -> list -> list) -> 
fun (n: nat) -> 
fun (xs: list) -> take n xs n xs


[dec-free expressed fix]

fun (n: nat) -> 
fun (xs: list) -> (
fix (take: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> (
    fix (len: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $take<$0> n ys
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (x': nat) -> len x' ys
        end
      end) n[2] xs[2]
  | Suc (n': nat) -> 
    match xs with
    | Nil -> (
      fix (len: nat -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $take<$0> n ys
        | Cons (y: A) (ys: list) -> 
          match n with
          | 0 -> Nil
          | Suc (x': nat) -> len x' ys
          end
        end) n[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons y (take n[2] xs[2] n' ys)
    end
  end) n xs n xs


[leq from]
((
fix (take: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Nil
    end
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Cons y ($take<$0> n' ys)
      end
    | Cons (y: A) (ys: list) -> Cons y (take n' ys)
    end
  end) n xs =< (
fix (app: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $take<$0> n ys
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons y (app n' ys)
    end
  end) n xs)


[leq to]
(
match n with
| 0 -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> Nil
  end
| Suc (n': nat) -> 
  match xs with
  | Nil -> 
    match ys with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons y ($take<$0> n' ys)
    end
  | Cons (y: A) (ys: list) -> Cons y ((
    fun (n: nat) -> 
    fun (xs: list) -> (
    fix (app: nat -> list -> list) -> 
      fun (n: nat) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $take<$0> n ys[2]
      | Cons (y: A) (ys: list) -> 
        match n with
        | 0 -> Nil
        | Suc (n': nat) -> Cons y (app n' ys)
        end
      end) n xs) n' ys)
  end
end =< (
fix (app: nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $take<$0> n ys
  | Cons (y: A) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons y (app n' ys)
    end
  end) n xs)


[fusing <<564>>] 
fun (xs: list) -> 
fun (n: nat) -> 
fun (ys: list) -> $zip<$0, $1> xs ($take<$0> n ys)


[yielding <<564>>] 
fix (take: list -> nat -> list -> list) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (ys: list) -> 
  match n with
  | 0 -> 
    match xs with
    | Nil -> Nil
    | Cons (x: A) (xs: list) -> Nil
    end
  | Suc (n': nat) -> 
    match ys with
    | Nil -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Cons (tuple x y) (take xs n' ys)
      end
    end
  end


[fusing <<565>>] 
fun (n: nat) -> 
fun (ys: list) -> 
fun (n: nat) -> 
fun (xs: list) -> (
fix (take: list -> nat -> list -> list) -> 
  fun (xs: list) -> 
  fun (n: nat) -> 
  fun (ys: list) -> 
  match n with
  | 0 -> 
    match xs with
    | Nil -> Nil
    | Cons (x: A) (xs: list) -> Nil
    end
  | Suc (n': nat) -> 
    match ys with
    | Nil -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> 
      match xs with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Cons (tuple x y) (take xs n' ys)
      end
    end
  end) ($take<$0> n[2] xs) n[2] ys


[yielding <<565>>] 
fix (take: nat -> list -> nat -> list -> list) -> 
  fun (n: nat) -> 
  fun (ys: list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match n[2] with
  | 0 -> Nil
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> 
      match ys[2] with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (take n' ys _|_ ys[2])
      end
    end
  end


[fusing <<566>>] 
fun (n: nat) -> 
fun (xs: list) -> 
fun (ys: list) -> $take<($0,$1)> n ($zip<$0, $1> xs ys)


[yielding <<566>>] 
fix (zip: nat -> list -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match xs with
  | Nil -> 
    match ys with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: B) (ys: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    end
  | Cons (x: A) (xs: list) -> 
    match ys with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: B) (ys: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Cons (tuple x y) (zip n' xs ys)
      end
    end
  end


[leq from]
((
fix (take: nat -> list -> list -> list) -> 
  fun (n: nat) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> 
      match ys[2] with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (take n' ys ys[2])
      end
    end
  end) n ys xs =< (
fix (zip: nat -> list -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match xs with
  | Nil -> 
    match ys with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: B) (ys: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    end
  | Cons (x: A) (xs: list) -> 
    match ys with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: B) (ys: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Cons (tuple x y) (zip n' xs ys)
      end
    end
  end) n xs ys)


[leq to]
(
match n with
| 0 -> Nil
| Suc (n': nat) -> 
  match xs with
  | Nil -> 
    match ys with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Nil
    end
  | Cons (y: A) (ys: list) -> 
    match ys[2] with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) ((
      fun (n: nat) -> 
      fun (ys: list) -> 
      fun (xs: list) -> (
      fix (zip: nat -> list -> list -> list) -> 
        fun (n: nat) -> 
        fun (xs: list) -> 
        fun (ys: list) -> 
        match xs with
        | Nil -> 
          match ys with
          | Nil -> 
            match n with
            | 0 -> Nil
            | Suc (n': nat) -> Nil
            end
          | Cons (y: B) (ys: list) -> 
            match n with
            | 0 -> Nil
            | Suc (n': nat) -> Nil
            end
          end
        | Cons (x: A) (xs: list) -> 
          match ys with
          | Nil -> 
            match n with
            | 0 -> Nil
            | Suc (n': nat) -> Nil
            end
          | Cons (y: B) (ys: list) -> 
            match n with
            | 0 -> Nil
            | Suc (n': nat) -> Cons (tuple x y) (zip n' xs ys)
            end
          end
        end) n xs ys) n' ys ys[2])
    end
  end
end =< (
fix (zip: nat -> list -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match xs with
  | Nil -> 
    match ys with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: B) (ys: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    end
  | Cons (x: A) (xs: list) -> 
    match ys with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: B) (ys: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Cons (tuple x y) (zip n' xs ys)
      end
    end
  end) n xs ys)


[leq from]
((
fix (zip: nat -> list -> list -> list) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match xs with
  | Nil -> 
    match ys with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: B) (ys: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    end
  | Cons (x: A) (xs: list) -> 
    match ys with
    | Nil -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Nil
      end
    | Cons (y: B) (ys: list) -> 
      match n with
      | 0 -> Nil
      | Suc (n': nat) -> Cons (tuple x y) (zip n' xs ys)
      end
    end
  end) n xs ys =< (
fix (take: nat -> list -> list -> list) -> 
  fun (n: nat) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> 
      match ys[2] with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (take n' ys ys[2])
      end
    end
  end) n ys xs)


[leq to]
(
match xs with
| Nil -> 
  match ys with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: B) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  end
| Cons (x: A) (xs: list) -> 
  match ys with
  | Nil -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Nil
    end
  | Cons (y: B) (ys: list) -> 
    match n with
    | 0 -> Nil
    | Suc (n': nat) -> Cons (tuple x y) ((
      fun (n: nat) -> 
      fun (xs: list) -> 
      fun (ys: list) -> (
      fix (take: nat -> list -> list -> list) -> 
        fun (n: nat) -> 
        fun (ys: list) -> 
        fun (xs: list) -> 
        match n with
        | 0 -> Nil
        | Suc (n': nat) -> 
          match xs with
          | Nil -> 
            match ys with
            | Nil -> Nil
            | Cons (y: A) (ys: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> 
            match ys[2] with
            | Nil -> Nil
            | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (take n' ys ys[2])
            end
          end
        end) n ys xs) n' xs ys)
    end
  end
end =< (
fix (take: nat -> list -> list -> list) -> 
  fun (n: nat) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match n with
  | 0 -> Nil
  | Suc (n': nat) -> 
    match xs with
    | Nil -> 
      match ys with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> 
      match ys[2] with
      | Nil -> Nil
      | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (take n' ys ys[2])
      end
    end
  end) n ys xs)


[fusing <<567>>] 
fun (ys: list) -> 
fun (xs: list) -> $zip<$0, $1> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys[2]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs) ys


[yielding <<567>>] 
fix (app: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> ys[2] ys
  | Cons (y: A) (ys: list) -> 
    match ys[2] with
    | Nil -> Nil
    | Cons (y: B) (ys: list) -> Cons (tuple y[2] y) (app ys ys[2])
    end
  end


[fusing <<568>>] 
fun (xs: list) -> 
fun (xs: list) -> $take<$0> ($length<$0> xs) xs[2]


[yielding <<568>>] 
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match xs[2] with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons y (len ys ys[2])
    end
  end


[fusing <<569>>] 
fun (xs: list) -> 
fun (zs: list) -> 
fun (xs: list) -> $zip<$0, $1> xs[2] ((
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match xs[2] with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons y (len ys ys[2])
    end
  end) zs xs[2])


[yielding <<569>>] 
fix (len: list -> list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  fun (xs: list) -> 
  match xs[2] with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys _|_)
    end
  end


[fusing <<570>>] 
fun (xs: list) -> 
fun (xs: list) -> $drop<$0> ($length<$0> xs) xs[2]


[yielding <<570>>] 
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> 
    match xs[2] with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> len ys ys[2]
    end
  end


[fusing <<571>>] 
fun (xs: list) -> 
fun (zs: list) -> 
fun (xs: list) -> $zip<$0, $1> xs[2] ((
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> 
    match xs[2] with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> len ys ys[2]
    end
  end) zs xs)


[yielding <<571>>] 
fix (len: list -> list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> xs[2] zs
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> 
      match xs[2] with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> len xs[2] ys ys[2]
    end
  end


[fusing <<572>>] 
fun (ys: list) -> 
fun (xs: list) -> 
fun (zs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (zs: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys zs
      | Cons (y: A) (ys: list) -> 
        match zs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (x: A) (xs: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) zs[2] xs[3]
  | Cons (y: ($0,$1)) (ys: list) -> Cons y (app ys)
  end) ((
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys)
    end
  end) xs zs)


[yielding <<572>>] 
fix (len: list -> list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (zs: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys zs
      | Cons (y: A) (ys: list) -> 
        match zs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (x: A) (xs: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) zs[2] xs[2]
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (zs: list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $zip<$0, $1> ys[2] zs
        | Cons (y: A) (ys: list) -> 
          match zs with
          | Nil -> 
            match ys[3] with
            | Nil -> Nil
            | Cons (x: A) (xs: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) zs[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[3] ys[2] ys)
    end
  end


[dec-free from]
(
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (zs: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys zs
      | Cons (y: A) (ys: list) -> 
        match zs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (x: A) (xs: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) zs[2] xs[2]
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (zs: list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $zip<$0, $1> ys[2] zs
        | Cons (y: A) (ys: list) -> 
          match zs with
          | Nil -> 
            match ys[3] with
            | Nil -> Nil
            | Cons (x: A) (xs: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) zs[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys)
    end
  end) xs zs


[dec-free context]

fun (len: list -> list -> list -> list -> list) -> 
fun (xs: list) -> 
fun (zs: list) -> len xs zs xs zs


[dec-free expressed fix]

fun (xs: list) -> 
fun (zs: list) -> (
fix (len: list -> list -> list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (zs: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys zs
      | Cons (y: A) (ys: list) -> 
        match zs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (x: A) (xs: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) zs[2] xs[2]
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (zs: list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $zip<$0, $1> ys[2] zs
        | Cons (y: A) (ys: list) -> 
          match zs with
          | Nil -> 
            match ys[3] with
            | Nil -> Nil
            | Cons (x: A) (xs: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) zs[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len xs[2] zs[2] ys[2] ys)
    end
  end) xs zs xs zs


[fusing <<573>>] 
fun (xs: list) -> 
fun (zs: list) -> (
fix (len: list -> list -> list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (zs: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys zs
      | Cons (y: A) (ys: list) -> 
        match zs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (x: A) (xs: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) zs[2] xs[2]
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (zs: list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $zip<$0, $1> ys[2] zs
        | Cons (y: A) (ys: list) -> 
          match zs with
          | Nil -> 
            match ys[3] with
            | Nil -> Nil
            | Cons (x: A) (xs: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) zs[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len xs[2] zs[2] ys[2] ys)
    end
  end) xs zs xs zs


[yielding <<573>>] 
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> ys zs
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> 
      match ys[2] with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys)
    end
  end


[leq from]
((
fix (app: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> ys[2] ys
  | Cons (y: A) (ys: list) -> 
    match ys[2] with
    | Nil -> Nil
    | Cons (y: B) (ys: list) -> Cons (tuple y[2] y) (app ys ys[2])
    end
  end) zs xs =< (
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> ys zs
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> 
      match ys[2] with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys)
    end
  end) xs zs)


[leq to]
(
match xs with
| Nil -> $zip<$0, $1> ys zs
| Cons (y: A) (ys: list) -> 
  match zs with
  | Nil -> Nil
  | Cons (y: B) (ys: list) -> Cons (tuple y[2] y) ((
    fun (ys: list) -> 
    fun (xs: list) -> (
    fix (len: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (zs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys[4] zs
      | Cons (y: A) (ys: list) -> 
        match zs with
        | Nil -> 
          match ys[5] with
          | Nil -> Nil
          | Cons (x: A) (xs: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys)
        end
      end) xs ys) ys ys[2])
  end
end =< (
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> ys zs
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> 
      match ys[2] with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys)
    end
  end) xs zs)


[dec-free from]
(
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (zs: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys zs
      | Cons (y: A) (ys: list) -> 
        match zs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (x: A) (xs: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) zs[2] xs[2]
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (zs: list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $zip<$0, $1> ys[2] zs
        | Cons (y: A) (ys: list) -> 
          match zs with
          | Nil -> 
            match ys[3] with
            | Nil -> Nil
            | Cons (x: A) (xs: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) zs[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys)
    end
  end) xs zs


[dec-free context]

fun (len: list -> list -> list -> list -> list) -> 
fun (xs: list) -> 
fun (zs: list) -> len xs zs xs zs


[dec-free expressed fix]

fun (xs: list) -> 
fun (zs: list) -> (
fix (len: list -> list -> list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (zs: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys zs
      | Cons (y: A) (ys: list) -> 
        match zs with
        | Nil -> 
          match ys[2] with
          | Nil -> Nil
          | Cons (x: A) (xs: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) zs[2] xs[2]
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (zs: list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $zip<$0, $1> ys[2] zs
        | Cons (y: A) (ys: list) -> 
          match zs with
          | Nil -> 
            match ys[3] with
            | Nil -> Nil
            | Cons (x: A) (xs: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) zs[2] xs[2]
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len xs[2] zs[2] ys[2] ys)
    end
  end) xs zs xs zs


[leq from]
((
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (zs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> ys zs
  | Cons (y: A) (ys: list) -> 
    match zs with
    | Nil -> 
      match ys[2] with
      | Nil -> Nil
      | Cons (x: A) (xs: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) (len ys[2] ys)
    end
  end) xs zs =< (
fix (app: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> ys[2] ys
  | Cons (y: A) (ys: list) -> 
    match ys[2] with
    | Nil -> Nil
    | Cons (y: B) (ys: list) -> Cons (tuple y[2] y) (app ys ys[2])
    end
  end) zs xs)


[leq to]
(
match xs with
| Nil -> $zip<$0, $1> ys zs
| Cons (y: A) (ys: list) -> 
  match zs with
  | Nil -> 
    match ys[2] with
    | Nil -> Nil
    | Cons (x: A) (xs: list) -> Nil
    end
  | Cons (y: A) (ys: list) -> Cons (tuple y[2] y) ((
    fun (xs: list) -> 
    fun (zs: list) -> (
    fix (app: list -> list -> list) -> 
      fun (ys: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $zip<$0, $1> ys[4] ys
      | Cons (y: A) (ys: list) -> 
        match ys[2] with
        | Nil -> Nil
        | Cons (y: B) (ys: list) -> Cons (tuple y[2] y) (app ys ys[2])
        end
      end) zs xs) ys[2] ys)
  end
end =< (
fix (app: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $zip<$0, $1> ys[2] ys
  | Cons (y: A) (ys: list) -> 
    match ys[2] with
    | Nil -> Nil
    | Cons (y: B) (ys: list) -> Cons (tuple y[2] y) (app ys ys[2])
    end
  end) zs xs)


[fusing <<574>>] 
fun (xs: list) -> 
fun (ys: list) -> $zip<$0, $1> xs ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> zs
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys)


[yielding <<574>>] 
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs zs
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> Nil
    | Cons (x: A) (xs: list) -> Cons (tuple x y) (app xs ys)
    end
  end


[fusing <<575>>] 
fun (ys: list) -> 
fun (xs: list) -> 
fun (ys: list) -> $zip<$0, $1> ((
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match xs[2] with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons y (len ys ys[2])
    end
  end) xs ys[2]) ys[2]


[yielding <<575>>] 
fix (len: list -> list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match ys[2] with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys _|_)
    end
  end


[fusing <<576>>] 
fun (ys: list) -> 
fun (xs: list) -> 
fun (ys: list) -> $zip<$0, $1> ((
fix (len: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> 
    match xs[2] with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> len ys ys[2]
    end
  end) xs ys) ys[2]


[yielding <<576>>] 
fix (len: list -> list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs ys[2]
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> 
      match ys[3] with
      | Nil -> Nil
      | Cons (y: B) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> len ys[4] ys ys[2]
    end
  end


[fusing <<577>>] 
fun (zs: list) -> 
fun (ys: list) -> 
fun (xs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> 
          match zs with
          | Nil -> Nil
          | Cons (y: B) (ys: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) xs[3] ys[2]
  | Cons (y: ($0,$1)) (ys: list) -> Cons y (app ys)
  end) ((
fix (len: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> Nil
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys)
    end
  end) ys xs)


[yielding <<577>>] 
fix (len: list -> list -> list -> list) -> 
  fun (zs: list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> 
          match zs with
          | Nil -> Nil
          | Cons (y: B) (ys: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) xs[2] ys[2]
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (xs: list) -> 
        fun (ys: list) -> 
        match ys with
        | Nil -> $zip<$0, $1> xs zs
        | Cons (y: A) (ys: list) -> 
          match xs with
          | Nil -> 
            match zs with
            | Nil -> Nil
            | Cons (y: B) (ys: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) xs[2] ys[3]
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len zs ys[2] ys)
    end
  end


[dec-free from]
(
fix (len: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> 
          match zs with
          | Nil -> Nil
          | Cons (y: B) (ys: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) xs[2] ys[2]
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (xs: list) -> 
        fun (ys: list) -> 
        match ys with
        | Nil -> $zip<$0, $1> xs zs
        | Cons (y: A) (ys: list) -> 
          match xs with
          | Nil -> 
            match zs with
            | Nil -> Nil
            | Cons (y: B) (ys: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) xs[2] ys[3]
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys)
    end
  end) ys xs


[dec-free context]

fun (len: list -> list -> list -> list -> list) -> 
fun (ys: list) -> 
fun (xs: list) -> len ys xs ys xs


[dec-free expressed fix]

fun (ys: list) -> 
fun (xs: list) -> (
fix (len: list -> list -> list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> 
          match zs with
          | Nil -> Nil
          | Cons (y: B) (ys: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) xs[2] ys[2]
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (xs: list) -> 
        fun (ys: list) -> 
        match ys with
        | Nil -> $zip<$0, $1> xs zs
        | Cons (y: A) (ys: list) -> 
          match xs with
          | Nil -> 
            match zs with
            | Nil -> Nil
            | Cons (y: B) (ys: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) xs[2] ys[3]
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[4] xs[2] ys[2] ys)
    end
  end) ys xs ys xs


[fusing <<578>>] 
fun (ys: list) -> 
fun (xs: list) -> (
fix (len: list -> list -> list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> 
          match zs with
          | Nil -> Nil
          | Cons (y: B) (ys: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) xs[2] ys[2]
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (xs: list) -> 
        fun (ys: list) -> 
        match ys with
        | Nil -> $zip<$0, $1> xs zs
        | Cons (y: A) (ys: list) -> 
          match xs with
          | Nil -> 
            match zs with
            | Nil -> Nil
            | Cons (y: B) (ys: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) xs[2] ys[3]
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[4] xs[2] ys[2] ys)
    end
  end) ys xs ys xs


[yielding <<578>>] 
fix (len: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs zs
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> 
      match zs with
      | Nil -> Nil
      | Cons (y: B) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys)
    end
  end


[leq from]
((
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs zs
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> Nil
    | Cons (x: A) (xs: list) -> Cons (tuple x y) (app xs ys)
    end
  end) xs ys =< (
fix (len: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs zs
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> 
      match zs with
      | Nil -> Nil
      | Cons (y: B) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys)
    end
  end) ys xs)


[leq to]
(
match ys with
| Nil -> $zip<$0, $1> xs zs
| Cons (y: A) (ys: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: A) (xs: list) -> Cons (tuple x y) ((
    fun (xs: list) -> 
    fun (ys: list) -> (
    fix (len: list -> list -> list) -> 
      fun (ys: list) -> 
      fun (xs: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> 
          match zs with
          | Nil -> Nil
          | Cons (y: B) (ys: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys)
        end
      end) ys xs) xs ys)
  end
end =< (
fix (len: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs zs
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> 
      match zs with
      | Nil -> Nil
      | Cons (y: B) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys)
    end
  end) ys xs)


[dec-free from]
(
fix (len: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> 
          match zs with
          | Nil -> Nil
          | Cons (y: B) (ys: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) xs[2] ys[2]
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (xs: list) -> 
        fun (ys: list) -> 
        match ys with
        | Nil -> $zip<$0, $1> xs zs
        | Cons (y: A) (ys: list) -> 
          match xs with
          | Nil -> 
            match zs with
            | Nil -> Nil
            | Cons (y: B) (ys: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) xs[2] ys[3]
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys)
    end
  end) ys xs


[dec-free context]

fun (len: list -> list -> list -> list -> list) -> 
fun (ys: list) -> 
fun (xs: list) -> len ys xs ys xs


[dec-free expressed fix]

fun (ys: list) -> 
fun (xs: list) -> (
fix (len: list -> list -> list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> (
    fix (len: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> 
          match zs with
          | Nil -> Nil
          | Cons (y: B) (ys: list) -> Nil
          end
        | Cons (y: A) (ys: list) -> len ys ys[2]
        end
      end) xs[2] ys[2]
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> (
      fix (len: list -> list -> list) -> 
        fun (xs: list) -> 
        fun (ys: list) -> 
        match ys with
        | Nil -> $zip<$0, $1> xs zs
        | Cons (y: A) (ys: list) -> 
          match xs with
          | Nil -> 
            match zs with
            | Nil -> Nil
            | Cons (y: B) (ys: list) -> Nil
            end
          | Cons (y: A) (ys: list) -> len ys ys[2]
          end
        end) xs[2] ys[3]
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[4] xs[2] ys[2] ys)
    end
  end) ys xs ys xs


[leq from]
((
fix (len: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs zs
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> 
      match zs with
      | Nil -> Nil
      | Cons (y: B) (ys: list) -> Nil
      end
    | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) (len ys[2] ys)
    end
  end) ys xs =< (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs zs
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> Nil
    | Cons (x: A) (xs: list) -> Cons (tuple x y) (app xs ys)
    end
  end) xs ys)


[leq to]
(
match ys with
| Nil -> $zip<$0, $1> xs zs
| Cons (y: A) (ys: list) -> 
  match xs with
  | Nil -> 
    match zs with
    | Nil -> Nil
    | Cons (y: B) (ys: list) -> Nil
    end
  | Cons (y: A) (ys: list) -> Cons (tuple y y[2]) ((
    fun (ys: list) -> 
    fun (xs: list) -> (
    fix (app: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match ys with
      | Nil -> $zip<$0, $1> xs zs
      | Cons (y: A) (ys: list) -> 
        match xs with
        | Nil -> Nil
        | Cons (x: A) (xs: list) -> Cons (tuple x y) (app xs ys)
        end
      end) xs ys) ys[2] ys)
  end
end =< (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> $zip<$0, $1> xs zs
  | Cons (y: A) (ys: list) -> 
    match xs with
    | Nil -> Nil
    | Cons (x: A) (xs: list) -> Cons (tuple x y) (app xs ys)
    end
  end) xs ys)


[dec-free from]
(
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add x')
  end) n


[dec-free context]

fun (add: nat -> nat -> nat) -> 
fun (x: nat) -> add x x


[dec-free expressed fix]

fun (x: nat) -> (
fix (add: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add n x')
  end) x x


[fusing <<579>>] 
fun (x: nat) -> (
fix (add: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add n x')
  end) x x


[yielding <<579>>] $double


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[fusing <<580>>] 
fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[discovery prop (before)]

fun (ys: list) -> ((
fix<580> (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys[2] =< (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ((
fix<580> (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys[2]))


[fusing <<581>>] 
fun (c1: A -> list -> list) -> 
fun (c0: list) -> 
fun (ys: list) -> (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys[2]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys)


[yielding <<581>>] 
fix (app: (A -> list -> list) -> list -> list -> list) -> 
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) ys[2]
  | Cons (y: A) (ys: list) -> c1 y (app c1 c0 ys)
  end


[leq from]
((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys[2] =< (
fix (app: list -> list) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) ys[2]
  | Cons (y: A) (ys: list) -> c1 y (app ys)
  end) ys[2])


[leq to]
(
match ys[2] with
| Nil -> Cons y ys
| Cons (y: A) (ys: list) -> Cons y ((
  fun (xs: list) -> (
  fix (app: list -> list) -> 
    fun (ys: list) -> 
    match ys with
    | Nil -> (
      fix (fold[list]: list -> list) -> 
        fun (var_list: list) -> 
        match var_list with
        | Nil -> c0
        | Cons (a: A) (y: list) -> c1 a (fold[list] y)
        end) ys[3]
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) xs) ys)
end =< (
fix (app: list -> list) -> 
  fun (ys: list) -> 
  match ys with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) ys[2]
  | Cons (y: A) (ys: list) -> c1 y (app ys)
  end) ys[2])


[discovery prop]

fun (ys: list) -> 
match ys[2] with
| Nil -> (Cons y ys =< (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) ys)
| Cons (y: A) (ys: list) -> (Cons y ((
  fix (app: list -> list) -> 
    fun (ys: list) -> 
    match ys with
    | Nil -> (
      fix (fold[list]: list -> list) -> 
        fun (var_list: list) -> 
        match var_list with
        | Nil -> c0
        | Cons (a: A) (y: list) -> c1 a (fold[list] y)
        end) ys[3]
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) ys) =< c1 y ((
  fix (app: list -> list) -> 
    fun (ys: list) -> 
    match ys with
    | Nil -> (
      fix (fold[list]: list -> list) -> 
        fun (var_list: list) -> 
        match var_list with
        | Nil -> c0
        | Cons (a: A) (y: list) -> c1 a (fold[list] y)
        end) ys[3]
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) ys))
end


[discovery prop (before)]

fun (ys: list) -> ((
fix<580> (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys[2] =< (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ((
fix<580> (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys[2]))


[discovery prop]

fun (ys: list) -> 
match ys[2] with
| Nil -> (Cons y ys =< (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) ys)
| Cons (y: A) (ys: list) -> (Cons y ((
  fix (app: list -> list) -> 
    fun (ys: list) -> 
    match ys with
    | Nil -> (
      fix (fold[list]: list -> list) -> 
        fun (var_list: list) -> 
        match var_list with
        | Nil -> c0
        | Cons (a: A) (y: list) -> c1 a (fold[list] y)
        end) ys[3]
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) ys) =< c1 y ((
  fix (app: list -> list) -> 
    fun (ys: list) -> 
    match ys with
    | Nil -> (
      fix (fold[list]: list -> list) -> 
        fun (var_list: list) -> 
        match var_list with
        | Nil -> c0
        | Cons (a: A) (y: list) -> c1 a (fold[list] y)
        end) ys[3]
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) ys))
end


[discovery prop (before)]

fun (ys: list) -> ((
fix<580> (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys[2] =< (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ((
fix<580> (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ys[2]))


[discovery prop]

fun (ys: list) -> 
match ys[2] with
| Nil -> (Cons y ys =< (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) ys)
| Cons (y: A) (ys: list) -> (Cons y ((
  fix (app: list -> list) -> 
    fun (ys: list) -> 
    match ys with
    | Nil -> (
      fix (fold[list]: list -> list) -> 
        fun (var_list: list) -> 
        match var_list with
        | Nil -> c0
        | Cons (a: A) (y: list) -> c1 a (fold[list] y)
        end) ys[3]
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) ys) =< c1 y ((
  fix (app: list -> list) -> 
    fun (ys: list) -> 
    match ys with
    | Nil -> (
      fix (fold[list]: list -> list) -> 
        fun (var_list: list) -> 
        match var_list with
        | Nil -> c0
        | Cons (a: A) (y: list) -> c1 a (fold[list] y)
        end) ys[3]
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) ys))
end


[failing <<580>>] 
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> Cons y ((
    fix<580> (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons y ys
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) ys)
  end


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[fusing <<582>>] 
fun (xs: list) -> $length<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[3]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<582>>] 
fix (app: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> xs[2]
  | Cons (y: A) (ys: list) -> Suc (app ys)
  end


[dec-free from]
(
fix (app: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> xs[2]
  | Cons (y: A) (ys: list) -> Suc (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> nat) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> nat) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> xs[2]
  | Cons (y: A) (ys: list) -> Suc (app xs[2] ys)
  end) xs xs


[fusing <<583>>] 
fun (xs: list) -> (
fix (app: list -> list -> nat) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> xs[2]
  | Cons (y: A) (ys: list) -> Suc (app xs[2] ys)
  end) xs xs


[yielding <<583>>] 
fix (app: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: A) (ys: list) -> Suc (Suc (app ys))
  end


[fusing <<584>>] 
fun (xs: list) -> $double ($length<$0> xs)


[yielding <<584>>] 
fix (len: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: A) (ys: list) -> Suc (Suc (len ys))
  end


[fusing <<585>>] 
fun (xs: list) -> $length<$0> ($reverse<$0> xs)


[discovery prop (before)]

fun (g: list) -> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) g =< (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<$0> g))


[fusing <<586>>] 
fun (c1: list -> list) -> 
fun (c0: list) -> 
fun (g: list) -> (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<$0> g)


[yielding <<586>>] 
fix (len: (list -> list) -> list -> list -> list) -> 
  fun (c1: list -> list) -> 
  fun (c0: list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c1 (len c1 c0 ys)
  end


[leq from]
((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) g =< (
fix (len: list -> list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c1 (len ys)
  end) g)


[leq to]
(
match g with
| Nil -> Cons y Nil
| Cons (y: A) (ys: list) -> Cons y ((
  fun (xs: list) -> (
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) xs) ys)
end =< (
fix (len: list -> list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c1 (len ys)
  end) g)


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (Cons y Nil =< c0)
| Cons (y: A) (ys: list) -> (Cons y ((
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) ys) =< c1 ((
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) ys))
end


[discovery prop (before)]

fun (g: list) -> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) g =< (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<$0> g))


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (Cons y Nil =< c0)
| Cons (y: A) (ys: list) -> (Cons y ((
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) ys) =< c1 ((
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) ys))
end


[fusing <<587>>] 
fun (x0: list) -> $length<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) x0)


[yielding <<587>>] 
fix (app: list -> nat) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> Suc 0
  | Cons (y: A) (ys: list) -> Suc (app ys)
  end


[yielding <<585>>] $length<$0>


[fusing <<588>>] 
fun (xs: list) -> $reverse<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<588>>] 
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $reverse<$0> ys
  | Cons (y: A) (ys: list) -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons y Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) (app ys)
  end


[fusing <<589>>] 
fun (xs: list) -> $length<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $reverse<$0> ys
  | Cons (y: A) (ys: list) -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons y Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) (app ys)
  end) xs)


[discovery prop (before)]

fun (g: list) -> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) g =< (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<$0> g))


[fusing <<590>>] 
fun (c1: list -> list) -> 
fun (c0: list) -> 
fun (g: list) -> (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<$0> g)


[yielding <<590>>] 
fix (len: (list -> list) -> list -> list -> list) -> 
  fun (c1: list -> list) -> 
  fun (c0: list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c1 (len c1 c0 ys)
  end


[leq from]
((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) g =< (
fix (len: list -> list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c1 (len ys)
  end) g)


[leq to]
(
match g with
| Nil -> Cons y Nil
| Cons (y: A) (ys: list) -> Cons y ((
  fun (xs: list) -> (
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) xs) ys)
end =< (
fix (len: list -> list) -> 
  fun (g: list) -> 
  match g with
  | Nil -> c0
  | Cons (y: A) (ys: list) -> c1 (len ys)
  end) g)


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (Cons y Nil =< c0)
| Cons (y: A) (ys: list) -> (Cons y ((
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) ys) =< c1 ((
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) ys))
end


[discovery prop (before)]

fun (g: list) -> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) g =< (
fix (fold[nat]: nat -> list) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ($length<$0> g))


[discovery prop]

fun (g: list) -> 
match g with
| Nil -> (Cons y Nil =< c0)
| Cons (y: A) (ys: list) -> (Cons y ((
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) ys) =< c1 ((
  fix (len: list -> list) -> 
    fun (g: list) -> 
    match g with
    | Nil -> c0
    | Cons (y: A) (ys: list) -> c1 (len ys)
    end) ys))
end


[fusing <<591>>] 
fun (x0: list) -> $length<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) x0)


[yielding <<591>>] 
fix (app: list -> nat) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> Suc 0
  | Cons (y: A) (ys: list) -> Suc (app ys)
  end


[yielding <<589>>] 
fix (app: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> ys
  | Cons (y: A) (ys: list) -> Suc (app ys)
  end


[fusing <<592>>] 
fun (ys: list) -> 
fun (xs: list) -> (
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> $length<$0> ys
  | Suc (x': nat) -> Suc (add x')
  end) ($length<$0> xs)


[yielding <<592>>] 
fix (len: list -> list -> nat) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> ys
  | Cons (y: A) (ys: list) -> Suc (len ys[2] ys)
  end


[fusing <<593>>] 
fun (xs: list) -> 
fun (ys: list) -> $length<$0> ($it_rev<$0> xs ys)


[yielding <<593>>] 
fix (it_rev: list -> list -> nat) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match xs with
  | Nil -> $length<$0> ys
  | Cons (x: A) (xs': list) -> it_rev xs' (Cons x ys)
  end


[leq from]
((
fix (it_rev: list -> list -> nat) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match xs with
  | Nil -> $length<$0> ys
  | Cons (x: A) (xs': list) -> it_rev xs' (Cons x ys)
  end) xs ys =< (
fix (len: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> ys
  | Cons (y: A) (ys: list) -> Suc (len ys)
  end) xs)


[leq to]
(
match xs with
| Nil -> $length<$0> ys
| Cons (x: A) (xs': list) -> (
  fun (xs: list) -> 
  fun (ys: list) -> (
  fix (len: list -> nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> $length<$0> ys
    | Cons (y: A) (ys: list) -> Suc (len ys)
    end) xs) xs' (Cons x ys)
end =< (
fix (len: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> ys
  | Cons (y: A) (ys: list) -> Suc (len ys)
  end) xs)


[leq from]
((
fix (len: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Suc ($length<$0> ys)
  | Cons (y: A) (ys: list) -> Suc (len ys)
  end) xs' =< Suc ((
fix (len: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> ys
  | Cons (y: A) (ys: list) -> Suc (len ys)
  end) xs'))


[leq to]
(
match xs' with
| Nil -> Suc ($length<$0> ys)
| Cons (y: A) (ys: list) -> Suc ((
  fun (xs: list) -> Suc ((
  fix (len: list -> nat) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> $length<$0> ys[2]
    | Cons (y: A) (ys: list) -> Suc (len ys)
    end) xs)) ys)
end =< Suc ((
fix (len: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> ys
  | Cons (y: A) (ys: list) -> Suc (len ys)
  end) xs'))


[fusing <<594>>] 
fun (xs: list) -> $reverse<$0> ($reverse<$0> xs)


[fusing <<595>>] 
fun (x0: list) -> $reverse<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) x0)


[yielding <<595>>] 
fix (app: list -> list) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons y Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) (app ys)
  end


[yielding <<594>>] 
fix (rev: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> Cons y (rev ys)
  end


[fusing <<596>>] 
fun (ys: list) -> 
fun (xs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ($reverse<$0> xs)


[fusing <<597>>] 
fun (ys: list) -> 
fun (x0: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) x0)


[yielding <<597>>] 
fix (app: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> Cons y ys
  | Cons (y: A) (ys: list) -> Cons y (app ys[2] ys)
  end


[yielding <<596>>] 
fix (rev: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> rev (Cons y ys[2]) ys
  end


[leq from]
((
fix (rev: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> rev (Cons y ys[2]) ys
  end) ys xs =< $it_rev<$0> xs ys)


[leq to]
(
match xs with
| Nil -> ys
| Cons (y: A) (ys: list) -> (
  fun (ys: list) -> 
  fun (xs: list) -> $it_rev<$0> xs ys) (Cons y ys[2]) ys
end =< $it_rev<$0> xs ys)


[fusing <<598>>] 
fun (X0: list) -> $it_rev<$0> X0 (Cons y ys[2])


[failing <<598>>] 
fix (it_rev: list -> list) -> 
  fun (X0: list) -> 
  match X0 with
  | Nil -> Cons y ys[2]
  | Cons (x: A) (xs': list) -> (
    fix<598> (it_rev: list -> list -> list) -> 
      fun (xs: list) -> 
      fun (ys: list) -> 
      match xs with
      | Nil -> ys
      | Cons (x: A) (xs': list) -> it_rev xs' (Cons x ys)
      end) xs' (Cons x (Cons y ys[2]))
  end


[leq from]
($it_rev<$0> xs ys =< (
fix (rev: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> rev (Cons y ys[2]) ys
  end) ys xs)


[leq to]
(
match xs with
| Nil -> ys
| Cons (x: A) (xs': list) -> (
  fun (xs: list) -> 
  fun (ys: list) -> (
  fix (rev: list -> list -> list) -> 
    fun (ys: list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> ys
    | Cons (y: A) (ys: list) -> rev (Cons y ys[2]) ys
    end) ys xs) xs' (Cons x ys)
end =< (
fix (rev: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> rev (Cons y ys[2]) ys
  end) ys xs)


[fusing <<599>>] 
fun (X0: list) -> (
fix (rev: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> rev (Cons y ys[2]) ys
  end) (Cons x ys) X0


[failing <<599>>] 
fix (rev: list -> list) -> 
  fun (X0: list) -> 
  match X0 with
  | Nil -> Cons x ys
  | Cons (y: A) (ys: list) -> (
    fix<599> (rev: list -> list -> list) -> 
      fun (ys: list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> ys
      | Cons (y: A) (ys: list) -> rev (Cons y ys[2]) ys
      end) (Cons y (Cons x ys[2])) ys
  end


[dec-free from]
(
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add x')
  end) n


[dec-free context]

fun (add: nat -> nat -> nat) -> 
fun (x: nat) -> add x x


[dec-free expressed fix]

fun (x: nat) -> (
fix (add: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add n x')
  end) x x


[fusing <<600>>] 
fun (n: nat) -> $half ($double n)


[yielding <<600>>] 
fix (add: nat -> nat) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> 0
  | Suc (x': nat) -> Suc (add x')
  end


[dec-free from]
(
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> Suc n
  | Suc (x': nat) -> Suc (add x')
  end) n


[dec-free context]

fun (add: nat -> nat -> nat) -> 
fun (x: nat) -> add x x


[dec-free expressed fix]

fun (x: nat) -> (
fix (add: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> Suc n
  | Suc (x': nat) -> Suc (add n x')
  end) x x


[fusing <<601>>] 
fun (x: nat) -> (
fix (add: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> Suc n
  | Suc (x': nat) -> Suc (add n x')
  end) x x


[yielding <<601>>] 
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> Suc 0
  | Suc (x': nat) -> Suc (Suc (add x'))
  end


[dec-free from]
(
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add x')
  end) n


[dec-free context]

fun (add: nat -> nat -> nat) -> 
fun (x: nat) -> add x x


[dec-free expressed fix]

fun (x: nat) -> (
fix (add: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add n x')
  end) x x


[leq from]
((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> Suc 0
  | Suc (x': nat) -> Suc (Suc (add x'))
  end) n =< Suc ($double n))


[leq to]
(
match n with
| 0 -> Suc 0
| Suc (x': nat) -> Suc (Suc ((
  fun (x: nat) -> Suc ($double x)) x'))
end =< Suc ($double n))


[dec-free from]
(
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add x')
  end) n


[dec-free context]

fun (add: nat -> nat -> nat) -> 
fun (x: nat) -> add x x


[dec-free expressed fix]

fun (x: nat) -> (
fix (add: nat -> nat -> nat) -> 
  fun (n: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> n
  | Suc (x': nat) -> Suc (add n x')
  end) x x


[fusing <<602>>] 
fun (n: nat) -> $even ($double n)


[yielding <<602>>] 
fix (add: nat -> bool) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> True
  | Suc (x': nat) -> add x'
  end


[orig]
(
fix (add: nat -> bool) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> True
  | Suc (x': nat) -> add x'
  end) _0


[guess]
True


[guess check]
True


[fusing <<603>>] 
fun (xs: list) -> $reverse<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $reverse<$0> ys
  | Cons (y: A) (ys: list) -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons y Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) (app ys)
  end) xs)


[fusing <<604>>] 
fun (x0: list) -> $reverse<$0> ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) x0)


[yielding <<604>>] 
fix (app: list -> list) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> Cons y Nil
  | Cons (y: A) (ys: list) -> (
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Cons y Nil
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) (app ys)
  end


[yielding <<603>>] 
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end


[fusing <<605>>] 
fun (ys: list) -> 
fun (xs: list) -> (
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) ((
fix (rev: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (y: A) (ys: list) -> Cons y (rev ys)
  end) xs)


[yielding <<605>>] 
fix (rev: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (y: A) (ys: list) -> Cons y (rev ys[2] ys)
  end


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> list) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> xs[2]
  | Cons (y: A) (ys: list) -> Cons y (app xs[2] ys)
  end) xs xs


[dec-free from]
(
fix (app: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> xs[2]
  | Cons (y: A) (ys: list) -> Suc (app ys)
  end) xs


[dec-free context]

fun (app: list -> list -> nat) -> 
fun (xs: list) -> app xs xs


[dec-free expressed fix]

fun (xs: list) -> (
fix (app: list -> list -> nat) -> 
  fun (xs: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $length<$0> xs[2]
  | Cons (y: A) (ys: list) -> Suc (app xs[2] ys)
  end) xs xs


[fusing <<606>>] 
fun (xs: list) -> $even ((
fix (app: list -> nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> 0
  | Cons (y: A) (ys: list) -> Suc (Suc (app ys))
  end) xs)


[yielding <<606>>] 
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: A) (ys: list) -> app ys
  end


[orig]
(
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: A) (ys: list) -> app ys
  end) _0


[guess]
True


[guess check]
True


[fusing <<607>>] 
fun (X0: list) -> $it_rev<$0> X0 Nil


[discovery prop (before)]
((
fix<607> (it_rev: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match xs with
  | Nil -> ys
  | Cons (x: A) (xs': list) -> it_rev xs' (Cons x ys)
  end) xs' (Cons x Nil) =< (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ((
fix<607> (it_rev: list -> list -> list) -> 
  fun (xs: list) -> 
  fun (ys: list) -> 
  match xs with
  | Nil -> ys
  | Cons (x: A) (xs': list) -> it_rev xs' (Cons x ys)
  end) xs' Nil))


[fusing <<608>>] 
fun (c1: A -> list -> list) -> 
fun (c0: list) -> 
fun (xs': list) -> 
fun (x1: list) -> (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ($it_rev<$0> xs' x1)


[yielding <<608>>] 
fix (it_rev: (A -> list -> list) -> list -> list -> list -> list) -> 
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xs': list) -> 
  fun (x1: list) -> 
  match xs' with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) x1
  | Cons (x: A) (xs': list) -> it_rev c1 c0 xs' (Cons x x1)
  end


[acc-fission for]

fix (it_rev: (A -> list -> list) -> list -> list -> list -> list) -> 
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xs': list) -> 
  fun (x1: list) -> 
  match xs' with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) x1
  | Cons (x: A) (xs': list) -> it_rev c1 c0 xs' (Cons x x1)
  end


[acc-fission context]

fun (it_rev: (A -> list -> list) -> list -> list -> list -> list) -> 
fun (c1: A -> list -> list) -> 
fun (c0: list) -> 
fun (xs': list) -> 
fun (x1: list) -> it_rev c1 c0 xs' ((
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) x1)


[acc-fission substituted]

match xs' with
| Nil -> (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1
| Cons (x: A) (xs': list) -> (
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xs': list) -> 
  fun (x1: list) -> it_rev c1 c0 xs' ((
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1)) c1 c0 xs' (Cons x x1)
end


[acc-fission simplified]

match xs' with
| Nil -> (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1
| Cons (x: A) (xs': list) -> it_rev c1 c0 xs' (c1 x ((
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1))
end


[acc-fission replaced]

match xs' with
| Nil -> _inf
| Cons (x: A) (xs': list) -> it_rev c1 c0 xs' (c1 x _inf)
end


[acc-fission variable]
x1


[acc-fission result]

fun (c1: A -> list -> list) -> 
fun (c0: list) -> 
fun (xs': list) -> 
fun (x1: list) -> (
fix (it_rev: (A -> list -> list) -> list -> list -> list -> list) -> 
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xs': list) -> 
  fun (x1: list) -> 
  match xs' with
  | Nil -> x1
  | Cons (x: A) (xs': list) -> it_rev c1 c0 xs' (c1 x x1)
  end) c1 c0 xs' ((
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) x1)


[discovery prop]
($it_rev<$0> xs' (Cons x Nil) =< (
fix (it_rev: list -> list -> list) -> 
  fun (xs': list) -> 
  fun (x1: list) -> 
  match xs' with
  | Nil -> x1
  | Cons (x: A) (xs': list) -> it_rev xs' (c1 x x1)
  end) xs' c0)


[hopefully true (before)]
($it_rev<$0> xs' (Cons x Nil) =< $it_rev<$0> xs' (Cons x Nil))


[hopefully true]
tt


[yielding <<607>>] $reverse<$0>


[fusing <<609>>] 
fun (X0: list) -> $it_revflat<$0> X0 Nil


[discovery prop (before)]
((
fix<609> (it_rflat: list -> list -> list) -> 
  fun (xss: list) -> 
  fun (ys: list) -> 
  match xss with
  | Nil -> ys
  | Cons (xs: list) (xss': list) -> it_rflat xss' ((
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> ys
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs)
  end) xss' xs =< (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ((
fix<609> (it_rflat: list -> list -> list) -> 
  fun (xss: list) -> 
  fun (ys: list) -> 
  match xss with
  | Nil -> ys
  | Cons (xs: list) (xss': list) -> it_rflat xss' ((
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> ys
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs)
  end) xss' Nil))


[fusing <<610>>] 
fun (c1: A -> list -> list) -> 
fun (c0: list) -> 
fun (xss': list) -> 
fun (x1: list) -> (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ($it_revflat<$0> xss' x1)


[yielding <<610>>] 
fix (it_rflat: (A -> list -> list) -> list -> list -> list -> list) -> 
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xss': list) -> 
  fun (x1: list) -> 
  match xss' with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) x1
  | Cons (xs: list) (xss': list) -> it_rflat c1 c0 xss' ((
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> x1
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs)
  end


[acc-fission for]

fix (it_rflat: (A -> list -> list) -> list -> list -> list -> list) -> 
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xss': list) -> 
  fun (x1: list) -> 
  match xss' with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) x1
  | Cons (xs: list) (xss': list) -> it_rflat c1 c0 xss' ((
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> x1
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs)
  end


[acc-fission context]

fun (it_rflat: (A -> list -> list) -> list -> list -> list -> list) -> 
fun (c1: A -> list -> list) -> 
fun (c0: list) -> 
fun (xss': list) -> 
fun (x1: list) -> it_rflat c1 c0 xss' ((
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) x1)


[acc-fission substituted]

match xss' with
| Nil -> (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1
| Cons (xs: list) (xss': list) -> (
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xss': list) -> 
  fun (x1: list) -> it_rflat c1 c0 xss' ((
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1)) c1 c0 xss' ((
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> x1
    | Cons (y: A) (ys: list) -> Cons y (app ys)
    end) xs)
end


[acc-fission simplified]

match xss' with
| Nil -> (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1
| Cons (xs: list) (xss': list) -> it_rflat c1 c0 xss' ((
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) ((
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> x1
    | Cons (y: A) (ys: list) -> Cons y (app ys)
    end) xs))
end


[acc-fission replaced]

match xss' with
| Nil -> _inf
| Cons (xs: list) (xss': list) -> it_rflat c1 c0 xss' ((
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) ((
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> x1
    | Cons (y: A) (ys: list) -> Cons y (app ys)
    end) xs))
end


[acc-fission variable]
x1


[fusing <<611>>] 
fun (c0: list) -> 
fun (c1: A -> list -> list) -> 
fun (xs: list) -> (
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) ((
fix (app: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> x1
  | Cons (y: A) (ys: list) -> Cons y (app ys)
  end) xs)


[yielding <<611>>] 
fix (app: list -> (A -> list -> list) -> list -> list) -> 
  fun (c0: list) -> 
  fun (c1: A -> list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) x1
  | Cons (y: A) (ys: list) -> c1 y (app c0 c1 ys)
  end


[acc-fission for]

fix (it_rflat: (A -> list -> list) -> list -> list -> list -> list) -> 
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xss': list) -> 
  fun (x1: list) -> 
  match xss' with
  | Nil -> (
    fix (fold[list]: list -> list) -> 
      fun (var_list: list) -> 
      match var_list with
      | Nil -> c0
      | Cons (a: A) (y: list) -> c1 a (fold[list] y)
      end) x1
  | Cons (xs: list) (xss': list) -> it_rflat c1 c0 xss' ((
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> x1
      | Cons (y: A) (ys: list) -> Cons y (app ys)
      end) xs)
  end


[acc-fission context]

fun (it_rflat: (A -> list -> list) -> list -> list -> list -> list) -> 
fun (c1: A -> list -> list) -> 
fun (c0: list) -> 
fun (xss': list) -> 
fun (x1: list) -> it_rflat c1 c0 xss' ((
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) x1)


[acc-fission substituted]

match xss' with
| Nil -> (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1
| Cons (xs: list) (xss': list) -> (
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xss': list) -> 
  fun (x1: list) -> it_rflat c1 c0 xss' ((
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1)) c1 c0 xss' ((
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> x1
    | Cons (y: A) (ys: list) -> Cons y (app ys)
    end) xs)
end


[acc-fission simplified]

match xss' with
| Nil -> (
  fix (fold[list]: list -> list) -> 
    fun (var_list: list) -> 
    match var_list with
    | Nil -> c0
    | Cons (a: A) (y: list) -> c1 a (fold[list] y)
    end) x1
| Cons (xs: list) (xss': list) -> it_rflat c1 c0 xss' ((
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> (
      fix (fold[list]: list -> list) -> 
        fun (var_list: list) -> 
        match var_list with
        | Nil -> c0
        | Cons (a: A) (y: list) -> c1 a (fold[list] y)
        end) x1
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) xs)
end


[acc-fission replaced]

match xss' with
| Nil -> _inf
| Cons (xs: list) (xss': list) -> it_rflat c1 c0 xss' ((
  fix (app: list -> list) -> 
    fun (xs: list) -> 
    match xs with
    | Nil -> _inf
    | Cons (y: A) (ys: list) -> c1 y (app ys)
    end) xs)
end


[acc-fission variable]
x1


[acc-fission result]

fun (c1: A -> list -> list) -> 
fun (c0: list) -> 
fun (xss': list) -> 
fun (x1: list) -> (
fix (it_rflat: (A -> list -> list) -> list -> list -> list -> list) -> 
  fun (c1: A -> list -> list) -> 
  fun (c0: list) -> 
  fun (xss': list) -> 
  fun (x1: list) -> 
  match xss' with
  | Nil -> x1
  | Cons (xs: list) (xss': list) -> it_rflat c1 c0 xss' ((
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> x1
      | Cons (y: A) (ys: list) -> c1 y (app ys)
      end) xs)
  end) c1 c0 xss' ((
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> c0
  | Cons (a: A) (y: list) -> c1 a (fold[list] y)
  end) x1)


[discovery prop]
($it_revflat<$0> xss' xs =< (
fix (it_rflat: list -> list -> list) -> 
  fun (xss': list) -> 
  fun (x1: list) -> 
  match xss' with
  | Nil -> x1
  | Cons (xs: list) (xss': list) -> it_rflat xss' ((
    fix (app: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> x1
      | Cons (y: A) (ys: list) -> c1 y (app ys)
      end) xs)
  end) xss' c0)


[hopefully true (before)]
($it_revflat<$0> xss' xs =< $it_revflat<$0> xss' xs)


[hopefully true]
tt


[yielding <<609>>] $revflat<$0>


[fusing <<612>>] 
fun (ys: list) -> 
fun (xs: list) -> $it_rev<$0> ($reverse<$0> xs) ys


[fusing <<613>>] 
fun (ys: list) -> 
fun (x0: list) -> $it_rev<$0> ((
fix (fold[list]: list -> list) -> 
  fun (var_list: list) -> 
  match var_list with
  | Nil -> Cons x Nil
  | Cons (a: A) (y: list) -> Cons a (fold[list] y)
  end) x0) ys


[yielding <<613>>] 
fix (fold[list]: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (x0: list) -> 
  match x0 with
  | Nil -> Cons x ys
  | Cons (a: A) (y: list) -> fold[list] (Cons a ys) y
  end


[failing <<612>>] 
fix (it_rev: list -> list -> list) -> 
  fun (ys: list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (x: A) (xs': list) -> Cons x ((
    fix (fold[list]: list -> list -> list) -> 
      fun (ys: list) -> 
      fun (x0: list) -> 
      match x0 with
      | Nil -> ys
      | Cons (a: A) (y: list) -> fold[list] (Cons a ys) y
      end) ys ((
    fix<612> (it_rev: list -> list) -> 
      fun (X0: list) -> 
      match X0 with
      | Nil -> Nil
      | Cons (x: A) (xs': list) -> (
        fix (fold[list]: list -> list) -> 
          fun (var_list: list) -> 
          match var_list with
          | Nil -> Cons x Nil
          | Cons (a: A) (y: list) -> Cons a (fold[list] y)
          end) (it_rev xs')
      end) xs'))
  end


[fusing <<614>>] 
fun (X0: nat) -> (
fix (qmul: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (acc: nat) -> 
  match x with
  | 0 -> acc
  | Suc (x': nat) -> qmul x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> acc
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end) X0 0


[discovery prop (before)]
((
fix<614> (qmul: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (acc: nat) -> 
  match x with
  | 0 -> acc
  | Suc (x': nat) -> qmul x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> acc
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end) x' m =< (
fix (fold[nat]: nat -> nat) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ((
fix<614> (qmul: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (acc: nat) -> 
  match x with
  | 0 -> acc
  | Suc (x': nat) -> qmul x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> acc
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end) x' 0))


[fusing <<615>>] 
fun (c1: nat -> nat) -> 
fun (c0: nat) -> 
fun (x': nat) -> 
fun (x1: nat) -> (
fix (fold[nat]: nat -> nat) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ((
fix (qmul: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (acc: nat) -> 
  match x with
  | 0 -> acc
  | Suc (x': nat) -> qmul x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> acc
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end) x' x1)


[yielding <<615>>] 
fix (qmul: (nat -> nat) -> nat -> nat -> nat -> nat) -> 
  fun (c1: nat -> nat) -> 
  fun (c0: nat) -> 
  fun (x': nat) -> 
  fun (x1: nat) -> 
  match x' with
  | 0 -> (
    fix (fold[nat]: nat -> nat) -> 
      fun (var_nat: nat) -> 
      match var_nat with
      | 0 -> c0
      | Suc (y: nat) -> c1 (fold[nat] y)
      end) x1
  | Suc (x': nat) -> qmul c1 c0 x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> x1
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end


[acc-fission for]

fix (qmul: (nat -> nat) -> nat -> nat -> nat -> nat) -> 
  fun (c1: nat -> nat) -> 
  fun (c0: nat) -> 
  fun (x': nat) -> 
  fun (x1: nat) -> 
  match x' with
  | 0 -> (
    fix (fold[nat]: nat -> nat) -> 
      fun (var_nat: nat) -> 
      match var_nat with
      | 0 -> c0
      | Suc (y: nat) -> c1 (fold[nat] y)
      end) x1
  | Suc (x': nat) -> qmul c1 c0 x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> x1
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end


[acc-fission context]

fun (qmul: (nat -> nat) -> nat -> nat -> nat -> nat) -> 
fun (c1: nat -> nat) -> 
fun (c0: nat) -> 
fun (x': nat) -> 
fun (x1: nat) -> qmul c1 c0 x' ((
fix (fold[nat]: nat -> nat) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) x1)


[acc-fission substituted]

match x' with
| 0 -> (
  fix (fold[nat]: nat -> nat) -> 
    fun (var_nat: nat) -> 
    match var_nat with
    | 0 -> c0
    | Suc (y: nat) -> c1 (fold[nat] y)
    end) x1
| Suc (x': nat) -> (
  fun (c1: nat -> nat) -> 
  fun (c0: nat) -> 
  fun (x': nat) -> 
  fun (x1: nat) -> qmul c1 c0 x' ((
  fix (fold[nat]: nat -> nat) -> 
    fun (var_nat: nat) -> 
    match var_nat with
    | 0 -> c0
    | Suc (y: nat) -> c1 (fold[nat] y)
    end) x1)) c1 c0 x' ((
  fix (add: nat -> nat) -> 
    fun (x: nat) -> 
    match x with
    | 0 -> x1
    | Suc (x': nat) -> Suc (add x')
    end) m)
end


[acc-fission simplified]

match x' with
| 0 -> (
  fix (fold[nat]: nat -> nat) -> 
    fun (var_nat: nat) -> 
    match var_nat with
    | 0 -> c0
    | Suc (y: nat) -> c1 (fold[nat] y)
    end) x1
| Suc (x': nat) -> qmul c1 c0 x' ((
  fix (fold[nat]: nat -> nat) -> 
    fun (var_nat: nat) -> 
    match var_nat with
    | 0 -> c0
    | Suc (y: nat) -> c1 (fold[nat] y)
    end) ((
  fix (add: nat -> nat) -> 
    fun (x: nat) -> 
    match x with
    | 0 -> x1
    | Suc (x': nat) -> Suc (add x')
    end) m))
end


[acc-fission replaced]

match x' with
| 0 -> _inf
| Suc (x': nat) -> qmul c1 c0 x' ((
  fix (fold[nat]: nat -> nat) -> 
    fun (var_nat: nat) -> 
    match var_nat with
    | 0 -> c0
    | Suc (y: nat) -> c1 (fold[nat] y)
    end) ((
  fix (add: nat -> nat) -> 
    fun (x: nat) -> 
    match x with
    | 0 -> x1
    | Suc (x': nat) -> Suc (add x')
    end) m))
end


[acc-fission variable]
x1


[fusing <<616>>] 
fun (c0: nat) -> 
fun (c1: nat -> nat) -> 
fun (m: nat) -> (
fix (fold[nat]: nat -> nat) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) ((
fix (add: nat -> nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> x1
  | Suc (x': nat) -> Suc (add x')
  end) m)


[yielding <<616>>] 
fix (add: nat -> (nat -> nat) -> nat -> nat) -> 
  fun (c0: nat) -> 
  fun (c1: nat -> nat) -> 
  fun (m: nat) -> 
  match m with
  | 0 -> (
    fix (fold[nat]: nat -> nat) -> 
      fun (var_nat: nat) -> 
      match var_nat with
      | 0 -> c0
      | Suc (y: nat) -> c1 (fold[nat] y)
      end) x1
  | Suc (x': nat) -> c1 (add c0 c1 x')
  end


[acc-fission for]

fix (qmul: (nat -> nat) -> nat -> nat -> nat -> nat) -> 
  fun (c1: nat -> nat) -> 
  fun (c0: nat) -> 
  fun (x': nat) -> 
  fun (x1: nat) -> 
  match x' with
  | 0 -> (
    fix (fold[nat]: nat -> nat) -> 
      fun (var_nat: nat) -> 
      match var_nat with
      | 0 -> c0
      | Suc (y: nat) -> c1 (fold[nat] y)
      end) x1
  | Suc (x': nat) -> qmul c1 c0 x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> x1
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end


[acc-fission context]

fun (qmul: (nat -> nat) -> nat -> nat -> nat -> nat) -> 
fun (c1: nat -> nat) -> 
fun (c0: nat) -> 
fun (x': nat) -> 
fun (x1: nat) -> qmul c1 c0 x' ((
fix (fold[nat]: nat -> nat) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) x1)


[acc-fission substituted]

match x' with
| 0 -> (
  fix (fold[nat]: nat -> nat) -> 
    fun (var_nat: nat) -> 
    match var_nat with
    | 0 -> c0
    | Suc (y: nat) -> c1 (fold[nat] y)
    end) x1
| Suc (x': nat) -> (
  fun (c1: nat -> nat) -> 
  fun (c0: nat) -> 
  fun (x': nat) -> 
  fun (x1: nat) -> qmul c1 c0 x' ((
  fix (fold[nat]: nat -> nat) -> 
    fun (var_nat: nat) -> 
    match var_nat with
    | 0 -> c0
    | Suc (y: nat) -> c1 (fold[nat] y)
    end) x1)) c1 c0 x' ((
  fix (add: nat -> nat) -> 
    fun (x: nat) -> 
    match x with
    | 0 -> x1
    | Suc (x': nat) -> Suc (add x')
    end) m)
end


[acc-fission simplified]

match x' with
| 0 -> (
  fix (fold[nat]: nat -> nat) -> 
    fun (var_nat: nat) -> 
    match var_nat with
    | 0 -> c0
    | Suc (y: nat) -> c1 (fold[nat] y)
    end) x1
| Suc (x': nat) -> qmul c1 c0 x' ((
  fix (add: nat -> nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> (
      fix (fold[nat]: nat -> nat) -> 
        fun (var_nat: nat) -> 
        match var_nat with
        | 0 -> c0
        | Suc (y: nat) -> c1 (fold[nat] y)
        end) x1
    | Suc (x': nat) -> c1 (add x')
    end) m)
end


[acc-fission replaced]

match x' with
| 0 -> _inf
| Suc (x': nat) -> qmul c1 c0 x' ((
  fix (add: nat -> nat) -> 
    fun (m: nat) -> 
    match m with
    | 0 -> _inf
    | Suc (x': nat) -> c1 (add x')
    end) m)
end


[acc-fission variable]
x1


[acc-fission result]

fun (c1: nat -> nat) -> 
fun (c0: nat) -> 
fun (x': nat) -> 
fun (x1: nat) -> (
fix (qmul: (nat -> nat) -> nat -> nat -> nat -> nat) -> 
  fun (c1: nat -> nat) -> 
  fun (c0: nat) -> 
  fun (x': nat) -> 
  fun (x1: nat) -> 
  match x' with
  | 0 -> x1
  | Suc (x': nat) -> qmul c1 c0 x' ((
    fix (add: nat -> nat) -> 
      fun (m: nat) -> 
      match m with
      | 0 -> x1
      | Suc (x': nat) -> c1 (add x')
      end) m)
  end) c1 c0 x' ((
fix (fold[nat]: nat -> nat) -> 
  fun (var_nat: nat) -> 
  match var_nat with
  | 0 -> c0
  | Suc (y: nat) -> c1 (fold[nat] y)
  end) x1)


[discovery prop]
((
fix (qmul: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (acc: nat) -> 
  match x with
  | 0 -> acc
  | Suc (x': nat) -> qmul x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> acc
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end) x' m =< (
fix (qmul: nat -> nat -> nat) -> 
  fun (x': nat) -> 
  fun (x1: nat) -> 
  match x' with
  | 0 -> x1
  | Suc (x': nat) -> qmul x' ((
    fix (add: nat -> nat) -> 
      fun (m: nat) -> 
      match m with
      | 0 -> x1
      | Suc (x': nat) -> c1 (add x')
      end) m)
  end) x' c0)


[hopefully true (before)]
((
fix (qmul: nat -> nat -> nat) -> 
  fun (x: nat) -> 
  fun (acc: nat) -> 
  match x with
  | 0 -> acc
  | Suc (x': nat) -> qmul x' ((
    fix (add: nat -> nat) -> 
      fun (x: nat) -> 
      match x with
      | 0 -> acc
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end) x' m =< (
fix (qmul: nat -> nat -> nat) -> 
  fun (x': nat) -> 
  fun (x1: nat) -> 
  match x' with
  | 0 -> x1
  | Suc (x': nat) -> qmul x' ((
    fix (add: nat -> nat) -> 
      fun (m: nat) -> 
      match m with
      | 0 -> x1
      | Suc (x': nat) -> Suc (add x')
      end) m)
  end) x' m)


[hopefully true]
tt


[yielding <<614>>] 
fix (qmul: nat -> nat) -> 
  fun (X0: nat) -> 
  match X0 with
  | 0 -> 0
  | Suc (x': nat) -> (
    fix (fold[nat]: nat -> nat) -> 
      fun (var_nat: nat) -> 
      match var_nat with
      | 0 -> m
      | Suc (y: nat) -> Suc (fold[nat] y)
      end) (qmul x')
  end


[orig]
(
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  assert Cons (y: nat) (ys: list) <- xs in 
  if (
    fix (eq: nat -> nat -> bool) -> 
      fun (x: nat) -> 
      fun (y: nat) -> 
      match x with
      | 0 -> 
        match y with
        | 0 -> True
        | Suc (y': nat) -> False
        end
      | Suc (x': nat) -> 
        match y with
        | 0 -> False
        | Suc (y': nat) -> eq x' y'
        end
      end) _6 y
  then True
  else app ys) _1


[guess]
True


[guess check]
True


[match fix from] (
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $elem n ys
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then True
    else app ys
  end) xs

[context] [True <- $elem n xs]

[to] True


[orig]
(
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if (
      fix (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) _6 y
    then True
    else app ys
  end) _1


[guess]
True


[guess check]
True


[orig]
(
fix (app: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if (
      fix (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) _6 y
    then True
    else app ys
  end) _1


[guess]
True


[guess check]
True


[fusing <<617>>] 
fun (n: nat) -> 
fun (m: nat) -> 
fun (xs: list) -> $elem n ($drop<nat> m xs)


[yielding <<617>>] 
fix (drop: nat -> nat -> list -> bool) -> 
  fun (n: nat) -> 
  fun (m: nat) -> 
  fun (xs: list) -> 
  match m with
  | 0 -> $elem n xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> False
    | Cons (y: nat) (ys: list) -> drop n n' ys
    end
  end


[fusing <<618>>] 
fun (m: nat) -> 
fun (xs: list) -> 
assert True <- (
fix (drop: nat -> list -> bool) -> 
  fun (m: nat) -> 
  fun (xs: list) -> 
  match m with
  | 0 -> $elem n xs
  | Suc (n': nat) -> 
    match xs with
    | Nil -> False
    | Cons (y: nat) (ys: list) -> drop n' ys
    end
  end) m xs in $elem n xs


[failing <<618>>] 
fix (any: nat -> list -> bool) -> 
  fun (m: nat) -> 
  fun (xs: list) -> 
  assert True <- (
  fix (drop: nat -> list -> bool) -> 
    fun (m: nat) -> 
    fun (xs: list) -> 
    match m with
    | 0 -> $elem n xs
    | Suc (n': nat) -> 
      match xs with
      | Nil -> False
      | Cons (y: nat) (ys: list) -> drop n' ys
      end
    end) m xs in 
  match xs with
  | Nil -> False
  | Cons (y: nat) (ys: list) -> 
    if $eq n y
    then True
    else (
      fix<618> (any: list -> bool) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> False
        | Cons (y: nat) (ys: list) -> 
          if $eq n y
          then True
          else any ys
        end) ys
  end


[leq from]
($elem n xs =< True)


[leq to]
(
match xs with
| Nil -> False
| Cons (y: nat) (ys: list) -> 
  if $eq n y
  then True
  else (
    fun (xs: list) -> True) ys
end =< True)


[fusing <<619>>] 
fun (xs: list) -> 
assert True <- (
fix (subset: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then subset xs'
    else False
  end) xs in (
fix (union: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then union xs'
    else Cons x (union xs')
  end) xs


[yielding <<619>>] 
fix (union: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (x: nat) (xs': list) -> 
    assert True <- (
    fix (subset: list -> bool) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> True
      | Cons (x: nat) (xs': list) -> 
        if $elem x ys
        then subset xs'
        else False
      end) xs' in 
    assert True <- $elem x ys in union xs'
  end


[orig]
(
fix (union: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> _2
  | Cons (x: nat) (xs': list) -> 
    assert True <- (
    fix (subset: list -> bool) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> True
      | Cons (x: nat) (xs': list) -> 
        if (
          fix (any: list -> bool) -> 
            fun (xs: list) -> 
            match xs with
            | Nil -> False
            | Cons (y: nat) (ys: list) -> 
              if (
                fix (eq: nat -> nat -> bool) -> 
                  fun (x: nat) -> 
                  fun (y: nat) -> 
                  match x with
                  | 0 -> 
                    match y with
                    | 0 -> True
                    | Suc (y': nat) -> False
                    end
                  | Suc (x': nat) -> 
                    match y with
                    | 0 -> False
                    | Suc (y': nat) -> eq x' y'
                    end
                  end) x y
              then True
              else any ys
            end) _8
        then subset xs'
        else False
      end) xs' in union xs'
  end) _1


[guess]
_0


[guess check]
_0


[match fix from] (
fix (union: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then union xs'
    else Cons x (union xs')
  end) xs

[context] [True <- (
fix (subset: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then subset xs'
    else False
  end) xs]

[to] ys


[fusing <<620>>] 
fun (xs: list) -> 
assert True <- (
fix (subset: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then subset xs'
    else False
  end) xs in (
fix (inter: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then Cons x (inter xs')
    else inter xs'
  end) xs


[yielding <<620>>] 
fix (inter: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: nat) (xs': list) -> 
    assert True <- (
    fix (subset: list -> bool) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> True
      | Cons (x: nat) (xs': list) -> 
        if $elem x ys
        then subset xs'
        else False
      end) xs' in 
    assert True <- $elem x ys in Cons x (inter xs')
  end


[leq from]
((
fix (inter: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then Cons x (inter xs')
    else inter xs'
  end) xs =< xs)


[leq to]
(
match xs with
| Nil -> Nil
| Cons (x: nat) (xs': list) -> 
  if $elem x ys
  then Cons x ((
    fun (xs: list) -> xs) xs')
  else (
    fun (xs: list) -> xs) xs'
end =< xs)


[fusing <<621>>] 
fun (xs: list) -> 
assert True <- $elem n xs in (
fix (union: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then union xs'
    else Cons x (union xs')
  end) xs


[yielding <<621>>] 
fix (union: list -> list) -> 
  fun (xs: list) -> 
  assert Cons (x: nat) (xs': list) <- xs in 
  if $eq n x
  then 
    if $elem x ys
    then (
      fix<621> (union: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> ys
        | Cons (x: nat) (xs': list) -> 
          if $elem x ys
          then union xs'
          else Cons x (union xs')
        end) xs'
    else Cons x ((
      fix<621> (union: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> ys
        | Cons (x: nat) (xs': list) -> 
          if $elem x ys
          then union xs'
          else Cons x (union xs')
        end) xs')
  else 
    if $elem x ys
    then 
      assert True <- $elem n xs' in union xs'
    else 
      assert True <- $elem n xs' in Cons x (union xs')


[fusing <<622>>] 
fun (n: nat) -> 
fun (xs: list) -> $elem n ((
fix (union: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> ys
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then union xs'
    else Cons x (union xs')
  end) xs)


[fusing <<623>>] 
fun (xs: list) -> 
assert False <- $elem x[2] xs in $elem x xs


[yielding <<623>>] 
fix (any: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (y: nat) (ys: list) -> 
    if $eq x y
    then 
      assert False <- $elem x[2] ys in 
      assert False <- $eq x[2] y in True
    else 
      assert False <- $elem x[2] ys in 
      assert False <- $eq x[2] y in any ys
  end


[yielding <<622>>] 
fix (union: nat -> list -> bool) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $elem n ys
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then union n xs'
    else 
      if $eq n x
      then True
      else union n xs'
  end


[fusing <<624>>] 
fun (xs: list) -> 
assert True <- $elem n xs in (
fix (union: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $elem n ys
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then union xs'
    else 
      if $eq n x
      then True
      else union xs'
  end) xs


[yielding <<624>>] 
fix (union: list -> bool) -> 
  fun (xs: list) -> 
  assert Cons (x: nat) (xs': list) <- xs in 
  if $eq n x
  then 
    if $elem x ys
    then (
      fix<624> (union: list -> bool) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> $elem n ys
        | Cons (x: nat) (xs': list) -> 
          if $elem x ys
          then union xs'
          else 
            if $eq n x
            then True
            else union xs'
        end) xs'
    else True
  else 
    if $elem x ys
    then 
      assert True <- $elem n xs' in union xs'
    else 
      assert True <- $elem n xs' in union xs'


[leq from]
((
fix (union: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> $elem n ys
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then union xs'
    else 
      if $eq n x
      then True
      else union xs'
  end) xs =< True)


[leq to]
(
match xs with
| Nil -> $elem n ys
| Cons (x: nat) (xs': list) -> 
  if $elem x ys
  then (
    fun (xs: list) -> True) xs'
  else 
    if $eq n x
    then True
    else (
      fun (xs: list) -> True) xs'
end =< True)


[leq from]
($elem n ys =< True)


[leq to]
(
match ys with
| Nil -> False
| Cons (y: nat) (ys: list) -> 
  if $eq n y
  then True
  else (
    fun (xs: list) -> True) ys
end =< True)


[orig]
(
fix (union: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (x: nat) (xs': list) -> 
    if (
      fix (any: list -> bool) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> False
        | Cons (y: nat) (ys: list) -> 
          if (
            fix (eq: nat -> nat -> bool) -> 
              fun (x: nat) -> 
              fun (y: nat) -> 
              match x with
              | 0 -> 
                match y with
                | 0 -> True
                | Suc (y': nat) -> False
                end
              | Suc (x': nat) -> 
                match y with
                | 0 -> False
                | Suc (y': nat) -> eq x' y'
                end
              end) x y
          then True
          else any ys
        end) _4
    then union xs'
    else 
      if (
        fix (eq: nat -> nat -> bool) -> 
          fun (x: nat) -> 
          fun (y: nat) -> 
          match x with
          | 0 -> 
            match y with
            | 0 -> True
            | Suc (y': nat) -> False
            end
          | Suc (x': nat) -> 
            match y with
            | 0 -> False
            | Suc (y': nat) -> eq x' y'
            end
          end) _6 x
      then True
      else union xs'
  end) _1


[guess]
True


[guess check]
True


[fusing <<625>>] 
fun (xs: list) -> 
assert True <- $elem n xs in (
fix (inter: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then Cons x (inter xs')
    else inter xs'
  end) xs


[yielding <<625>>] 
fix (inter: list -> list) -> 
  fun (xs: list) -> 
  assert Cons (x: nat) (xs': list) <- xs in 
  if $eq n x
  then 
    if $elem x ys
    then Cons x ((
      fix<625> (inter: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> Nil
        | Cons (x: nat) (xs': list) -> 
          if $elem x ys
          then Cons x (inter xs')
          else inter xs'
        end) xs')
    else (
      fix<625> (inter: list -> list) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> Nil
        | Cons (x: nat) (xs': list) -> 
          if $elem x ys
          then Cons x (inter xs')
          else inter xs'
        end) xs'
  else 
    if $elem x ys
    then 
      assert True <- $elem n xs' in Cons x (inter xs')
    else 
      assert True <- $elem n xs' in inter xs'


[fusing <<626>>] 
fun (n: nat) -> 
fun (xs: list) -> $elem n ((
fix (inter: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Nil
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then Cons x (inter xs')
    else inter xs'
  end) xs)


[fusing <<627>>] 
fun (xs: list) -> 
assert False <- $elem x[2] xs in $elem x xs


[yielding <<627>>] 
fix (any: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (y: nat) (ys: list) -> 
    if $eq x y
    then 
      assert False <- $elem x[2] ys in 
      assert False <- $eq x[2] y in True
    else 
      assert False <- $elem x[2] ys in 
      assert False <- $eq x[2] y in any ys
  end


[yielding <<626>>] 
fix (inter: nat -> list -> bool) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then 
      if $eq n x
      then True
      else inter n xs'
    else inter n xs'
  end


[fusing <<628>>] 
fun (xs: list) -> 
assert True <- $elem n xs in (
fix (inter: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then 
      if $eq n x
      then True
      else inter xs'
    else inter xs'
  end) xs


[yielding <<628>>] 
fix (inter: list -> bool) -> 
  fun (xs: list) -> 
  assert Cons (x: nat) (xs': list) <- xs in 
  if $eq n x
  then 
    if $elem x ys
    then True
    else (
      fix<628> (inter: list -> bool) -> 
        fun (xs: list) -> 
        match xs with
        | Nil -> False
        | Cons (x: nat) (xs': list) -> 
          if $elem x ys
          then 
            if $eq n x
            then True
            else inter xs'
          else inter xs'
        end) xs'
  else 
    if $elem x ys
    then 
      assert True <- $elem n xs' in inter xs'
    else 
      assert True <- $elem n xs' in inter xs'


[leq from]
((
fix (inter: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (x: nat) (xs': list) -> 
    if $elem x ys
    then 
      if $eq n x
      then True
      else inter xs'
    else inter xs'
  end) xs =< True)


[leq to]
(
match xs with
| Nil -> False
| Cons (x: nat) (xs': list) -> 
  if $elem x ys
  then 
    if $eq n x
    then True
    else (
      fun (xs: list) -> True) xs'
  else (
    fun (xs: list) -> True) xs'
end =< True)


[fusing <<629>>] 
fun (xs: list) -> $elem n ((
fix (ins: list -> list) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> Cons n Nil
  | Cons (y: nat) (ys: list) -> 
    if $le n y
    then Cons n (Cons y ys)
    else Cons y (ins ys)
  end) xs)


[fusing <<630>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $le x y


[yielding <<630>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $le x' y' in False
    end
  | Suc (y': nat) -> 
    assert Suc (x': nat) <- x in 
    match y[2] with
    | 0 -> (
      fix<630> (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) x' y'
    | Suc (y': nat) -> 
      assert False <- $le x' y' in le x' y' y'[2]
    end
  end


[rep-arg orig]
$eq n n


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _3


[guess]
True


[guess check]
True


[fusing <<631>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $le x y[2] in $eq x y


[yielding <<631>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    match y[2] with
    | 0 -> 
      match y with
      | 0 -> True
      | Suc (y': nat) -> False
      end
    | Suc (y': nat) -> 
      match y with
      | 0 -> True
      | Suc (y': nat) -> False
      end
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in 
      assert True <- $le x' y' in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in 
      assert True <- $le x' y' in eq x' y' y'[2]
    end
  end


[rep-arg orig]
$eq n n


[rep-arg ctx]

fun (eq: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> eq x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $eq x x


[orig]
(
fix (eq: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (x': nat) -> eq x'
  end) _5


[guess]
True


[guess check]
True


[fusing <<632>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert False <- $le x y[2] in $eq x y


[yielding <<632>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  assert Suc (x': nat) <- x in 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> False
    | Suc (y': nat) -> 
      assert False <- $le x' y' in False
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> (
      fix<632> (eq: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match x with
        | 0 -> 
          match y with
          | 0 -> True
          | Suc (y': nat) -> False
          end
        | Suc (x': nat) -> 
          match y with
          | 0 -> False
          | Suc (y': nat) -> eq x' y'
          end
        end) x' y'
    | Suc (y': nat) -> 
      assert False <- $le x' y' in eq x' y' y'[2]
    end
  end


[fusing <<633>>] 
fun (x: nat) -> 
fun (y: nat) -> 
assert False <- $le x y in $eq x y


[yielding <<633>>] 
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  assert Suc (x': nat) <- x in 
  match y with
  | 0 -> False
  | Suc (y': nat) -> 
    assert False <- $le x' y' in eq x' y'
  end


[orig]
(
fix (eq: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  assert Suc (x': nat) <- x in 
  match y with
  | 0 -> False
  | Suc (y': nat) -> eq x' y'
  end) _5 _1


[guess]
False


[guess check]
False


[match fix from] $eq n y

[context] [False <- $le n y]

[to] False


[yielding <<629>>] 
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if $le n y
    then True
    else ins ys
  end


[orig]
(
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if (
      fix (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) _5 y
    then True
    else ins ys
  end) _0


[guess]
True


[guess check]
True


[fusing <<634>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (y: nat) -> 
assert True <- $eq x y[2] in $le y[2] y


[yielding <<634>>] 
fix (le: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match y with
  | 0 -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert True <- $eq x' x'[2] in False
    end
  | Suc (y': nat) -> 
    match y[2] with
    | 0 -> 
      assert 0 <- x in True
    | Suc (x': nat) -> 
      assert Suc (x': nat) <- x in 
      assert True <- $eq x' x'[2] in le x' x'[2] y'
    end
  end


[fusing <<635>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert True <- $eq x[2] y in $eq x y


[yielding <<635>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> 
      assert 0 <- x[2] in True
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in 
      assert True <- $eq x' y' in False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert 0 <- x[2] in False
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in 
      assert True <- $eq x' y' in eq x' y' x'[2]
    end
  end


[fusing <<636>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
fun (x: nat) -> 
assert True <- $le x[3] y in (
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match y with
    | 0 -> 
      assert 0 <- x[2] in True
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert 0 <- x[2] in False
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in eq x' y' x'[2]
    end
  end) x[2] x[3] x


[yielding <<636>>] 
fix (eq: nat -> nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> 
    match x[3] with
    | 0 -> 
      match y with
      | 0 -> 
        assert 0 <- x[2] in True
      | Suc (y': nat) -> 
        assert 0 <- x[2] in True
      end
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in 
      assert Suc (y': nat) <- y in 
      assert True <- $le y'[2] y' in False
    end
  | Suc (x': nat) -> 
    match x[3] with
    | 0 -> 
      match y with
      | 0 -> 
        assert 0 <- x[2] in False
      | Suc (y': nat) -> 
        assert 0 <- x[2] in False
      end
    | Suc (y': nat) -> 
      assert Suc (x': nat) <- x[2] in 
      assert Suc (y': nat) <- y in 
      assert True <- $le y'[2] y' in eq y'[2] y' x' x'[2]
    end
  end


[fusing <<637>>] 
fun (x: nat) -> 
fun (y: nat) -> 
fun (x: nat) -> 
assert False <- $le x[2] y in (
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> 
    assert 0 <- y[2] in 
    match y with
    | 0 -> True
    | Suc (y': nat) -> False
    end
  | Suc (x': nat) -> 
    match y with
    | 0 -> 
      assert Suc (y': nat) <- y[2] in False
    | Suc (y': nat) -> 
      assert Suc (y': nat) <- y[2] in eq x' y' y'[2]
    end
  end) x x[2] y


[yielding <<637>>] 
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  assert Suc (x': nat) <- x in 
  match y with
  | 0 -> 
    assert Suc (x': nat) <- x[2] in False
  | Suc (y': nat) -> 
    assert Suc (y': nat) <- x[2] in 
    assert False <- $le y' y'[2] in eq y' y'[2] x'
  end


[orig]
(
fix (eq: nat -> nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  fun (x: nat) -> 
  assert Suc (x': nat) <- x in 
  match y with
  | 0 -> False
  | Suc (y': nat) -> 
    assert Suc (y': nat) <- x[2] in eq y' y'[2] x'
  end) _5 _1 _6


[guess]
False


[guess check]
False


[match fix from] $eq n y

[context] [True <- $eq n m, False <- $le m y]

[to] False


[orig]
(
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> True
  | Cons (y: nat) (ys: list) -> 
    if (
      fix (le: nat -> nat -> bool) -> 
        fun (x: nat) -> 
        fun (y: nat) -> 
        match y with
        | 0 -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> False
          end
        | Suc (y': nat) -> 
          match x with
          | 0 -> True
          | Suc (x': nat) -> le x' y'
          end
        end) _5 y
    then True
    else ins ys
  end) _0


[guess]
True


[guess check]
True


[leq from]
((
fix (ins: list -> bool) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (y: nat) (ys: list) -> 
    if $le m y
    then 
      if $eq n y
      then True
      else $elem n ys
    else 
      if $eq n y
      then True
      else ins ys
  end) xs =< $elem n xs)


[leq to]
(
match xs with
| Nil -> False
| Cons (y: nat) (ys: list) -> 
  if $le m y
  then 
    if $eq n y
    then True
    else $elem n ys
  else 
    if $eq n y
    then True
    else (
      fun (xs: list) -> $elem n xs) ys
end =< $elem n xs)


[fusing <<638>>] 
fun (n: nat) -> 
fun (xs: list) -> $elem n ($insertsort xs)


[failing <<638>>] 
fix (isort: nat -> list -> bool) -> 
  fun (n: nat) -> 
  fun (xs: list) -> 
  match xs with
  | Nil -> False
  | Cons (y: nat) (ys: list) -> (
    fix (ins: list -> bool) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> $eq n y
      | Cons (y: nat) (ys: list) -> 
        if $le y[2] y
        then 
          if $eq n y[2]
          then True
          else 
            if $eq n y
            then True
            else $elem n ys
        else 
          if $eq n y
          then True
          else ins ys
      end) ((
    fix<638> (isort: list -> list) -> 
      fun (xs: list) -> 
      match xs with
      | Nil -> Nil
      | Cons (y: nat) (ys: list) -> (
        fix (ins: list -> list) -> 
          fun (xs: list) -> 
          match xs with
          | Nil -> Cons y Nil
          | Cons (y: nat) (ys: list) -> 
            if $le y[2] y
            then Cons y[2] (Cons y ys)
            else Cons y (ins ys)
          end) (isort ys)
      end) ys)
  end


[leq from]
($elem n xs =< True)


[leq to]
(
match xs with
| Nil -> False
| Cons (y: nat) (ys: list) -> 
  if $eq n y
  then True
  else (
    fun (xs: list) -> True) ys
end =< True)


[fusing <<639>>] 
fun (f: A -> B) -> $map<$0, $0> f (
fix (repeat: list) -> Cons x repeat)


[yielding <<639>>] 
fix (repeat: (A -> B) -> list) -> 
  fun (f: A -> B) -> Cons (f x) (repeat f)


[fusing <<640>>] 
fun (x: A) -> $map<$0, $0> f ((
fix (iter: A -> list) -> 
  fun (x: A) -> Cons x (iter (f x))) x)


[yielding <<640>>] 
fix (iter: A -> list) -> 
  fun (x: A) -> Cons (f x) (iter (f x))


[leq from]
((
fix (iter: A -> list) -> 
  fun (x: A) -> Cons (f x) (iter (f x))) x =< (
fix (iter: A -> list) -> 
  fun (x: A) -> Cons x (iter (f x))) (f x))


[leq to]
(Cons (f x) ((
fun (x: A) -> (
fix (iter: A -> list) -> 
  fun (x: A) -> Cons x (iter (f x))) (f x)) (f x)) =< (
fix (iter: A -> list) -> 
  fun (x: A) -> Cons x (iter (f x))) (f x))


[fusing <<641>>] 
fun (p: A -> bool) -> $filter<$0> p (
fix (repeat: list) -> Cons x repeat)


[yielding <<641>>] 
fix (repeat: (A -> bool) -> list) -> 
  fun (p: A -> bool) -> 
  if p x
  then Cons x (repeat p)
  else repeat p


[leq from]
(
fix (repeat: list) -> 
  if p x
  then Cons x repeat
  else repeat =< 
fix (repeat: list) -> Cons x repeat)


[leq to]
(
if p x
then Cons x (
  fix (repeat: list) -> Cons x repeat)
else 
  fix (repeat: list) -> Cons x repeat =< 
fix (repeat: list) -> Cons x repeat)


[fusing <<642>>] 
fun (n: nat) -> $drop<$0> n (
fix (repeat: list) -> Cons x repeat)


[yielding <<642>>] 
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons x (
    fix<642> (repeat: list) -> Cons x repeat)
  | Suc (n': nat) -> repeat n'
  end


[orig]
(
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons _2 (
    fix (repeat: list) -> Cons _3 repeat)
  | Suc (n': nat) -> repeat n'
  end) _1


[guess]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[guess check]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[orig]
(
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons _2 (
    fix (repeat: list) -> Cons _3 repeat)
  | Suc (n': nat) -> repeat n'
  end) _1


[guess]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[guess check]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[leq from]
(
fix (repeat: list) -> Cons x repeat =< (
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons x (
    fix (repeat: list) -> Cons x repeat)
  | Suc (n': nat) -> repeat n'
  end) n)


[leq to]
(Cons x ((
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons x (
    fix (repeat: list) -> Cons x repeat)
  | Suc (n': nat) -> repeat n'
  end) n) =< (
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons x (
    fix (repeat: list) -> Cons x repeat)
  | Suc (n': nat) -> repeat n'
  end) n)


[orig]
(
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons _2 (
    fix (repeat: list) -> Cons _3 repeat)
  | Suc (n': nat) -> repeat n'
  end) _1


[guess]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[guess check]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[orig]
(
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons _2 (
    fix (repeat: list) -> Cons _3 repeat)
  | Suc (n': nat) -> repeat n'
  end) _1


[guess]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[guess check]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[orig]
(
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons _2 (
    fix (repeat: list) -> Cons _3 repeat)
  | Suc (n': nat) -> repeat n'
  end) _1


[guess]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[guess check]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[orig]
(
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons _2 (
    fix (repeat: list) -> Cons _3 repeat)
  | Suc (n': nat) -> repeat n'
  end) _1


[guess]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[guess check]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[orig]
(
fix (repeat: nat -> list) -> 
  fun (n: nat) -> 
  match n with
  | 0 -> Cons _2 (
    fix (repeat: list) -> Cons _3 repeat)
  | Suc (n': nat) -> repeat n'
  end) _1


[guess]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[guess check]
Cons _0 (
fix (repeat: list) -> Cons _1 repeat)


[fusing <<643>>] 
fun (x: A) -> $butlast<$0> ((
fix (iter: A -> list) -> 
  fun (x: A) -> Cons x (iter (f x))) x)


[yielding <<643>>] 
fix (iter: A -> list) -> 
  fun (x: A) -> Cons x (iter (f x))


[fusing <<644>>] 
fun (x: A) -> $last<$0> ((
fix (iter: A -> list) -> 
  fun (x: A) -> Cons x (iter (f x))) x)


[yielding <<644>>] 
fix (iter: A -> A) -> 
  fun (x: A) -> iter (f x)


[leq from]
((
fix (iter: A -> A) -> 
  fun (x: A) -> iter (f x)) x =< _|_)


[leq to]
((
fun (x: A) -> _|_) (f x) =< _|_)


[fusing <<645>>] $is_sorted (
fix (repeat: list) -> Cons n repeat)


[rep-arg orig]
$le n n


[rep-arg ctx]

fun (le: nat -> nat -> bool) -> 
fun (x: nat) -> 
fun (y: nat) -> le x x


[rep-arg full]

fun (x: nat) -> 
fun (y: nat) -> $le x x


[fusing <<646>>] 
fun (x: nat) -> 
fun (y: nat) -> $le x x


[yielding <<646>>] 
fix (le: nat -> nat -> bool) -> 
  fun (x: nat) -> 
  fun (y: nat) -> 
  match x with
  | 0 -> True
  | Suc (y': nat) -> le y' _|_
  end


[orig]
(
fix (le: nat -> bool) -> 
  fun (x: nat) -> 
  match x with
  | 0 -> True
  | Suc (y': nat) -> le y'
  end) _1


[guess]
True


[guess check]
True


[yielding <<645>>] 
fix (repeat: bool) -> repeat


[leq from]
(
fix (repeat: bool) -> repeat =< _|_)


[leq to]
(_|_ =< _|_)
106  Tried: 0  Errors: 0  Failures: 0Cases: 106  Tried: 1  Errors: 0  Failures: 0Cases: 106  Tried: 2  Errors: 0  Failures: 0Cases: 106  Tried: 3  Errors: 0  Failures: 0Cases: 106  Tried: 4  Errors: 0  Failures: 0Cases: 106  Tried: 5  Errors: 0  Failures: 0Cases: 106  Tried: 6  Errors: 0  Failures: 0Cases: 106  Tried: 7  Errors: 0  Failures: 0Cases: 106  Tried: 8  Errors: 0  Failures: 0Cases: 106  Tried: 9  Errors: 0  Failures: 0Cases: 106  Tried: 10  Errors: 0  Failures: 0Cases: 106  Tried: 11  Errors: 0  Failures: 0Cases: 106  Tried: 12  Errors: 0  Failures: 0Cases: 106  Tried: 13  Errors: 0  Failures: 0Cases: 106  Tried: 14  Errors: 0  Failures: 0Cases: 106  Tried: 15  Errors: 0  Failures: 0Cases: 106  Tried: 16  Errors: 0  Failures: 0Cases: 106  Tried: 17  Errors: 0  Failures: 0Cases: 106  Tried: 18  Errors: 0  Failures: 0Cases: 106  Tried: 19  Errors: 0  Failures: 0Cases: 106  Tried: 20  Errors: 0  Failures: 0Cases: 106  Tried: 21  Errors: 0  Failures: 0Cases: 106  Tried: 22  Errors: 0  Failures: 0Cases: 106  Tried: 23  Errors: 0  Failures: 0Cases: 106  Tried: 24  Errors: 0  Failures: 0Cases: 106  Tried: 25  Errors: 0  Failures: 0Cases: 106  Tried: 26  Errors: 0  Failures: 0Cases: 106  Tried: 27  Errors: 0  Failures: 0Cases: 106  Tried: 28  Errors: 0  Failures: 0Cases: 106  Tried: 29  Errors: 0  Failures: 0Cases: 106  Tried: 30  Errors: 0  Failures: 0Cases: 106  Tried: 31  Errors: 0  Failures: 0Cases: 106  Tried: 32  Errors: 0  Failures: 0Cases: 106  Tried: 33  Errors: 0  Failures: 0Cases: 106  Tried: 34  Errors: 0  Failures: 0Cases: 106  Tried: 35  Errors: 0  Failures: 0Cases: 106  Tried: 36  Errors: 0  Failures: 0Cases: 106  Tried: 37  Errors: 0  Failures: 0Cases: 106  Tried: 38  Errors: 0  Failures: 0Cases: 106  Tried: 39  Errors: 0  Failures: 0Cases: 106  Tried: 40  Errors: 0  Failures: 0Cases: 106  Tried: 41  Errors: 0  Failures: 0Cases: 106  Tried: 42  Errors: 0  Failures: 0Cases: 106  Tried: 43  Errors: 0  Failures: 0Cases: 106  Tried: 44  Errors: 0  Failures: 0Cases: 106  Tried: 45  Errors: 0  Failures: 0Cases: 106  Tried: 46  Errors: 0  Failures: 0Cases: 106  Tried: 47  Errors: 0  Failures: 0Cases: 106  Tried: 48  Errors: 0  Failures: 0Cases: 106  Tried: 49  Errors: 0  Failures: 0Cases: 106  Tried: 50  Errors: 0  Failures: 0Cases: 106  Tried: 51  Errors: 0  Failures: 0Cases: 106  Tried: 52  Errors: 0  Failures: 0Cases: 106  Tried: 53  Errors: 0  Failures: 0Cases: 106  Tried: 54  Errors: 0  Failures: 0Cases: 106  Tried: 55  Errors: 0  Failures: 0Cases: 106  Tried: 56  Errors: 0  Failures: 0Cases: 106  Tried: 57  Errors: 0  Failures: 0Cases: 106  Tried: 58  Errors: 0  Failures: 0Cases: 106  Tried: 59  Errors: 0  Failures: 0Cases: 106  Tried: 60  Errors: 0  Failures: 0Cases: 106  Tried: 61  Errors: 0  Failures: 0Cases: 106  Tried: 62  Errors: 0  Failures: 0Cases: 106  Tried: 63  Errors: 0  Failures: 0Cases: 106  Tried: 64  Errors: 0  Failures: 0Cases: 106  Tried: 65  Errors: 0  Failures: 0Cases: 106  Tried: 66  Errors: 0  Failures: 0Cases: 106  Tried: 67  Errors: 0  Failures: 0Cases: 106  Tried: 68  Errors: 0  Failures: 0Cases: 106  Tried: 69  Errors: 0  Failures: 0Cases: 106  Tried: 70  Errors: 0  Failures: 0Cases: 106  Tried: 71  Errors: 0  Failures: 0Cases: 106  Tried: 72  Errors: 0  Failures: 0Cases: 106  Tried: 73  Errors: 0  Failures: 0Cases: 106  Tried: 74  Errors: 0  Failures: 0Cases: 106  Tried: 75  Errors: 0  Failures: 0Cases: 106  Tried: 76  Errors: 0  Failures: 0Cases: 106  Tried: 77  Errors: 0  Failures: 0Cases: 106  Tried: 78  Errors: 0  Failures: 0Cases: 106  Tried: 79  Errors: 0  Failures: 0Cases: 106  Tried: 80  Errors: 0  Failures: 0Cases: 106  Tried: 81  Errors: 0  Failures: 0Cases: 106  Tried: 82  Errors: 0  Failures: 0Cases: 106  Tried: 83  Errors: 0  Failures: 0Cases: 106  Tried: 84  Errors: 0  Failures: 0Cases: 106  Tried: 85  Errors: 0  Failures: 0Cases: 106  Tried: 86  Errors: 0  Failures: 0Cases: 106  Tried: 87  Errors: 0  Failures: 0Cases: 106  Tried: 88  Errors: 0  Failures: 0Cases: 106  Tried: 89  Errors: 0  Failures: 0Cases: 106  Tried: 90  Errors: 0  Failures: 0Cases: 106  Tried: 91  Errors: 0  Failures: 0Cases: 106  Tried: 92  Errors: 0  Failures: 0Cases: 106  Tried: 93  Errors: 0  Failures: 0Cases: 106  Tried: 94  Errors: 0  Failures: 0Cases: 106  Tried: 95  Errors: 0  Failures: 0Cases: 106  Tried: 96  Errors: 0  Failures: 0Cases: 106  Tried: 97  Errors: 0  Failures: 0Cases: 106  Tried: 98  Errors: 0  Failures: 0Cases: 106  Tried: 99  Errors: 0  Failures: 0Cases: 106  Tried: 100  Errors: 0  Failures: 0Cases: 106  Tried: 101  Errors: 0  Failures: 0Cases: 106  Tried: 102  Errors: 0  Failures: 0Cases: 106  Tried: 103  Errors: 0  Failures: 0Cases: 106  Tried: 104  Errors: 0  Failures: 0Cases: 106  Tried: 105  Errors: 0  Failures: 0                                              Cases: 106  Tried: 106  Errors: 0  Failures: 0

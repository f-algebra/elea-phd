
prop "1+1=2": 
  add 1 1 = 2

prop "2*2=2+2":
  mul 2 2 = add 2 2

prop "1<=2": 
  leq_nat 1 2
 
prop "not-not": forall (p: bool) ->
  not (not p) = p
   
  /*
  This one no longer applies
prop "expand-rev"<A>: forall (xs: list<A>) (x: A) ->
  reverse<A> (Cons<A> x xs) = append<A> (reverse<A> xs) (Cons<A> x Nil<A>)
  */
  
let append3<A> =
  fix (app3: list<A> -> list<A> -> list<A> -> list<A>) ->
    fun (xs: list<A>) (ys: list<A>) (zs: list<A>) ->
    match xs with
    | Nil -> append<A> ys zs
    | Cons x xs' -> Cons<A> x (app3 xs' ys zs)
    end
    
prop "append3-simp"<A>: forall (xs ys zs: list<A>) ->
  append3<A> xs ys zs = append<A> xs (append<A> ys zs) 
    
  
let dneppa<A> = 
  fix (ppa: list<A> -> list<A> -> list<A>) (zs xs: list<A>) ->
    match xs with
    | Nil -> zs
    | Cons y ys -> Cons<A> y (ppa zs ys)
    end
   
prop "non-rec first arg"<A>: forall (xs ys: list<A>) ->
  dneppa<A> ys xs = append<A> xs ys
    
  
let always_true = 
  fix (true: nat -> nat -> bool) (x y: nat) ->
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> True
      | Suc y' -> true x' y'
      end
    end

prop "always true": forall (n m: nat) ->
  always_true n m
 
prop "constant fix 1": forall (n m x: nat) ->
  (fix (f: nat -> bool) (x: nat) ->
  match x with
  | 0 -> eq_nat n m
  | Suc x' -> f x'
  end) x 
  = eq_nat n m
  
prop "constant fix 2": forall (xs: list<nat>) ->
  (fix (f: list<nat> -> bool) (xs: list<nat>) ->
  match xs with
  | Nil -> True
  | Cons y ys ->
    or (f ys) (eq_nat 1 y)
  end) xs
 
prop "id nat":
  (fun (n: nat) -> n)
  = 
  (fix (id: nat -> nat) (n: nat) -> 
    match n with | 0 -> 0 | Suc n' -> Suc (id n') end)

  /*
let is_sorted2 = 
  fix (srtd: list<nat> -> bool) (xs: list<nat>) ->
    match xs with
    | Nil -> True
    | Cons y ys ->
      match ys with
      | Nil -> srtd Nil<nat>
      | Cons z zs -> and (leq_nat y z) (srtd ys)
      end
    end
    

prop "unfold within fix": forall (xs: list<nat>) ->
  is_sorted xs = is_sorted2 xs
    */
  /*
  
prop "propagate match 1": forall (xs: list<nat>) (x y: nat) ->
  match is_sorted xs with
  | True -> True
  | False -> not (is_sorted xs)
  end
  


prop "unfold productive fix": forall (xs: list<nat>) ->
  (match append<nat> xs (Cons<nat> 1 Nil<nat>) with
   | Nil -> 0 | Cons y ys -> y end)
  =
  (match xs with
   | Nil -> 1 | Cons y ys -> y end)
   
prop "unfold branching fix"<A>: forall (t: tree<A>) ->
  (match flatten<A> t with
   | Nil -> 0 | Cons y ys -> 1 end)
  = 
  (match t with
   | Leaf -> 0 | Node t1 x t2 -> 1 end)
   
prop "unfold branching fix 2": forall (t: tree<nat>) (n: nat) ->
  (match tree_insert n t with
    | Leaf -> 1
    | Node t1 x t2 -> 2 
    end) = 2
  */
   /*
let super_loopy = fun (t: tree<nat>) (n: nat) ->
  match t with
  | Leaf -> False
  | Node ta m tb -> 
    match ta with
    | Leaf -> False
    | Node taa m tab ->
      match tb with
      | Leaf -> False
      | Node tba m tbb -> 
        match rightmost_leq t n with
        | False -> False
        | True -> sorted_tree t
        end
      end
    end
  end
   
prop "loopy mc looperson": forall (t: tree<nat>) (n: nat) ->
  super_loopy t n = super_loopy t n
  */


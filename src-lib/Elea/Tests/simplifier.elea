
prop "1+1=2": 
  add 1 1 = 2

prop "2*2=2+2":
  mul 2 2 = add 2 2

prop "1<=2": 
  leq_nat 1 2
  
prop "not-not": forall (p: bool) ->
  not (not p) = p
  
prop "expand-rev": forall (xs: nlist) (x: nat) ->
  reverse (Cons x xs) = append (reverse xs) (Cons x Nil)
  
  
let append3 =
  fix (app3: nlist -> nlist -> nlist -> nlist) ->
    fun (xs: nlist) (ys: nlist) (zs: nlist) ->
    match xs with
    | Nil -> append ys zs
    | Cons x xs' -> Cons x (app3 xs' ys zs)
    end
    
prop "append3-simp": forall (xs: nlist) (ys: nlist) (zs: nlist) ->
  append3 xs ys zs = append xs (append ys zs) 
    
  
let dneppa = 
  fix (ppa: nlist -> nlist -> nlist) (zs: nlist) (xs: nlist) ->
    match xs with
    | Nil -> zs
    | Cons y ys -> Cons y (ppa zs ys)
    end
   
prop "non-rec first arg": forall (xs: nlist) (ys: nlist) ->
  dneppa ys xs = append xs ys
    
  
let always_true = 
  fix (true: nat -> nat -> bool) (x y: nat) ->
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> True
      | Suc y' -> true x' y'
      end
    end

prop "always true": forall (n m: nat) ->
  always_true n m
 

let is_sorted2 = 
  fix (srtd: nlist -> bool) (xs: nlist) ->
    match xs with
    | Nil -> True
    | Cons y ys ->
      match ys with
      | Nil -> srtd Nil
      | Cons z zs -> and (leq_nat y z) (srtd ys)
      end
    end
  
prop "unfold within fix": forall (xs: nlist) ->
  is_sorted xs = is_sorted2 xs


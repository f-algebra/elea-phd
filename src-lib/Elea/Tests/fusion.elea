
prop "add 0": forall (n: nat) -> add n 0 = n

prop "add associative": forall (x y z: nat) -> 
  add (add x y) z = add x (add y z)
    /*
prop "add commutative": forall (x y z: nat) ->
  eq_nat (add x y) (add y x)
*/
prop "append associative": forall (xs ys zs: nlist) ->
  append (append xs ys) zs = append xs (append ys zs)
    
let revapp = 
  fix (rap: nat -> nlist -> nlist) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> Cons n Nil
    | Cons y ys -> append (rap n ys) (Cons y Nil)
    end
    
prop "revapp def": forall (n: nat) (xs: nlist) ->
  reverse (append xs (Cons n Nil)) = revapp n xs

prop "revapp cons": forall (n: nat) (xs: nlist) ->
  revapp n xs = Cons n (reverse xs)
  
prop "revrev": forall (xs: nlist) ->
  xs = reverse (reverse xs)

  
prop "count reverse": forall (n: nat) (xs: nlist) ->
  count n (reverse xs) = count n xs
  
prop "count append": forall (n: nat) (xs ys: nlist) ->
  count n (append xs ys) = add (count n xs) (count n ys)

prop "count snoc": forall (n: nat) (xs: nlist) ->
  count n (append xs (Cons n Nil)) = Suc (count n xs)
  
  
prop "eq_nat reflexive": forall (n: nat) -> 
  eq_nat n n
  
prop "leq_nat reflexive": forall (n: nat) ->
  leq_nat n n
  
prop "eq_nat symmetric": forall (n m: nat) ->
  implies (eq_nat n m) (eq_nat m n)
  
prop "eq_nat transitive": forall (i j k: nat) ->
  implies (and (eq_nat i j) (eq_nat j k)) (eq_nat i k)
  
prop "leq_nat transitive": forall (i j k: nat) ->
  implies (and (leq_nat i j) (leq_nat j k)) (leq_nat i k)
  
prop "leq_nat total": forall (n m: nat) ->
  implies (not (leq_nat n m)) (leq_nat m n)
  
  /*
prop "drop take": forall (n: nat) (xs: nlist) ->
  xs = append (take n xs) (drop n xs)
  */
  
prop "filter reverse": forall (p: nat -> bool) (xs: nlist) ->
  filter p (reverse xs) = reverse (filter p xs)

prop "insertsort sorted": forall (xs: nlist) ->
  is_sorted (insertsort xs)

  /*
let sorted_tree = 
  fix (srtd: ntree -> bool) (t: ntree) ->
  match t with
  | Leaf -> True
  | Node t1 x t2 -> 
    match flatten t2 with
    | Nil -> 
  */
  /*
let rightmost_leq = 
  fix (leq: nat -> nlist -> bool) (n: nat) (xs: nlist) ->
  match xs with
  | Nil -> True
  | Cons x xs ->
    match xs with
    | Nil -> leq_nat x n
    | Cons y ys -> leq n xs
    end
  end
  
prop "main": forall (y: nat) (t: ntree) (xs: nlist) ->
  rightmost_leq y (flatten t)
 */

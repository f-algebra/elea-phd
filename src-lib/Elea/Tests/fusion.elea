
prop "add 0" (n: nat) ->
  add n 0 =< n
  
prop "add associative" (x y z: nat) -> 
  add (add x y) z =< add x (add y z)

prop "add double" (x: nat) ->
  add x x =< double x
  
prop "append nil"<A> (xs: list<A>) ->
  append<A> xs Nil<A> =< xs
  
prop "append associative"<A> (xs ys zs: list<A>) ->
  append<A> (append<A> xs ys) zs =< append<A> xs (append<A> ys zs)
  
let revapp<A> = 
  fix (rap: A -> list<A> -> list<A>) (n: A) (xs: list<A>) ->
    match xs with
    | Nil -> Cons<A> n Nil<A>
    | Cons y ys -> append<A> (rap n ys) (Cons<A> y Nil<A>)
    end
    
prop "revapp def"<A> (n: A) (xs: list<A>) ->
  reverse<A> (append<A> xs (Cons<A> n Nil<A>)) =< revapp<A> n xs
 
prop "revapp cons"<A> (n: A) (xs: list<A>) ->
  reverse<A> (append<A> xs (Cons<A> n Nil<A>)) =< Cons<A> n (reverse<A> xs)
 
prop "revrev"<A> (xs: list<A>) ->
  reverse<A> (reverse<A> xs) =< xs

prop "eq reflexive" (n: nat) -> 
  eq n n =< True
  
let eq3 = 
  fix (eq3: nat -> nat -> nat -> bool) (x y z: nat) ->
  match x with
  | 0 -> and (eq y 0) (eq z 0)
  | Suc x ->
    match y with
    | 0 -> False
    | Suc y -> 
      match z with
      | 0 -> False
      | Suc z -> eq3 x y z
      end
    end
  end

prop "eq3" (x: nat) ->
  eq3 x x x =< True
  
prop "eq3 1" (x y: nat) ->
  eq3 x x y =< eq x y
  
prop "eq3 2" (x y: nat) -> 
  eq3 x y y =< eq x y

prop "le reflexive" (n: nat) ->
  le n n =< True
  
prop "drop add"<A> (n m: nat) (xs: list<A>) ->
  drop<A> m (drop<A> n xs) =< drop<A> (add n m) xs
  
prop "drop take"<A> (n: nat) (xs: list<A>) ->
  append<A> (take<A> n xs) (drop<A> n xs) =< xs
 
prop "count append" (n: nat) (xs ys: list<nat>) ->
  count n (append<nat> xs ys) =< add (count n xs) (count n ys)
 
prop "count snoc" (n: nat) (xs: list<nat>) ->
  count n (append<nat> xs (Cons<nat> n Nil<nat>)) =< Suc (count n xs)
  /*
prop "count reverse": forall (n: nat) (xs: list<nat>) ->
  count n xs = count n (reverse<nat> xs)
  */
  
prop "eq symmetric" (n m: nat) ->
  implies (eq n m) (eq m n) =< True
  
prop "le total" (n m: nat) ->
  implies (not (le n m)) (le m n) =< True
 
prop "eq transitive" (i j k: nat) ->
  implies (and (eq i j) (eq j k)) (eq i k) =< True
  
prop "le transitive" (i j k: nat) ->
  implies (and (le i j) (le j k)) (le i k) =< True
  
prop "sorted" (xs: list<nat>) ->
  is_sorted (insertsort xs)
  
prop "len filter" <A> (p: A -> bool) (xs: list<A>) ->
  le (length<A> (filter<A> p xs)) (length<A> xs)
  
// leq gen problem
// prop "le add" (n m: nat) ->
//   le n (add m n)
  
prop "drop take" <A> (n m: nat) (xs: list<A>) ->
  drop<A> m (take<A> (add n m) xs)
  == take<A> n (drop<A> m xs) 

 /*
prop "insertsort sorted": forall (xs: list<nat>) (n: nat) ->
  implies (is_sorted xs) (is_sorted (insert n xs))
 */
  /*
let half_fused_eq = 
  fix (hfeq: nat -> nat -> nat -> bool) (x y z: nat) ->
  match y with
  | 0 ->
    assert 0 <- x in
      (match z with
      | 0 -> True
      | Suc z' -> False
      end)
  | Suc y' ->
    assert Suc x' <- x in
    (assert True <- eq x' y' in
      (match z with
      | 0 -> False
      | Suc z' -> hfeq x' y' z'
      end))
  end
  
prop "half fused eq" : forall (i j k: nat) ->
  implies (eq k i) (half_fused_eq i j k)
 */ 
/*
prop "id list"<A>:  
  (fun (n: nat) (xs: list<A>) -> xs)
  =
  (fix (id: nat -> list<A> -> list<A>) (n: nat) (xs: list<A>) ->
    match n with
    | 0 -> xs
    | Suc n' -> 
      match xs with
      | Nil -> Nil<A>
      | Cons y ys -> Cons<A> y (id n' ys)
      end
    end)

  
  
  
prop "filter reverse"<A>: forall (p: A -> bool) (xs: list<A>) ->
  reverse<A> (filter<A> p xs) = filter<A> p (reverse<A> xs)

  */
/*  
prop "take append"<A>: forall (n: nat) (xs ys: list<A>) ->
  take<A> n (append<A> xs ys) 
  = append<A> (take<A> n xs) (take<A> (minus n (length<A> xs)) ys)
 */
  /*
prop "take drop"<A>: forall (n m: nat) (xs: list<A>) ->
  take<A> n (drop <A> m xs)
  = drop<A> m (take<A> (add n m) xs)
  */
 /* 
prop "take zip"<A, B>: forall (n: nat) (xs: list<A>) (ys: list<B>) ->
  take<(A, B)> n (zip<A, B> xs ys) 
  = zip<A, B> (take<A> n xs) (take<B> n ys)
  */
/*
let srtd_tree_ins = 
  fix (srtd_ins: nat -> tree<nat> -> bool) (n: nat) (t: tree<nat>) ->
  match t with
  | Leaf -> True
  | Node t1 x t2 ->
    if le n x
    then 
      and (sorted_tree t2)
        (and (le_leftmost x t2)
        (and (rightmost_le (tree_insert n t1) x)
        (srtd_ins n t1)))
    else 
      and (sorted_tree t1)
        (and (le_leftmost x (tree_insert n t2))
        (and (rightmost_le t1 x)
        (srtd_ins n t2)))
  end

prop "sorted flatten": forall (t: tree<nat>) (n: nat) (xs: list<nat>) ->
  implies (sorted_tree t) (is_sorted (flatten<nat> (tree_insert n t)))

prop "rightmost ins": forall (t: tree<nat>) (n: nat) (x: nat) ->
  implies (and (le x n) (rightmost_le t n)) 
    (rightmost_le (tree_insert x t) n)
  
prop "rightmost le": forall (t: tree<nat>) (n: nat) ->
  le (rightmost<nat> t) n = rightmost_le t n

prop "leftmost ins": forall (t: tree<nat>) (n x: nat) ->
  implies (and (le n x) (le_leftmost n t)) 
    (le_leftmost n (tree_insert x t))
    
prop "leftmost ins 2": forall (t1 t2: tree<nat>) (x y n: nat) ->
  implies (and (le n x) (le_leftmost n (Node<nat> t1 y Leaf<nat>))) 
    (le_leftmost n (Node<nat> (tree_insert x t1) y Leaf<nat>))
    
prop "sorted tree impl": forall (t1 t2: tree<nat>) (x: nat) ->
  match sorted_tree (Node<nat> t1 x t2) with
  | True -> 
    match t2 with 
    | Leaf -> rightmost_le t1 x
    | Node t1 x t2 -> True
    end
  | False -> True
  end
  
prop "leftmost impl": forall (t1 t2: tree<nat>) (x n: nat) ->
  implies (le_leftmost n (Node<nat> t1 x t2))
    (le_leftmost n (tree_insert n t1))
    
prop "last flatten"<A>: forall (t: tree<A>) ->
  last<A> (flatten<A> t) = rightmost<A> t
  
prop "prop 27": forall (x: nat) (xs ys: list<nat>) ->
  implies (elem_nat x ys) (elem_nat x (append<nat> xs ys))

prop "prop 30": forall (x: nat) (xs: list<nat>) ->
  elem_nat x (insert x xs)
  
prop "prop 66": forall (p: nat -> bool) (xs: list<nat>) ->
  le (length<nat> (filter<nat> p xs)) (length<nat> xs)

prop "prop 6": forall (n m: nat) ->
  minus n (add n m) = 0 
  
prop "prop 9": forall (i j k: nat) ->
  minus (minus i j) k = minus i (add j k)
  
 
prop "height mirror" <A>: forall (t: tree<A>) ->
  height<A> (mirror<A> t) = height<A> t
*/



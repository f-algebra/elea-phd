
prop "id nat":
  (fun (n: nat) -> n)
  = 
  (fix (id: nat -> nat) (n: nat) -> 
    match n with | 0 -> 0 | Suc n' -> Suc (id n') end)
    

prop "add 0": forall (n: nat) -> add n 0 = n

prop "add associative": forall (x y z: nat) -> 
  add (add x y) z = add x (add y z)
    
prop "add commutative": forall (x y z: nat) ->
  add x y = add y x
  
prop "max associative": forall (x y z: nat) ->
  max x (max y z) = max (max x y) z

let double = 
  fix (dbl: nat -> nat) (x: nat) ->
  match x with
  | 0 -> 0
  | Suc x' -> Suc (Suc (dbl x'))
  end
  
prop "add double": forall (x: nat) ->
  double x = add x x

prop "id list"<A>:
  (fun (n: nat) (xs: list<A>) -> xs)
  =
  (fix (id: nat -> list<A> -> list<A>) (n: nat) (xs: list<A>) ->
    match n with
    | 0 -> xs
    | Suc n' -> 
      match xs with
      | Nil -> Nil<A>
      | Cons y ys -> Cons<A> y (id n' ys)
      end
    end)

prop "append nil"<A>: forall (xs: list<A>) ->
  append<A> xs Nil<A> = xs
 
prop "append associative"<A>: forall (xs ys zs: list<A>) ->
  append<A> (append<A> xs ys) zs = append<A> xs (append<A> ys zs)

  
let revapp<A> = 
  fix (rap: A -> list<A> -> list<A>) (n: A) (xs: list<A>) ->
    match xs with
    | Nil -> Cons<A> n Nil<A>
    | Cons y ys -> append<A> (rap n ys) (Cons<A> y Nil<A>)
    end
    
prop "revapp def"<A>: forall (n: A) (xs: list<A>) ->
  reverse<A> (append<A> xs (Cons<A> n Nil<A>)) = revapp<A> n xs

prop "revapp cons"<A>: forall (n: A) (xs: list<A>) ->
  revapp<A> n xs = Cons<A> n (reverse<A> xs)
  
prop "revrev"<A>: forall (xs: list<A>) ->
  xs = reverse<A> (reverse<A> xs)

prop "count reverse": forall (n: nat) (xs: list<nat>) ->
  count_nat n (reverse<nat> xs) = count_nat n xs
  
prop "count append": forall (n: nat) (xs ys: list<nat>) ->
  count_nat n (append<nat> xs ys) = add (count_nat n xs) (count_nat n ys)

prop "count snoc": forall (n: nat) (xs: list<nat>) ->
  count_nat n (append<nat> xs (Cons<nat> n Nil<nat>)) = Suc (count_nat n xs)
  
prop "eq_nat reflexive": forall (n: nat) -> 
  eq_nat n n
  
prop "leq_nat reflexive": forall (n: nat) ->
  leq_nat n n
  
prop "eq_nat symmetric": forall (n m: nat) ->
  implies (eq_nat n m) (eq_nat m n)
  
prop "eq_nat transitive": forall (i j k: nat) ->
  implies (and (eq_nat i j) (eq_nat j k)) (eq_nat i k)
  
prop "leq_nat transitive": forall (i j k: nat) ->
  implies (and (leq_nat i j) (leq_nat j k)) (leq_nat i k)
  
prop "leq_nat total": forall (n m: nat) ->
  implies (not (leq_nat n m)) (leq_nat m n)
  
prop "leq_nat total 2": forall (f: nat -> nat) (n m: nat) ->
  implies (not (leq_nat (f n) m)) (leq_nat m (f n))
  
prop "drop take"<A>: forall (n: nat) (xs: list<A>) ->
  xs = append<A> (take<A> n xs) (drop<A> n xs)
  
prop "drop add"<A>: forall (n: nat) (m: nat) (xs: list<A>) ->
  drop<A> (add m n) xs = drop<A> n (drop<A> m xs)
  
prop "filter reverse"<A>: forall (p: A -> bool) (xs: list<A>) ->
  reverse<A> (filter<A> p xs) = filter<A> p (reverse<A> xs)

prop "insertsort sorted": forall (xs: list<nat>) ->
  is_sorted (insertsort xs)
  
prop "take append"<A>: forall (n: nat) (xs ys: list<A>) ->
  take<A> n (append<A> xs ys) 
  = append<A> (take<A> n xs) (take<A> (minus n (length<A> xs)) ys)
 
  /*
prop "take drop"<A>: forall (n m: nat) (xs: list<A>) ->
  take<A> n (drop <A> m xs)
  = drop<A> m (take<A> (add n m) xs)
  */
  
prop "take zip"<A, B>: forall (n: nat) (xs: list<A>) (ys: list<B>) ->
  take<(A, B)> n (zip<A, B> xs ys) 
  = zip<A, B> (take<A> n xs) (take<B> n ys)

  
prop "sorted flatten": forall (t: tree<nat>) (n: nat) ->
  is_sorted (flatten<nat> (tree_insert n t))

  
  /*
prop "height mirror" <A>: forall (t: tree<A>) ->
  height<A> (mirror<A> t) = height<A> t
*/

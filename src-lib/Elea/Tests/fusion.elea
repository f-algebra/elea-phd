
prop "add 0": forall (n: nat) -> add n 0 = n

prop "add associative": 
  forall (x y z: nat) -> 
    add (add x y) z = add x (add y z)

prop "append associative": 
  forall (xs ys zs: nlist) ->
    append (append xs ys) zs = append xs (append ys zs)
    
let revapp = 
  fix (rap: nat -> nlist -> nlist) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> Cons n Nil
    | Cons y ys -> append (rap n ys) (Cons y Nil)
    end
    
prop "revapp def": forall (n: nat) (xs: nlist) ->
  reverse (append xs (Cons n Nil)) = revapp n xs

prop "revapp cons": forall (n: nat) (xs: nlist) ->
  revapp n xs = Cons n (reverse xs)

  
prop "count reverse": forall (n: nat) (xs: nlist) ->
  count n (reverse xs) = count n xs
  
prop "count append": forall (n: nat) (xs ys: nlist) ->
  count n (append xs ys) = add (count n xs) (count n ys)

prop "count snoc": forall (n: nat) (xs: nlist) ->
  count n (append xs (Cons n Nil)) = Suc (count n xs)
  
  
prop "eq_nat reflexive": forall (n: nat) -> 
  eq_nat n n
  
prop "leq_nat reflexive": forall (n: nat) ->
  leq_nat n n
  
prop "eq_nat symmetric": forall (n m: nat) ->
  implies (eq_nat n m) (eq_nat m n)
  
prop "eq_nat transitive": forall (i j k: nat) ->
  implies (and (eq_nat i j) (eq_nat j k)) (eq_nat i k)
  
prop "leq_nat transitive": forall (i j k: nat) ->
  implies (and (leq_nat i j) (leq_nat j k)) (leq_nat i k)
  
  
prop "filter reverse": forall (p: nat -> bool) (xs: nlist) ->
  reverse (filter p xs) = filter p (reverse xs)

/*
prop "insertsort sorted": forall (xs: nlist) ->
  is_sorted (insertsort xs)
*/

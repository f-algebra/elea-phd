
prop "id nat":
  (fun (n: nat) -> n)
  = 
  (fix (id: nat -> nat) (n: nat) -> 
    match n with | 0 -> 0 | Suc n' -> Suc (id n') end)
    

prop "add 0": forall (n: nat) -> add n 0 = n

prop "add associative": forall (x y z: nat) -> 
  add (add x y) z = add x (add y z)
    
prop "add commutative": forall (x y z: nat) ->
  add x y = add y x
  
prop "max associative": forall (x y z: nat) ->
  max x (max y z) = max (max x y) z

let double = 
  fix (dbl: nat -> nat) (x: nat) ->
  match x with
  | 0 -> 0
  | Suc x' -> Suc (Suc (dbl x'))
  end
  
prop "add double": forall (x: nat) ->
  double x = add x x

prop "id list"<A>:
  (fun (n: nat) (xs: list<A>) -> xs)
  =
  (fix (id: nat -> list<A> -> list<A>) (n: nat) (xs: list<A>) ->
    match n with
    | 0 -> xs
    | Suc n' -> 
      match xs with
      | Nil -> Nil<A>
      | Cons y ys -> Cons<A> y (id n' ys)
      end
    end)

prop "append nil"<A>: forall (xs: list<A>) ->
  append<A> xs Nil<A> = xs
 
prop "append associative"<A>: forall (xs ys zs: list<A>) ->
  append<A> (append<A> xs ys) zs = append<A> xs (append<A> ys zs)

  
let revapp<A> = 
  fix (rap: A -> list<A> -> list<A>) (n: A) (xs: list<A>) ->
    match xs with
    | Nil -> Cons<A> n Nil<A>
    | Cons y ys -> append<A> (rap n ys) (Cons<A> y Nil<A>)
    end
    
prop "revapp def"<A>: forall (n: A) (xs: list<A>) ->
  reverse<A> (append<A> xs (Cons<A> n Nil<A>)) = revapp<A> n xs

prop "revapp cons"<A>: forall (n: A) (xs: list<A>) ->
  revapp<A> n xs = Cons<A> n (reverse<A> xs)
  
prop "revrev"<A>: forall (xs: list<A>) ->
  xs = reverse<A> (reverse<A> xs)

prop "count reverse": forall (n: nat) (xs: list<nat>) ->
  count_nat n (reverse<nat> xs) = count_nat n xs
  
prop "count append": forall (n: nat) (xs ys: list<nat>) ->
  count_nat n (append<nat> xs ys) = add (count_nat n xs) (count_nat n ys)

prop "count snoc": forall (n: nat) (xs: list<nat>) ->
  count_nat n (append<nat> xs (Cons<nat> n Nil<nat>)) = Suc (count_nat n xs)
  
prop "eq_nat reflexive": forall (n: nat) -> 
  eq_nat n n
  
prop "leq_nat reflexive": forall (n: nat) ->
  leq_nat n n
  
prop "eq_nat symmetric": forall (n m: nat) ->
  implies (eq_nat n m) (eq_nat m n)
  
prop "eq_nat transitive": forall (i j k: nat) ->
  implies (and (eq_nat i j) (eq_nat j k)) (eq_nat i k)
  
prop "leq_nat transitive": forall (i j k: nat) ->
  implies (and (leq_nat i j) (leq_nat j k)) (leq_nat i k)
  
prop "leq_nat total": forall (n m: nat) ->
  implies (not (leq_nat n m)) (leq_nat m n)
  
prop "leq_nat total 2": forall (f: nat -> nat) (n m: nat) ->
  implies (not (leq_nat (f n) m)) (leq_nat m (f n))
  
prop "drop take"<A>: forall (n: nat) (xs: list<A>) ->
  xs = append<A> (take<A> n xs) (drop<A> n xs)
  
prop "drop add"<A>: forall (n: nat) (m: nat) (xs: list<A>) ->
  drop<A> (add m n) xs = drop<A> n (drop<A> m xs)
  
prop "filter reverse"<A>: forall (p: A -> bool) (xs: list<A>) ->
  reverse<A> (filter<A> p xs) = filter<A> p (reverse<A> xs)

prop "insertsort sorted": forall (xs: list<nat>) ->
  is_sorted (insertsort xs)
/*  
prop "take append"<A>: forall (n: nat) (xs ys: list<A>) ->
  take<A> n (append<A> xs ys) 
  = append<A> (take<A> n xs) (take<A> (minus n (length<A> xs)) ys)
 */
  /*
prop "take drop"<A>: forall (n m: nat) (xs: list<A>) ->
  take<A> n (drop <A> m xs)
  = drop<A> m (take<A> (add n m) xs)
  */
  
prop "take zip"<A, B>: forall (n: nat) (xs: list<A>) (ys: list<B>) ->
  take<(A, B)> n (zip<A, B> xs ys) 
  = zip<A, B> (take<A> n xs) (take<B> n ys)

let srtd_tree_ins = 
  fix (srtd_ins: nat -> tree<nat> -> bool) (n: nat) (t: tree<nat>) ->
  match t with
  | Leaf -> True
  | Node t1 x t2 ->
    if leq_nat n x
    then 
      and (srtd_ins n t1) 
        (and (leq_leftmost x t2)
        (and (rightmost_leq (tree_insert n t1) x)
        (sorted_tree t2)))
    else 
      and (sorted_tree t1)
        (and (leq_leftmost x (tree_insert n t2))
        (and (rightmost_leq t1 x)
        (srtd_ins n t2)))
  end

prop "sorted flatten": forall (t: tree<nat>) (n: nat) (xs: list<nat>) ->
  implies (is_sorted (flatten<nat> t)) (is_sorted (flatten<nat> (tree_insert n t)))

prop "rightmost ins": forall (t: tree<nat>) (n: nat) (x: nat) ->
  implies (and (leq_nat x n) (rightmost_leq t n)) 
    (rightmost_leq (tree_insert x t) n)
  
prop "rightmost leq": forall (t: tree<nat>) (n: nat) ->
  leq_nat (rightmost<nat> t) n = rightmost_leq t n

prop "leftmost ins": forall (t: tree<nat>) (n x: nat) ->
  implies (and (leq_nat n x) (leq_leftmost n t)) 
    (leq_leftmost n (tree_insert x t))
    
prop "leftmost impl": forall (t1 t2: tree<nat>) (x n: nat) ->
  implies (leq_leftmost n (Node<nat> t1 x t2))
    (leq_leftmost n (tree_insert n t1))
    
prop "last flatten"<A>: forall (t: tree<A>) ->
  last<A> (flatten<A> t) = rightmost<A> t
 
prop "prop 27": forall (x: nat) (xs ys: list<nat>) ->
  implies (elem_nat x ys) (elem_nat x (append<nat> xs ys))

prop "prop 30": forall (x: nat) (xs: list<nat>) ->
  elem_nat x (insert_nat x xs)
  /*
prop "prop 66": forall (p: nat -> bool) (xs: list<nat>) ->
  leq_nat (length<nat> (filter<nat> p xs)) (length<nat> xs)
  */
  /*
prop "prop 3": forall (n: nat) (xs ys: list<nat>) ->
  leq_nat (count_nat n xs) (count_nat n (append<nat> xs ys))
*/

prop "prop 6": forall (n m: nat) ->
  minus n (add n m) = 0 
  
prop "prop 9": forall (i j k: nat) ->
  minus (minus i j) k = minus i (add j k)
  
  /*
prop "height mirror" <A>: forall (t: tree<A>) ->
  height<A> (mirror<A> t) = height<A> t
*/

 
prop "unfold productive fix": forall (xs: list<nat>) ->
  (match append<nat> xs (Cons<nat> 1 Nil<nat>) with
   | Nil -> 0 | Cons y ys -> y end)
  =
  (match xs with
   | Nil -> 1 | Cons y ys -> y end)
   
prop "unfold branching fix"<A>: forall (t: tree<A>) ->
  (match flatten<A> t with
   | Nil -> 0 | Cons y ys -> 1 end)
  = 
  (match t with
   | Leaf -> 0 | Node t1 x t2 -> 1 end)
   
prop "unfold branching fix 2": forall (t: tree<nat>) (n: nat) ->
  (match tree_insert n t with
    | Leaf -> 1
    | Node t1 x t2 -> 2 
    end) = 2
    



/* Booleans */ 

ind bool = True | False

let not = 
  fun (x:bool) -> 
    match x with 
    | True -> False 
    | False -> True 
    end

let or = 
  fun (x: bool) (y: bool) -> 
    match x with
    | True -> True
    | False -> 
      match y with
      | True -> True
      | False -> False
      end
    end

let and =
  fun (x:bool) (y:bool) ->
    match x with
    | True -> 
      match y with
      | True -> True
      | False -> False
      end
    | False -> False
    end
    
let implies = fun (p:bool) (q:bool) -> or (not p) q

    
/* Natural numbers */    
    
ind nat = 0 | Suc nat

let 1 = Suc 0
let 2 = Suc 1

let eq_nat = 
  fix (eq_nat: nat -> nat -> bool) (x:nat) (y:nat) ->
    match x with
    | 0 ->
      match y with
      | 0 -> True
      | Suc y' -> False
      end
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> eq_nat x' y'
      end
    end
    
let leq_nat = 
  fix (leq_nat: nat -> nat -> bool) (x: nat) (y: nat) -> 
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq_nat x' y'
      end
    end
    
let max = 
  fun (x: nat) (y: nat) ->
    match leq_nat x y with
    | True -> y
    | False -> x
    end

let add = 
  fix (add: nat -> nat -> nat) (x: nat) (y: nat) -> 
    match x with 
    | 0 -> y
    | Suc x' -> Suc (add x' y)
    end
   
let mul = 
  fix (mul: nat -> nat -> nat) (x: nat) (y: nat) -> 
    match x with
    | 0 -> 0
    | Suc x' -> add y (mul x' y)
    end
    
let leq = 
  fix (leq: nat -> nat -> bool) (x:nat) (y:nat) ->
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq x' y'
      end
    end


ind nlist = Nil | Cons nat nlist

let length = 
  fix (len: nlist -> nat) (xs: nlist) ->
    match xs with
    | Nil -> 0
    | Cons y ys -> Suc (len ys)
    end
    
let append =
  fix (app: nlist -> nlist -> nlist) (xs: nlist) (zs: nlist) ->
    match xs with
    | Nil -> zs
    | Cons y ys -> Cons y (app ys zs)
    end
    
let reverse = 
  fix (rev: nlist -> nlist) (xs: nlist) ->
    match xs with
    | Nil -> Nil
    | Cons y ys -> append (rev ys) (Cons y Nil)
    end
    
let count = 
  fix (c: nat -> nlist -> nat) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> 0
    | Cons y ys ->
      match eq_nat n y with
      | True -> Suc (c n ys)
      | False -> c n ys
      end
    end



/* Booleans */ 

ind bool = True | False

let not = 
  fun (x:bool) -> 
    match x with 
    | True -> False 
    | False -> True 
    end

let or = 
  fun (x: bool) (y: bool) -> 
    match x with
    | True -> True
    | False -> 
      match y with
      | True -> True
      | False -> False
      end
    end

let and =
  fun (x:bool) (y:bool) ->
    match x with
    | True -> 
      match y with
      | True -> True
      | False -> False
      end
    | False -> False
    end
    
let implies = fun (p:bool) (q:bool) -> or (not p) q

    
/* Natural numbers */    
    
ind nat = 0 | Suc nat

let 1 = Suc 0
let 2 = Suc 1

let eq_nat = 
  fix (eq_nat: nat -> nat -> bool) (x:nat) (y:nat) ->
    match x with
    | 0 ->
      match y with
      | 0 -> True
      | Suc y' -> False
      end
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> eq_nat x' y'
      end
    end
    
let leq_nat = 
  fix (leq_nat: nat -> nat -> bool) (x: nat) (y: nat) -> 
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq_nat x' y'
      end
    end
    
let max = 
  fun (x: nat) (y: nat) ->
    match leq_nat x y with
    | True -> y
    | False -> x
    end

let add = 
  fix (add: nat -> nat -> nat) (x: nat) (y: nat) -> 
    match x with 
    | 0 -> y
    | Suc x' -> Suc (add x' y)
    end
   
let mul = 
  fix (mul: nat -> nat -> nat) (x: nat) (y: nat) -> 
    match x with
    | 0 -> 0
    | Suc x' -> add y (mul x' y)
    end
    
let leq = 
  fix (leq: nat -> nat -> bool) (x:nat) (y:nat) ->
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq x' y'
      end
    end


ind nlist = Nil | Cons nat nlist

let length = 
  fix (len: nlist -> nat) (xs: nlist) ->
    match xs with
    | Nil -> 0
    | Cons y ys -> Suc (len ys)
    end
    
let append =
  fix (app: nlist -> nlist -> nat) (xs: nlist) (zs: nlist) ->
    match xs with
    | Nil -> zs
    | Cons y ys -> Cons y (app ys zs)
    end
    
let reverse = 
  fix (rev: nlist -> nlist) (xs: nlist) ->
    match xs with
    | Nil -> Nil
    | Cons y ys -> append (rev ys) (Cons y Nil)
    end
    
/*
    
let list = fun (a: *) -> 
  ind list: * with 
  | Nil: list 
  | Cons: pi a list -> list
  end

let Nil = fun (a: *) -> inj0 (list a)
let Cons = fun (a: *) -> inj1 (list a)

let app = 
  fun (a: *) ->
    fix (app: pi (list a) (list a) -> list a) ->
      fun (xs: list a) (ys: list a) ->
        match xs with
        | Nil -> ys
        | Cons x xs' -> Cons a x (app xs' ys)
        end

let rev = 
  fun (a: *) ->
    fix (rev: pi (list a) -> list a) (xs: list a) ->
      match xs with
      | Nil -> Nil a
      | Cons x xs' -> 
          app a (rev xs') (Cons a x (Nil a))
      end
      
let count =
  fix (count: pi nat (list nat) -> nat) (n:nat) (xs:list nat) ->
    match xs with
    | Nil -> 0
    | Cons x xs' -> 
      match eq_nat n x with
      | True -> Suc (count n xs')
      | False -> count n xs'
      end
    end
    
let take =
  fix (take: pi (a:*) nat (list a) -> list a) (a:*) (n:nat) (xs:list a) ->
    match xs with
    | Nil -> Nil a
    | Cons y ys -> 
      match n with
      | 0 -> Nil a
      | Suc n' -> Cons a y (take a n' ys)
      end
    end
    
    
let sorted =
  fix (srtd: pi (list nat) -> bool) (xs:list nat) ->
    match xs with
    | Nil -> True
    | Cons y ys -> 
      match ys with
      | Nil -> True
      | Cons z zs -> and (leq_nat y z) (srtd ys)
      end
    end
    
let insert = 
  fix (ins: pi nat (list nat) -> list nat) (n: nat) (xs: list nat) ->
    match xs with
    | Nil -> Cons nat n (Nil nat)
    | Cons y ys ->
      match leq_nat n y with
      | True -> Cons nat n xs
      | False -> Cons nat y (ins n ys)
      end
    end
    
let isort = 
  fix (isort: pi (list nat) -> list nat) (xs: list nat) ->
    match xs with
    | Nil -> Nil nat
    | Cons y ys -> insert y (isort ys)
    end

    

let tree = fun (a:*) ->
  ind tree: * with
  | Leaf: tree
  | Node: pi a tree tree -> tree
  end
 
let Leaf = fun (a: *) -> inj0 (tree a)
let Node = fun (a: *) -> inj1 (tree a)

let mirror =
  fun (a: *) ->
  fix (mirror: pi (tree a) -> tree a) ->
    fun (t: tree a) ->
    match t with
    | Leaf -> Leaf a
    | Node x t1 t2 -> Node a x (mirror t2) (mirror t1)
    end
    
let height = 
  fun (a: *) ->
  fix (height: pi (tree a) -> nat) ->
    fun (t: tree a) ->
    match t with
    | Leaf -> 0
    | Node x t1 t2 -> Suc (max (height t1) (height t2))
    end
  
let size =
  fun (a: *) ->  
  fix (size: pi (tree a) -> nat) -> 
    fun (t: tree a) ->
    match t with
    | Leaf -> 1
    | Node x t1 t2 -> Suc (add (size t1) (size t2))
    end
    
let flatten = 
  fun (a: *) ->
  fix (flat: pi (tree a) -> list a) ->
    fun (t: tree a) ->
    match t with
    | Leaf -> Nil a
    | Node x t1 t2 -> app a (flat t1) (Cons a x (flat t2))
    end
    
let ins_tree =
  fix (ins: pi nat (tree nat) -> tree nat) (n: nat) (t: tree nat) ->
  match t with
  | Leaf -> Node nat n (Leaf nat) (Leaf nat)
  | Node x t1 t2 -> 
    match leq_nat n x with
    | True -> Node nat x (ins n t1) t2
    | False -> Node nat x t1 (ins n t2)
    end
  end

let build = 
  fix (build: pi (list nat) -> tree nat) (xs: list nat) ->
  match xs with
  | Nil -> Leaf nat
  | Cons y ys -> ins_tree y (build ys)
  end
  
let treesort =
  fun (xs: list nat) -> flatten nat (build xs)

  */
  

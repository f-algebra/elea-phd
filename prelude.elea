
/* Booleans */ 

ind bool = True | False

let not = 
  fun (p: bool) -> if p then False else True

let or = 
  fun (p q: bool) -> if p then True else q

let and =
  fun (p q:bool) -> if p then q else False
    
let implies =
  fun (p q:bool) -> if p then q else True

    
/* Natural numbers */    
    
ind nat = 0 | Suc nat

let 1 = Suc 0
let 2 = Suc 1

let eq_nat = 
  fix (eq_nat: nat -> nat -> bool) (x y:nat) ->
    match x with
    | 0 ->
      match y with
      | 0 -> True
      | Suc y' -> False
      end
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> eq_nat x' y'
      end
    end
    
let leq_nat = 
  fix (leq_nat: nat -> nat -> bool) (x y: nat) -> 
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq_nat x' y'
      end
    end
    
let max = 
  fun (x: nat) (y: nat) ->
    match leq_nat x y with
    | True -> y
    | False -> x
    end

let add = 
  fix (add: nat -> nat -> nat) (x y: nat) -> 
    match x with 
    | 0 -> y
    | Suc x' -> Suc (add x' y)
    end
   
let mul = 
  fix (mul: nat -> nat -> nat) (x y: nat) -> 
    match x with
    | 0 -> 0
    | Suc x' -> add y (mul x' y)
    end
    
let leq = 
  fix (leq: nat -> nat -> bool) (x y:nat) ->
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq x' y'
      end
    end


ind nlist = Nil | Cons nat nlist

let length = 
  fix (len: nlist -> nat) (xs: nlist) ->
    match xs with
    | Nil -> 0
    | Cons y ys -> Suc (len ys)
    end
    
let append =
  fix (app: nlist -> nlist -> nlist) (xs zs: nlist) ->
    match xs with
    | Nil -> zs
    | Cons y ys -> Cons y (app ys zs)
    end
    
let reverse = 
  fix (rev: nlist -> nlist) (xs: nlist) ->
    match xs with
    | Nil -> Nil
    | Cons y ys -> append (rev ys) (Cons y Nil)
    end
    
let count = 
  fix (c: nat -> nlist -> nat) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> 0
    | Cons y ys ->
      if eq_nat n y 
      then Suc (c n ys)
      else c n ys
    end

let insert = 
  fix (ins: nat -> nlist -> nlist) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> Cons n Nil
    | Cons y ys -> 
      if leq_nat n y
      then Cons n xs
      else Cons y (ins n ys)
    end
    
let insertsort = 
  fix (isort: nlist -> nlist) (xs: nlist) ->
    match xs with
    | Nil -> Nil
    | Cons y ys -> insert y (isort ys)
    end
    
let is_sorted = 
  fix (srtd: nlist -> bool) (xs: nlist) ->
    match xs with
    | Nil -> True
    | Cons y ys ->
      match ys with
      | Nil -> True
      | Cons z zs -> 
        and (leq_nat y z) (srtd ys)
      end
    end
    

ind ntree = Leaf | Node ntree nat ntree


    

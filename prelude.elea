
let id = fun (a:*) (x:a) -> x


/* Booleans */ 

let bool =
  ind bool: * with
  | True: bool
  | False: bool
  end
  
let True = inj0 bool
let False = inj1 bool

let not = fun (x:bool) -> match x with | True -> False | False -> True end

let or = 
  fun (x: bool) (y: bool) -> 
    match x with
    | True -> True
    | False -> 
      match y with
      | True -> True
      | False -> False
      end
    end

let and =
  fun (x:bool) (y:bool) ->
    match x with
    | True -> 
      match y with
      | True -> True
      | False -> False
      end
    | False -> False
    end
    
let implies = fun (p:bool) (q:bool) -> or (not p) q

    
/* Natural numbers */    
    
let nat =
  ind nat: * with 
  | 0: nat 
  | Suc: pi nat -> nat
  end
  
let 0 = inj0 nat
let Suc = inj1 nat
let 1 = Suc 0
let 2 = Suc 1

let eq_nat = 
  fix (eq_nat: pi nat nat -> bool) (x:nat) (y:nat) ->
    match x with
    | 0 ->
      match y with
      | 0 -> True
      | Suc y' -> False
      end
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> eq_nat x' y'
      end
    end
    
let leq_nat = 
  fix (leq_nat: pi nat nat -> bool) (x: nat) (y: nat) -> 
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq_nat x' y'
      end
    end

let add = 
  fix (add: pi nat nat -> nat) (x: nat) (y: nat) -> 
    match x with 
    | 0 -> y
    | Suc x' -> Suc (add x' y)
    end
   
let mul = 
  fix (mul: pi nat nat -> nat) (x: nat) (y: nat) -> 
    match x with
    | 0 -> 0
    | Suc x' -> add y (mul x' y)
    end
    
let leq = 
  fix (leq: pi nat nat -> bool) (x:nat) (y:nat) ->
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq x' y'
      end
    end

/* Lists */
    
let list = fun (a: *) -> 
  ind list: * with 
  | Nil: list 
  | Cons: pi a list -> list
  end

let Nil = fun (a: *) -> inj0 (list a)
let Cons = fun (a: *) -> inj1 (list a)

let length =
  fun (a: *) ->
    fix (len: pi (list a) -> nat) ->
      fun (xs: list a) ->
        match xs with
        | Nil -> 0
        | Cons x xs' -> Suc (len xs')
        end

let app = 
  fun (a: *) ->
    fix (app: pi (list a) (list a) -> list a) ->
      fun (xs: list a) (ys: list a) ->
        match xs with
        | Nil -> ys
        | Cons x xs' -> Cons a x (app xs' ys)
        end

let rev = 
  fun (a: *) ->
    fix (rev: pi (list a) -> list a) (xs: list a) ->
      match xs with
      | Nil -> Nil a
      | Cons x xs' -> 
          app a (rev xs') (Cons a x (Nil a))
      end
      
let count =
  fix (count: pi nat (list nat) -> nat) (n:nat) (xs:list nat) ->
    match xs with
    | Nil -> 0
    | Cons x xs' -> 
      match eq_nat n x with
      | True -> Suc (count n xs')
      | False -> count n xs'
      end
    end
    
let take =
  fix (take: pi (a:*) nat (list a) -> list a) (a:*) (n:nat) (xs:list a) ->
    match xs with
    | Nil -> Nil a
    | Cons y ys -> 
      match n with
      | 0 -> Nil a
      | Suc n' -> Cons a y (take a n' ys)
      end
    end
    
    
/* Sorting lists */
    
let sorted =
  fix (srtd: pi (list nat) -> bool) (xs:list nat) ->
    match xs with
    | Nil -> True
    | Cons y ys -> 
      match ys with
      | Nil -> True
      | Cons z zs -> and (leq_nat y z) (srtd ys)
      end
    end
    
let insert = 
  fix (ins: pi nat (list nat) -> list nat) (n: nat) (xs: list nat) ->
    match xs with
    | Nil -> Cons nat n (Nil nat)
    | Cons y ys ->
      match leq_nat n y with
      | True -> Cons nat n xs
      | False -> Cons nat y (ins n ys)
      end
    end
    
let isort = 
  fix (isort: pi (list nat) -> list nat) (xs: list nat) ->
    match xs with
    | Nil -> Nil nat
    | Cons y ys -> insert y (isort ys)
    end

    
/* Trees */

let tree = fun (a:*) ->
  ind tree: * with
  | Leaf: tree
  | Node: pi a tree tree -> tree
  end
 
let Leaf = fun (a: *) -> inj0 (tree a)
let Node = fun (a: *) -> inj1 (tree a)

let mirror =
  fun (a: *) ->
  fix (mirror: pi (tree a) -> tree a) ->
    fun (t: tree a) ->
    match t with
    | Leaf -> Leaf a
    | Node x t1 t2 -> Node a x (mirror t2) (mirror t1)
    end
    
let height = 
  fun (a: *) ->
  fix (height: pi (tree a) -> nat) ->
    fun (t: tree a) ->
    match t with
    | Leaf -> 0
    | Node x t1 t2 -> Suc (add (height t1) (height t2))
    end
  
let flatten = 
  fun (a: *) ->
  fix (flat: pi (tree a) -> list a) ->
    fun (t: tree a) ->
    match t with
    | Leaf -> Nil a
    | Node x t1 t2 -> app a (flat t1) (Cons a x (flat t2))
    end

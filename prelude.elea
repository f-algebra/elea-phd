
let nat =
  ind nat: * with 
  | 0: nat 
  | Suc: pi nat -> nat
  end
  
let 0 = inj0 nat
let Suc = inj1 nat
let 1 = Suc 0
let 2 = Suc 1

let list = fun (a: *) -> 
  ind list: * with 
  | Nil: list 
  | Cons: pi a list -> list
  end

let Nil = fun (a: *) -> inj0 (list a)
let Cons = fun (a: *) -> inj1 (list a)

let add = 
  fix (add: pi nat nat -> nat) (x: nat) (y: nat) -> 
    match x with 
    | 0 -> y
    | Suc x' -> Suc (add x' y)
    end
   
let mul = 
  fix (mul: pi nat nat -> nat) (x: nat) (y: nat) -> 
    match x with
    | 0 -> 0
    | Suc x' -> add y (mul x' y)
    end

let app = 
  fun (a: *) ->
    fix (app: pi (list a) (list a) -> list a) ->
      fun (xs: list a) (ys: list a) ->
        match xs with
        | Nil -> ys
        | Cons x xs' -> Cons a x (app xs' ys)
        end

let rev = 
  fun (a: *) ->
    fix (rev: pi (list a) -> list a) (xs: list a) ->
      match xs with
      | Nil -> Nil a
      | Cons x xs' -> 
          app a (rev xs') (Cons a x (Nil a))
      end


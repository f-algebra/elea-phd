
ind unit = Unit


/* Booleans */ 

ind bool = True | False

let not = 
  fun (p: bool) -> if p then False else True

let or = 
  fun (p q: bool) -> if p then True else q

let and =
  fun (p q:bool) -> if p then q else False
    
let implies =
  fun (p q:bool) -> if p then q else True

    
/* Natural numbers */    
    
ind nat = 0 | Suc nat

let 1 = Suc 0
let 2 = Suc 1

let eq_nat = 
  fix (eq_nat: nat -> nat -> bool) (x y:nat) ->
    match x with
    | 0 ->
      match y with
      | 0 -> True
      | Suc y' -> False
      end
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> eq_nat x' y'
      end
    end
    
let leq_nat = 
  fix (leq_nat: nat -> nat -> bool) (x y: nat) -> 
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> False
      | Suc y' -> leq_nat x' y'
      end
    end
    
let max = 
  fun (x: nat) (y: nat) ->
    match leq_nat x y with
    | True -> y
    | False -> x
    end

let add = 
  fix (add: nat -> nat -> nat) (x y: nat) -> 
    match x with 
    | 0 -> y
    | Suc x' -> Suc (add x' y)
    end
   
let mul = 
  fix (mul: nat -> nat -> nat) (x y: nat) -> 
    match x with
    | 0 -> 0
    | Suc x' -> add y (mul x' y)
    end

let minus = 
  fix (minus: nat -> nat -> nat) (x y: nat) -> 
    match y with
    | 0 -> x
    | Suc y' ->
      match x with
      | 0 -> 0
      | Suc x' -> minus x' y'
      end
    end

ind nlist = Nil | Cons nat nlist

let length = 
  fix (len: nlist -> nat) (xs: nlist) ->
    match xs with
    | Nil -> 0
    | Cons y ys -> Suc (len ys)
    end
    
let append =
  fix (app: nlist -> nlist -> nlist) (xs zs: nlist) ->
    match xs with
    | Nil -> zs
    | Cons y ys -> Cons y (app ys zs)
    end
    
let reverse = 
  fix (rev: nlist -> nlist) (xs: nlist) ->
    match xs with
    | Nil -> Nil
    | Cons y ys -> append (rev ys) (Cons y Nil)
    end
    
let count = 
  fix (c: nat -> nlist -> nat) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> 0
    | Cons y ys ->
      if eq_nat n y 
      then Suc (c n ys)
      else c n ys
    end

let take =
  fix (take: nat -> nlist -> nlist) (n: nat) (xs: nlist) ->
    match n with
    | 0 -> Nil
    | Suc n' ->
      match xs with
      | Nil -> Nil
      | Cons y ys -> Cons y (take n' ys)
      end
    end
    
let drop = 
  fix (drop: nat -> nlist -> nlist) (n: nat) (xs: nlist) ->
    match n with
    | 0 -> xs
    | Suc n' ->
      match xs with
      | Nil -> Nil
      | Cons y ys -> drop n' ys
      end
    end
 
let filter = 
  fun (p: nat -> bool) ->
  fix (filter: nlist -> nlist) (xs: nlist) ->
    match xs with
    | Nil -> Nil
    | Cons y ys -> 
      if p y
      then Cons y (filter ys)
      else filter ys
    end
    
let map =
  fun (f: nat -> nat) ->
  fix (map: nlist -> nlist) (xs: nlist) ->
    match xs with
    | Nil -> Nil
    | Cons y ys -> Cons (f y) (map ys)
    end
    
let elem =
  fix (elem: nat -> nlist -> bool) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> False
    | Cons y ys -> or (eq_nat n y) (elem n ys)
    end
    
let insert = 
  fix (ins: nat -> nlist -> nlist) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> Cons n Nil
    | Cons y ys -> 
      if leq_nat n y
      then Cons n xs
      else Cons y (ins n ys)
    end
    
let insertsort = 
  fix (isort: nlist -> nlist) (xs: nlist) ->
    match xs with
    | Nil -> Nil
    | Cons y ys -> insert y (isort ys)
    end
    
let is_sorted = 
  fix (srtd: nlist -> bool) (xs: nlist) ->
    match xs with
    | Nil -> True
    | Cons y ys ->
      match ys with
      | Nil -> True
      | Cons z zs -> 
        and (leq_nat y z) (srtd ys)
      end
    end
    

ind ntree = Leaf | Node ntree nat ntree

let flatten = 
  fix (flat: ntree -> nlist) (t: ntree) ->
    match t with
    | Leaf -> Nil
    | Node t1 x t2 -> append (flat t1) (Cons x (flat t2))
    end
    
let height = 
  fix (height: ntree -> nat) (t: ntree) ->
    match t with
    | Leaf -> 0
    | Node t1 x t2 -> Suc (max (height t1) (height t2))
    end
    
let mirror = 
  fix (mir: ntree -> ntree) (t: ntree) ->
    match t with
    | Leaf -> Leaf 
    | Node t1 x t2 -> Node (mir t2) x (mir t1)
    end  


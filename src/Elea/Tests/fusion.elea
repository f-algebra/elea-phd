
prop "add 0": forall (n: nat) -> add n 0 = n

prop "add associative": 
  forall (x: nat) (y: nat) (z: nat) -> 
    add (add x y) z = add x (add y z)

prop "append associative": 
  forall (xs: nlist) (ys: nlist) (zs: nlist) ->
    append (append xs ys) zs = append xs (append ys zs)
    
    
let revapp = 
  fix (rap: nat -> nlist -> nlist) (n: nat) (xs: nlist) ->
    match xs with
    | Nil -> Cons n Nil
    | Cons y ys -> append (rap n ys) (Cons y Nil)
    end
    
prop "revapp def": forall (n: nat) (xs: nlist) ->
  reverse (append xs (Cons n Nil)) = revapp n xs

prop "revapp cons": forall (n: nat) (xs: nlist) ->
  revapp n xs = Cons n (reverse xs)
  

let always_true = 
  fix (true: nat -> nat -> bool) (x: nat) (y: nat) ->
    match x with
    | 0 -> True
    | Suc x' ->
      match y with
      | 0 -> True
      | Suc y' -> true x' y'
      end
    end

prop "always true": forall (n: nat) (m: nat) ->
  always_true n m = True
 
  
prop "count reverse": forall (n: nat) (xs: nlist) ->
  count n (reverse xs) = count n xs
  
prop "count append": forall (n: nat) (xs: nlist) (ys: nlist) ->
  count n (append xs ys) = add (count n xs) (count n ys)

prop "count snoc": forall (n: nat) (xs: nlist) ->
  count n (append xs (Cons n Nil)) = Suc (count n xs)
  
  
prop "eq_nat reflexive": forall (n: nat) -> 
  eq_nat n n = True
  
prop "leq_nat reflexive": forall (n: nat) ->
  leq_nat n n = True


/* Requires prelude.elea to be loaded */


/* Simple Nat properties */
/*
prop (n: nat) -> add n 0 == n
prop (n: nat) -> minus n n =< 0
prop (n m: nat) -> minus n (add n m) =< 0
prop (n m: nat) -> minus (add n m) n =< m
prop (k m n: nat) -> minus (add k m) (add k n) =< minus m n
prop (k m n: nat) -> minus (minus n m) k == minus n (add m k)
prop (k m n: nat) -> max (max k m) n == max k (max m n)

prop (n m: nat) -> eq n m == eq m n
prop (k m n: nat) ->
  assertBool le n m 
  in max m n == m
prop (n: nat) -> assertBool le n 0 in n == 0
prop (n m: nat) -> le n (add n m) =< True

prop<A> (n: nat) (xs: list<A>) -> 
	append<A> (take<A> n xs) (drop<A> n xs) =< xs
	
prop (n: nat) (xs ys: list<nat>) -> 
	add (count n xs) (count n ys) == count n (append<nat> xs ys)
	
prop<A, B> (n: nat) (f: A -> B) (xs: list<A>) -> 
  drop<B> n (map<A, B> f xs) 
  == 
  map<A, B> f (drop<A> n xs)
	
prop<A> (p: A -> bool) (xs ys: list<A>) ->
  filter<A> p (append<A> xs ys) 
  == 
  append<A> (filter<A> p xs) (filter<A> p ys)
  
prop (n: nat) (xs: list<nat>) ->
  length<nat> (insert n xs) =< Suc (length<nat> xs)
  
prop<A> (n: nat) (xs: list<A>) ->
  length<A> (drop<A> n xs) == minus (length<A> xs) n
  
prop (xs: list<nat>) -> 
  length<nat> (insertsort xs) =< length<nat> xs
  
prop (n: nat) (xs ys: list<nat>) ->
  assertBool elem n xs 
  in elem n (append<nat> xs ys) =< True
  
prop (n: nat) (xs ys: list<nat>) ->
  assertBool elem n ys 
  in elem n (append<nat> xs ys) =< True
  
prop (n: nat) (xs: list<nat>) ->  
  elem n (append<nat> xs (Cons<nat> n Nil<nat>)) =< True

prop (n: nat) (xs: list<nat>) ->  
  elem n (insert n xs) =< True
  
prop (n: nat) (xs: list<nat>) ->
  elem n (delete n xs) =< False 

prop (n: nat) (xs: list<nat>) ->
  count n (append<nat> xs (Cons<nat> n Nil<nat>)) =< Suc (count n xs)
  
prop<A, B> (n: nat) (f: A -> B) (xs: list<A>) ->
  take<B> n (map<A, B> f xs) == map<A, B> f (take<A> n xs)
  
  
prop<A> (p: A -> bool) (xs: list<A>) ->
  append<A> (takeWhile<A> p xs) (dropWhile<A> p xs) =< xs
  
prop<A> (xs: list<A>) ->
  append<A> (butlast<A> xs) (Cons<A> (last<A> xs) Nil<A>) =< xs 
  
prop<A> (xs: list<A>) ->
  butlast<A> xs == take<A> (minus (length<A> xs) 1) xs
  
prop<A> (xs: list<A>) (x: A) ->
  butlast<A> (append<A> xs (Cons<A> x Nil<A>)) =< xs
         
prop<A> (n m: nat) (xs: list<A>) ->
  drop<A> n (drop<A> m xs) == drop<A> (add m n) xs
  
prop<A> (xs ys: list<A>) ->
  assertBool not (null<A> ys) 
  in last<A> (append<A> xs ys) == last<A> ys

prop<A> (xs: list<A>) (n: nat) ->
  assertBool lt n (length<A> xs)
  in last<A> (drop<A> n xs) =< last<A> xs
  
prop<A> (xs: list<A>) (x: A) ->
  last<A> (append<A> xs (Cons<A> x Nil<A>)) =< x
  
prop<A> (xs: list<A>) ->
  length<A> (butlast<A> xs) =< minus (length<A> xs) 1
*/
prop (n: nat) (xs ys: list<nat>) -> 
	le (count n xs) (count n (append<nat> xs ys))
	 /*  
prop<A> (n: nat) (xs ys: list<A>) ->
  drop<A> n (append<A> xs ys) 
  ==
  append<A> (drop<A> n xs) (drop<A> (minus n (length<A> xs)) ys)
   
*//* The other direction needs deepseq knowledge *//*
prop 71 (n m: nat) (xs: list<nat>) ->
  assertBool not (eq n m) 
  in elem n (insert m xs) =< elem n xs
  
*//* The other direction needs deepseq knowledge *//*
prop 76 (n m: nat) (xs: list<nat>) ->
  assertBool not (eq n m) 
  in count n (snoc<nat> m xs) =< count n xs
  
prop 77 (n: nat) (xs: list<nat>) ->
  assertBool is_sorted xs
  in is_sorted (insert n xs)
  
prop 78 (xs: list<nat>) ->
  is_sorted (insertsort xs)
  */
  
 
  
/*


prop_80 n xs ys
  = (take n (xs ++ ys) =:= take n xs ++ take (n - len xs) ys)

prop_81 n m xs {- ys -}
  = (take n (drop m xs) =:= drop m (take (n + m) xs))

prop_82 n xs ys
  = (take n (zip xs ys) =:= zip (take n xs) (take n ys))

prop_83 xs ys zs
  = (zip (xs ++ ys) zs =:=
           zip xs (take (len xs) zs) ++ zip ys (drop (len xs) zs))

prop_84 xs ys zs
  = (zip xs (ys ++ zs) =:=
           zip (take (len ys) xs) ys ++ zip (drop (len ys) xs) zs)

prop_85 xs ys
  = (len xs =:= len ys) ==>
    (zip (rev xs) (rev ys) =:= rev (zip xs ys))


prop_T01 :: Nat -> Prop Nat
prop_T01 x = double x =:= x + x

prop_T02 :: [a] -> [a] -> Prop Nat
prop_T02 x y = length (x ++ y ) =:= length (y ++ x)

prop_T03 :: [a] -> [a] -> Prop Nat
prop_T03 x y = length (x ++ y ) =:= length (y ) + length x

prop_T04 :: [a] -> Prop Nat
prop_T04 x = length (x ++ x) =:= double (length x)

prop_T05 :: [a] -> Prop Nat
prop_T05 x = length (rev x) =:= length x

prop_T06 :: [a] -> [a] -> Prop Nat
prop_T06 x y = length (rev (x ++ y )) =:= length x + length y

prop_T07 :: [a] -> [a] -> Prop Nat
prop_T07 x y = length (qrev x y) =:= length x + length y

prop_T08 :: Nat -> Nat -> [a] -> Prop [a]
prop_T08 x y z = drop x (drop y z) =:= drop y (drop x z)

prop_T09 :: Nat -> Nat -> [a] -> Nat -> Prop [a]
prop_T09 x y z w = drop w (drop x (drop y z)) =:= drop y (drop x (drop w z))

prop_T10 :: [a] -> Prop [a]
prop_T10 x = rev (rev x) =:= x

prop_T11 :: [a] -> [a] -> Prop [a]
prop_T11 x y = rev (rev x ++ rev y) =:= y ++ x

prop_T12 :: [a] -> [a] -> Prop [a]
prop_T12 x y = qrev x y =:= rev x ++ y

prop_T13 :: Nat -> Prop Nat
prop_T13 x = half (x + x) =:= x

prop_T14 :: [Nat] -> Prop Bool
prop_T14 x = proveBool (sorted (isort x))

prop_T15 :: Nat -> Prop Nat
prop_T15 x = x + S x =:= S (x + x)

prop_T16 :: Nat -> Prop Bool
prop_T16 x = proveBool (even (x + x))

prop_T17 :: [a] -> [a] -> Prop [a]
prop_T17 x y = rev (rev (x ++ y)) =:= rev (rev x) ++ rev (rev y)

prop_T18 :: [a] -> [a] -> Prop [a]
prop_T18 x y = rev (rev x ++ y) =:= rev y ++ x

prop_T19 :: [a] -> [a] -> Prop [a]
prop_T19 x y = rev (rev x) ++ y =:= rev (rev (x ++ y))

prop_T20 :: [a] -> Prop Bool
prop_T20 x = proveBool (even (length (x ++ x)))

prop_T21 :: [a] -> [a] -> Prop [a]
prop_T21 x y = rotate (length x) (x ++ y) =:= y ++ x

prop_T22 :: [a] -> [a] -> Prop Bool
prop_T22 x y = even (length (x ++ y)) =:= even (length (y ++ x))

prop_T23 :: [a] -> [a] -> Prop Nat
prop_T23 x y = half (length (x ++ y)) =:= half (length (y ++ x))

prop_T24 :: Nat -> Nat -> Prop Bool
prop_T24 x y = even (x + y) =:= even (y + x)

prop_T25 :: [a] -> [a] -> Prop Bool
prop_T25 x y = even (length (x ++ y)) =:= even (length y + length x)

prop_T26 :: Nat -> Nat -> Prop Nat
prop_T26 x y = half (x + y) =:= half (y + x)

prop_T27 :: [a] -> Prop [a]
prop_T27 x = rev x =:= qrev x []

prop_T28 :: [[a]] -> Prop [a]
prop_T28 x = revflat x =:= qrevflat x []

prop_T29 :: [a] -> Prop [a]
prop_T29 x = rev (qrev x []) =:= x

prop_T30 :: [a] -> Prop [a]
prop_T30 x = rev (rev x ++ []) =:= x

prop_T31 :: [a] -> Prop [a]
prop_T31 x = qrev (qrev x []) [] =:= x

prop_T32 :: [a] -> Prop [a]
prop_T32 x = rotate (length x) x =:= x

prop_T33 :: Nat -> Prop Nat
prop_T33 x = fac x =:= qfac x one

prop_T34 :: Nat -> Nat -> Prop Nat
prop_T34 x y = x * y =:= mult x y zero

prop_T35 :: Nat -> Nat -> Prop Nat
prop_T35 x y = exp x y =:= qexp x y one

prop_T36 :: Nat -> [Nat] -> [Nat] -> Prop Bool
prop_T36 x y z = givenBool (x `elem` y) (proveBool (x `elem` (y ++ z)))

prop_T37 :: Nat -> [Nat] -> [Nat] -> Prop Bool
prop_T37 x y z = givenBool (x `elem` z) (proveBool (x `elem` (y ++ z)))

prop_T38 :: Nat -> [Nat] -> [Nat] -> Prop Bool
prop_T38 x y z = givenBool (x `elem` y)
               ( givenBool (x `elem` z)
               ( proveBool (x `elem` (y ++ z))))

prop_T39 :: Nat -> Nat -> [Nat] -> Prop Bool
prop_T39 x y z = givenBool (x `elem` drop y z) (proveBool (x `elem` z))

prop_T40 :: [Nat] -> [Nat] -> Prop [Nat]
prop_T40 x y = givenBool (x `subset` y) ((x `union` y) =:= y)

prop_T41 :: [Nat] -> [Nat] -> Prop [Nat]
prop_T41 x y = givenBool (x `subset` y) ((x `intersect` y) =:= x)

prop_T42 :: Nat -> [Nat] -> [Nat] -> Prop Bool
prop_T42 x y z = givenBool (x `elem` y) (proveBool (x `elem` (y `union` z)))

prop_T43 :: Nat -> [Nat] -> [Nat] -> Prop Bool
prop_T43 x y z = givenBool (x `elem` y) (proveBool (x `elem` (z `union` y)))

prop_T44 :: Nat -> [Nat] -> [Nat] -> Prop Bool
prop_T44 x y z = givenBool (x `elem` y)
               ( givenBool (x `elem` z)
               ( proveBool (x `elem` (y `intersect` z))))

prop_T45 :: Nat -> [Nat] -> Prop Bool
prop_T45 x y = proveBool (x `elem` insert x y)

prop_T46 :: Nat -> Nat -> [Nat] -> Prop Bool
prop_T46 x y z = x =:= y ==> proveBool (x `elem` insert y z)

prop_T47 :: Nat -> Nat -> [Nat] -> Prop Bool
prop_T47 x y z = givenBool (x /= y) ((x `elem` insert y z) =:= x `elem` z)

prop_T48 :: [Nat] -> Prop Nat
prop_T48 x = length (isort x) =:= length x

prop_T49 :: Nat -> [Nat] -> Prop Bool
prop_T49 x y = givenBool (x `elem` isort y) (proveBool (x `elem` y))


!!! needs more tool work
--  Needs fission + fusion at once
prop (n m: nat) -> minus (add m n) n =< m

-- These two suffer from the len xs = len (rev xs) problem
prop 72<A> (n: nat) (xs: list<A>) ->
  reverse<A> (drop<A> n xs) == take<A> (minus (length<A> xs) n) (reverse<A> xs)
  
prop_74 i xs
  = (rev (take i xs) =:= drop (len xs - i) (rev xs))
  
  
-- This one is just hard
cubes n =:= tri n * tri n

-- These need implication based generalisations
prop<A> (p: A -> bool) (xs: list<A>) ->
  le (length<A> (filter<A> p xs)) (length<A> xs)
prop_68 n xs
  = proveBool (len (delete n xs) <= len xs)
prop (n m: nat) ->
  le n (add m n) 
prop (n m: nat) ->
  lt n (Suc (add m n))

-- This one needs that insertsort deepseqs its input
-- so it works with finite input
prop (xs: list<nat>) (n: nat) ->
  count n (insertsort xs) == count n xs
  
-- Not entirely sure what's wrong here

-- Needs dec con fusion
prop (n m: nat) ->
  assertBool le m n in le m (Suc n)

-- Needs fix fix with con fusion!
prop 79 (m n k: nat) ->
  minus (minus m n) k =< minus (minus (Suc m) n) (Suc k)
  
  
-- Needs finite mode!
prop<A> (n m: nat) (xs: list<A>) ->
  drop<A> n (take<A> m xs) =< take<A> (minus m n) (drop<A> n xs)  

max a b =:= max b a

prop_52 n xs
  = (count n xs =:= count n (rev xs))

prop_47 a
  = (height (mirror a) =:= height a)
 
prop_73 p x
  = (rev (filter p xs) =:= filter p (rev xs))

prop_75 n m xs
  = (count n xs + count n [m] =:= count n (m : xs))
  
  
! not interesting
(S (count n xs) =:= count n (n : xs))
(drop Z xs =:= xs)

prop (n x: nat) (xs: list<nat>) ->
  assertBool eq n x 
  in count n (Cons<nat> x xs) =< Suc (count n xs)
prop_13 n x xs
  = (drop (S n) (x : xs) =:= drop n xs)

prop_16 x xs
  = xs =:= [] ==> last (x:xs) =:= x

prop_31 a b c
  = (min (min a b) c =:= min a (min b c))

prop_32 a b
  = (min a b =:= min b a)

prop_33 a b
  = (min a b == a =:= a <= b)

prop_34 a b
  = (min a b == b =:= b <= a)
  

prop_35 xs
  = (dropWhile (\_ -> False) xs =:= xs)

prop_36 xs
  = (takeWhile (\_ -> True) xs =:= xs)
 
prop_39 n x xs
  = (count n [x] + count n xs =:= count n (x:xs))

prop_40 xs
  = (take Z xs =:= [])

prop_42 n x xs
  = (take (S n) (x:xs) =:= x : (take n xs))
  
prop_44 x xs ys
  = (zip (x:xs) ys =:= zipConcat x xs ys)

prop_45 x y xs ys
  = (zip (x:xs) (y:ys) =:= (x, y) : zip xs ys)

prop_46 xs
  = (zip [] xs =:= [])
  
prop_49 xs ys
  = (butlast (xs ++ ys) =:= butlastConcat xs ys)
  

prop_58 n xs ys
  = (drop n (zip xs ys) =:= zip (drop n xs) (drop n ys))

prop_59 xs ys
  = ys =:= [] ==> last (xs ++ ys) =:= last xs
  

prop_62 xs x
  = givenBool (not (null xs))
  ( (last (x:xs) =:= last xs) )

prop_61 xs ys
  = (last (xs ++ ys) =:= lastOfTwo xs ys)

*/
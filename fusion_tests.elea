let t1 = 
  fun (a:*) (y:a) (zs:list a) -> 
    rev a (app a zs (Cons a y (Nil a)))
let t1' =
  fun (a:*) (y:a) (xs:list a) -> 
    Cons a y ((
      fix (f: pi (list a)->list a) (xs:list a) ->
      match xs with
      | Nil -> Nil a
      | Cons x xs -> app a (f xs) (Cons a x (Nil a)) 
      end) xs)

let t2 = fun (x:nat) (y:nat) -> add x (Suc y)
let t2' = fun (x:nat) (y:nat) -> Suc (add x y)

let t3 = 
  fun (a:*) (xs:list a) (ys:list a) (zs:list a) ->
    app a (app a xs ys) zs
let t3' = 
  fun (a:*) (xs:list a) (ys:list a) (zs:list a) ->
    app a xs (app a ys zs)
  
let t4 = fun (x:nat) (y:nat) (z:nat) -> add (add x y) z
let t4' = fun (x:nat) (y:nat) (z:nat) -> add x (add y z)

let t5 =
  fix (f:pi nat -> bool) (x:nat) ->
    match x with | 0 -> True | Suc x' -> f x' end
let t5' = fun (x:nat) -> True

let t6 = 
  fun (n:nat) (xs:list nat) -> 
    count n (app nat xs (Cons nat n (Nil nat)))
let t6' = fun (n:nat) (xs:list nat) -> Suc (count n xs)

let t7 = fun (n:nat) (xs:list nat) -> count n (rev nat xs)
let t7' = fun (n:nat) (xs:list nat) -> count n xs

let t8 = fun (a: *) (xs: list a) -> rev a (rev a xs)
let t8' = fun (a: *) (xs: list a) -> xs

let t9 = fix (f: pi (a:*) (list a) -> list a) (a:*) (xs:list a) -> 
  match xs with
  | Nil -> Nil a
  | Cons x xs' -> Cons a x (f a xs')
  end
let t9' = fun (a:*) (xs:list a) -> xs

let t10 = fun (x:nat) (y:nat) -> or (leq_nat x y) (leq_nat y x)
let t10' = fun nat nat -> True

let t11 = fun (n:nat) (xs:list nat) (ys:list nat) -> 
  count n (app nat xs ys)
let t11' = fun (n:nat) (xs:list nat) (ys:list nat) -> 
  add (count n xs) (count n ys)

let t12 = fun (x:nat) (y:nat) (z:nat) -> 
  implies (and (leq_nat x y) (leq_nat y z)) (leq_nat x z)
let t12' = fun nat nat nat -> True

let t13 = fun (x:nat) (xs:list nat) ->
  match sorted xs with
  | True -> False
  | False -> sorted (Cons nat x xs)
  end
let t13' = fun nat (list nat) -> False
  
let t14 = fun (x:nat) (xs:list nat) -> 
  match sorted (Cons nat x xs) with
  | True -> sorted xs
  | False -> True
  end
let t14' = fun nat (list nat) -> True

let srtd_ins = 
  fix (srtd_ins: pi nat (list nat) -> bool) ->
    fun (n: nat) (xs: list nat) -> 
    match xs with
    | Nil -> True
    | Cons y ys ->
      match leq_nat n y with
      | True -> sorted xs
      | False -> 
        match insert n ys with
        | Nil -> True
        | Cons z zs ->
          match srtd_ins n ys with
          | True -> leq_nat y z
          | False -> False
          end
        end
      end
    end

let t20 = fun (n:nat) (xs:list nat) -> sorted (insert n xs)
let t20' = fun (n:nat) (xs:list nat) -> srtd_ins n xs

let t21 = fun (n:nat) (xs: list nat) -> 
  match sorted xs with
  | True -> srtd_ins n xs
  | False -> False
  end
let t21' = fun (n:nat) (xs: list nat) -> sorted xs


let t40 = fun (n:nat) (xs:list nat) (bs:list nat) ->
  match sorted xs with
  | True -> sorted (take nat n xs)
  | False -> not (sorted (app nat bs xs))
  end
let t40' = fun nat (list nat) (list nat) -> True

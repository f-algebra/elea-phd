let t1 = 
  fun (a:*) (y:a) (zs:list a) -> 
    rev a (app a zs (Cons a y (Nil a)))
let t1' =
  fun (a:*) (y:a) (xs:list a) -> 
    Cons a y ((
      fix (f: pi (list a)->list a) (xs:list a) ->
      match xs with
      | Nil -> Nil a
      | Cons x xs -> app a (f xs) (Cons a x (Nil a)) 
      end) xs)

let t2 = fun (x:nat) (y:nat) -> add x (Suc y)
let t2' = fun (x:nat) (y:nat) -> Suc (add x y)

let t3 = 
  fun (a:*) (xs:list a) (ys:list a) (zs:list a) ->
    app a (app a xs ys) zs
let t3' = 
  fun (a:*) (xs:list a) (ys:list a) (zs:list a) ->
    app a xs (app a ys zs)
  
let t4 = fun (x:nat) (y:nat) (z:nat) -> add (add x y) z
let t4' = fun (x:nat) (y:nat) (z:nat) -> add x (add y z)

let t5 =
  fix (f:pi nat -> bool) (x:nat) ->
    match x with | 0 -> True | Suc x' -> f x' end
let t5' = fun (x:nat) -> True

let t6 = 
  fun (n:nat) (xs:list nat) -> 
    count n (app nat xs (Cons nat n (Nil nat)))
let t6' = fun (n:nat) (xs:list nat) -> Suc (count n xs)

let t7 = fun (n:nat) (xs:list nat) -> count n (rev nat xs)
let t7' = fun (n:nat) (xs:list nat) -> count n xs

let t8 = fun (a: *) (xs: list a) -> rev a (rev a xs)
let t8' = fun (a: *) (xs: list a) -> xs

let t9 = fix (f: pi (a:*) (list a) -> list a) (a:*) (xs:list a) -> 
  match xs with
  | Nil -> Nil a
  | Cons x xs' -> Cons a x (f a xs')
  end
let t9' = fun (a:*) (xs:list a) -> xs

let t10 = fun (x:nat) (y:nat) -> or (leq_nat x y) (leq_nat y x)
let t10' = fun nat nat -> True

let t11 = fun (n:nat) (xs:list nat) (ys:list nat) -> 
  count n (app nat xs ys)
let t11' = fun (n:nat) (xs:list nat) (ys:list nat) -> 
  add (count n xs) (count n ys)

let t12 = fun (x:nat) (y:nat) (z:nat) -> 
  implies (and (leq_nat x y) (leq_nat y z)) (leq_nat x z)
let t12' = fun nat nat nat -> True

let t13 = fun (x:nat) (xs:list nat) ->
  match sorted xs with
  | True -> False
  | False -> sorted (Cons nat x xs)
  end
let t13' = fun nat (list nat) -> False
  
let t14 = fun (x:nat) (xs:list nat) -> 
  match sorted (Cons nat x xs) with
  | True -> sorted xs
  | False -> True
  end
let t14' = fun nat (list nat) -> True
    
let t15 = fun (a: *) (t: tree a) -> mirror a (mirror a t)
let t15' = fun (a: *) (t: tree a) -> t

let t16 = fun (a: *) (n: nat)
  (t1: tree a) (x: nat) (y: nat) -> 
    add (add n x) y
let t16' = fun (a: *) (n: nat)
  (t1: tree a) (x: nat) (y: nat) -> 
    add n (add x y)
    
let t17 = fun (a: *) (t: tree a) -> size a (mirror a t)
let t17' = fun (a:*) ->
  fix (height: pi (tree a) -> nat) ->
    fun (t: tree a) ->
    match t with
    | Leaf -> 1
    | Node x t1 t2 -> Suc (add (height t2) (height t1))
    end

let t18 = fun (n: nat) (m: nat) -> eq_nat (add n m) (add m n)
let t18' = fun nat nat -> True

let t19 = fun (n: nat) (t: tree nat) -> add (size nat t) n
let t19' = fun nat (tree nat) -> 0

let t50 = fun (t: list nat) -> sorted (treesort t)
let t50' = fun (list nat) -> True

let t51 = fun (n: nat) (as: list nat) (bs: list nat) -> 
  match sorted as with
  | True ->
    match sorted bs with
    | True -> sorted (app nat as (Cons nat n bs))
    | False -> False
    end
  | False -> False
  end
let t51' = fun nat (list nat) (list nat) -> False

let t52 = fun (n: nat) (as: list nat) (bs: list nat) -> 
  sorted (app nat as (Cons nat n bs))
let t52' = fun nat (list nat) (list nat) -> False
  
let t53 = fun (t: tree nat) -> sorted (flatten nat t)
let t53' = fun (tree nat) -> True

let last_leq =
  fun (n: nat) ->
  fix (last_leq: pi (tree nat) -> bool) (t: tree nat) ->
  match t with
  | Leaf -> True
  | Node x t1 t2 ->
    match t2 with
    | Leaf -> leq_nat x n
    | Node y t21 t22 -> last_leq t2
    end
  end
  
let first_gt =
  fun (n: nat) ->
  fix (first_gt: pi (tree nat) -> bool) (t: tree nat) ->
  match t with
  | Leaf -> True
  | Node x t1 t2 ->
    match t1 with
    | Leaf -> leq_nat n x
    | Node y t11 t12 -> first_gt t1
    end
  end

let sorted_tree = 
  fix (srtd: pi (tree nat) -> bool) (t: tree nat) ->
  match t with
  | Leaf -> True
  | Node x t1 t2 ->
    and (and (srtd t1) (srtd t2)) 
        (and (last_leq x t1) (first_gt x t2))
  end

let t55 = fun (xs: list nat) -> sorted_tree (build xs)
let t55' = _|_ bool

let t54 = fun (n: nat) (t: tree nat) -> 
  match sorted_tree t with
  | True -> sorted_tree (ins_tree n t)
  | False -> False
  end
let t54' = _|_ bool

/* requires invention of list-fold functions */
let t219 = fun (a: *) (t: tree a) -> length a (flatten a t)
let t219' = fun (a: *) (t: tree a) -> height a t

/* done, but takes ages */
let t110 = fun (xs:list nat) -> sorted (isort xs)
let t110' = fun (list nat) -> True

let t115 = fun (n:nat) (xs:list nat) -> sorted (insert n xs)
let t115' =
  fix (srtd_ins: pi nat (list nat) -> bool) ->
    fun (n: nat) (xs: list nat) -> 
    match xs with
    | Nil -> True
    | Cons y ys ->
      match leq_nat n y with
      | True -> sorted xs
      | False -> 
        match insert n ys with
        | Nil -> True
        | Cons z zs ->
          match leq_nat y z with
          | True -> srtd_ins n ys
          | False -> False
          end
        end
      end
    end
    
/* this one is just plain hard */
let t40 = fun (n:nat) (xs:list nat) (bs:list nat) ->
  match sorted xs with
  | True -> sorted (take nat n xs)
  | False -> not (sorted (app nat bs xs))
  end
let t40' = fun nat (list nat) (list nat) -> True

/* needs some form of multiple argument deforestation */
let t219 = fun (a: *) (t: tree a) ->
  eq_nat (height a t) (height a (mirror a t))
let t219' = fun (a: *) (tree a) -> True

let t1 = add 1 1
let t1' = 2

let t2 = mul 2 2
let t2' = add 2 2

let t3 = rev nat (Cons nat 1 (Cons nat 2 (Nil nat)))
let t3' = Cons nat 2 (Cons nat 1 (Nil nat))

let t4 = fun (a:*) ->
  fix (f: pi (list a) (list a) nat ->list a) (xs:list a) (y:list a) -> 
    match xs with
    | Nil -> fun (z:nat) -> y
    | Cons x xs' -> fun (z:nat) -> Cons a x (f xs' y
    (match z with | 0 -> 0 | Suc z' -> z' end)) end
let t4' = 
  fun (a:*) (xs:list a) (y:list a) -> 
  (fix (f: pi (list a) nat -> list a) (xs:list a) (z:nat) ->
  match xs with
  | Nil -> y
  | Cons x xs' -> match z with
    | 0 -> Cons a x (f xs' 0)
    | Suc z' -> Cons a x (f xs' z') end end) xs
    
let t5 = fix (f: pi nat nat ->nat) (x:nat) (y:nat) ->
  match x with
  | 0 -> y
  | Suc x' -> Suc (f x' y) end    
let t5' = fun (x:nat) (y:nat) ->
  (fix (f:pi nat->nat) (x:nat) ->
    match x with
    | 0 -> y
    | Suc x' -> Suc (f x') end) x

let t6 = 
  fun (a:*) (y:a) (xs:list a) -> app a xs (Cons a y (Nil a))
let t6' = 
  fun (a:*) (y:a) ->
    fix (app: pi (list a)->list a) (xs:list a) ->
    match xs with
    | Nil -> Cons a y (Nil a)
    | Cons x xs' -> Cons a x (app xs') end
  
let t7 = 
  fix (rev: pi (a:*) (list a) -> list a) (a:*) (xs:list a)->
    match xs with
    | Nil -> Nil a
    | Cons x ys -> (app a) (rev a ys) (Cons a x (Nil a))
    end
let t7' = 
  fun (a:*) -> 
    fix (f: pi (list a) -> list a) (xs: list a) ->
    match xs with
    | Nil -> Nil a
    | Cons x ys -> app a (f ys) (Cons a x (Nil a))
    end
    
let t8 = 
  fix (rap: pi (a:*) a (list a) -> list a) (a:*) (y:a) (xs:list a)->
    match xs with
    | Nil -> Cons a y (Nil a)
    | Cons x ys -> (app a) (rap a y ys) (Cons a x (Nil a))
    end
let t8' = 
  fun (a:*) (y:a) -> 
    fix (f: pi (list a) -> list a) (xs: list a) ->
    match xs with
    | Nil -> Cons a y (Nil a)
    | Cons x ys -> app a (f ys) (Cons a x (Nil a))
    end
    
let t9 = fun (a:*) (xs:list a) (n:nat) ->
  match leq_nat (len a xs) n with
  | True -> True
  | False -> 
    match n with
    | 0 -> True
    | Suc n' ->
      match xs with
      | Nil -> False
      | Cons x xs' -> leq_nat n' (len a xs')
      end
    end
  end
let t9' = fun (a:*) (xs:list a) (n:nat) ->
  match n with
  | 0 -> True
  | Suc n' ->
    match xs with
    | Nil -> True
    | Cons x xs' ->
      match leq_nat (len a xs') n' with
      | True -> True
      | False -> leq_nat n' (len a xs')
      end
    end
  end
  
let t10 = fun (p:bool) (q:bool) -> not (and (not p) (not q))
let t10' = or

let t11 = fun (p:bool) -> not (not p)
let t11' = id bool

let t12 = fun (xs:list nat) (ys:list nat) (n:nat) ->
  match app nat xs ys with
  | Nil -> False
  | Cons z zs -> eq_nat z n
  end
let t12' = fun (xs:list nat) (ys:list nat) (n:nat) ->
  match xs with
  | Nil -> 
    match ys with
    | Nil -> False
    | Cons z zs -> eq_nat z n
    end
  | Cons z zs -> eq_nat z n
  end
  
let t13 =  
  fix (srtd_ins: pi nat (list nat) -> bool) ->
    fun (n: nat) (xs: list nat) -> 
    match xs with
    | Nil -> True
    | Cons y ys ->
      match leq_nat n y with
      | True -> srtd_ins n (Nil nat)
      | False -> srtd_ins n ys
      end
    end
let t13' = 
  fix (srtd_ins: pi nat (list nat) -> bool) ->
    fun (n: nat) (xs: list nat) -> 
    match xs with
    | Nil -> True
    | Cons y ys ->
      match leq_nat n y with
      | True -> True
      | False -> srtd_ins n ys
      end
    end
    
let t14 = fun (a: *) ->  
  fix (height: pi (tree a) nat nat nat-> nat) ->
  fun (t: tree a) (m:nat) (y: nat) (n: nat)  ->
    match t with
    | Leaf -> y
    | Node x t1 t2 -> Suc (height t1 m (height t2 m y n) n)
    end
let t14' = fun (a: *) (t: tree a) (m: nat) (y: nat) (n: nat) ->  
  ((fix (height: pi (t: tree a) (y: nat) -> nat) ->
  fun (t: tree a) -> 
    fun (y: nat) ->
      match t with
      | Leaf -> y
      | Node x t1 t2 -> Suc (height t1 (height t2 y))
      end) t) y


/* Doesn't work for fiddly reasons */
let t30 = 
  fix (app: pi (a:*) (xs:list a) (ys:list a) -> list a) ->
    fun (a:*) (xs:list a) (ys:list a) ->
    match xs with
    | Nil -> ys
    | Cons z zs -> app a (Nil a) (Cons a z (app a zs ys))
    end
let t30' = app

